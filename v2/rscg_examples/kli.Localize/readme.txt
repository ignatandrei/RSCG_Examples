# Localize

Simple package to localize **strings** from json files via static source code generation.

Implemented via [C# source generators](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview)

[![CI\CD](https://github.com/kl1mm/localize/actions/workflows/dotnet.yml/badge.svg?branch=main)](https://github.com/kl1mm/localize/actions/workflows/dotnet.yml)

## Usage

_Also see [**example project**](https://github.com/kl1mm/localize/tree/develop/example/kli.Localize.Example)_

### Install the nuget package

Add a [Nuget package](https://www.nuget.org/packages/kli.Localize/) reference to the project file in the project you want to localize:  

`<PackageReference Include="kli.Localize" Version="<version>" />`

### Create \*.json files for your localized texts.

Example:

```json
{
    "SampleText": "FooBar",
    "Other": "Text42",
    "NestedItems": {
      "Are": "also supported"
    }
}
```

Name your localization files, including the culture according to the pattern: `<FileName>_<CultureInfo.Name>.json` (e.g. `Locale_de.json`). 
For other cultures follow the same pattern (e.g. `Locale_en-US.json` for American English or `Locale_en.json` for English).  
You have to specify which given culture is the neutral culture (the fallback used if there is no localization found for a specific culture)
via the `NeutralCulture` attribute on the `Localize` element.

![locale_files image][locale_files]

### Add json files to csproj

In an `ItemGroup` in your csproj file add an `Localize` element for **each localization** json file, include other cultures via glob pattern. 
Set the `Include` attribute to the path of the file and specify the neutral culture via the `NeutralCulture` attribute

Example:

```xml
<Project Sdk="Microsoft.NET.Sdk">
    <ItemGroup>
        <PackageReference Include="kli.Localize" Version="1.0.*" />

        <Localize Include="TestLocalizations\Locale_*.json" NeutralCulture="en"/>
    </ItemGroup>
</Project>
```

This means: if you have a `Locale_en.json` and a `Locale_en-US.json` add `Locale_*.json` as `<Localize>`, and specify either `en` or `en_US` as `NeutralCulture`.  
Add other files the same way in another `Localize` element.

### Use it in your code

Now you should be able to locate the generated source code in your project under Dependencies/Analyzers.  
_Of course you can also view and debug the generated source code._  

![generated_1 image][generated_1]  

<details>
  <summary>Generated code example</summary>

```csharp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by kli.Localize.Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace kli.Localize.Example.Localizations
{
    using System;
    using System.Globalization;
    using System.Collections.Generic;
    using Translations = System.Collections.Generic.Dictionary<string, string>;

    public sealed class Locale
    {
        private static readonly LocalizationProvider provider = new LocalizationProvider();
        public static IDictionary<string, string> GetAll(CultureInfo cultureInfo = null) => provider.GetValues(cultureInfo ?? CultureInfo.CurrentUICulture);
        public static string GetString(string key, CultureInfo cultureInfo = null) => provider.GetValue(key, cultureInfo ?? CultureInfo.CurrentUICulture);
        ///<summary>Similar to: Hallo Welt (German)</summary>
        public static string MyText => provider.GetValue(nameof(MyText), CultureInfo.CurrentUICulture);
        private class LocalizationProvider
        {
            delegate bool SelectorFunc<T>(Translations translations, out T arg);
            internal string GetValue(string key, CultureInfo cultureInfo)
            {
                bool ValueSelector(Translations translations, out string value)
                {
                    if (translations.TryGetValue(key, out value))
                        return true;
                    value = key;
                    return false;
                }

                return TraverseCultures<string>(cultureInfo, ValueSelector);
            }

            internal IDictionary<string, string> GetValues(CultureInfo cultureInfo)
            {
                bool ValueSelector(Translations translations, out Translations value)
                {
                    value = translations;
                    return true;
                }

                return TraverseCultures<Translations>(cultureInfo, ValueSelector);
            }

            private T TraverseCultures<T>(CultureInfo cultureInfo, SelectorFunc<T> selectorFunc)
            {
                if (resources.TryGetValue(cultureInfo, out Translations translations))
                {
                    if (selectorFunc(translations, out T result) || cultureInfo == CultureInfo.InvariantCulture)
                        return result;
                }

                return TraverseCultures<T>(cultureInfo.Parent, selectorFunc);
            }

            private static readonly Translations invariant = new()
            {{"MyText", "Hallo Welt (German)"}, };
            private static readonly Translations en = new()
            {{"MyText", "Hello World (English)"}, };
            private static readonly Dictionary<CultureInfo, Translations> resources = new()
            {{CultureInfo.InvariantCulture, invariant}, {new CultureInfo("en"), en}, };
        }
    }
}
```

</details>

  

Import the namespace where you put your \*.json files and use the generated code to access your localizations.  
Access is based on [CultureInfo.CurrentUICulture](https://docs.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.currentuiculture)
  
  

![useit image][useit]

### Namespace generation

The namespace is generated using the following pattern:  
`rootnamespace + relative directory structure`  

This behaviour can be overridden with the `NamespaceName` attribute on the `Localize` element.

### Class naming

The default class name in the generated code is the filename without the culture.

This behaviour can be overridden with the `ClassName` attribute on the `Localize` element.


## [Changelog](CHANGELOG.md)

## Help! Why is no code generated?

Directly after including the package sometimes the tooling (Visual Studio) gets stuck. If you encounter any problems with source generation try to restart Visual Studio and/or check the build log for warnings/errors.

## Need help? Problems?

Feel free to create an [Issue](https://github.com/kl1mm/localize/issues)

[locale_files]: docs/locale_files.png
[generated_1]: docs/generated_1.png
[useit]: docs/useit.png
