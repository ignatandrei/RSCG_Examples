# Enhanced.GetTypes

[![license](https://flat.badgen.net/github/license/duskembayev/Enhanced.GetTypes)](LICENSE)
[![nuget](https://flat.badgen.net/nuget/v/Enhanced.GetTypes?icon=nuget)](https://www.nuget.org/packages/Enhanced.GetTypes)

`Enhanced.GetTypes` is a NuGet package for observing derived types in current assembly in .NET applications **without reflection**.

## Motivation

The main goal of the package is to provide a way to get derived types in the current assembly without using reflection. This approach allows you to get the types at compile time and use them in different scenarios, such as registering them in the DI container, creating factories, etc.

## How to install
```shell
dotnet add package Enhanced.GetTypes
```

## How to use

Let's say you have an interface `IService` and you want to get all derived types of this interface in the current assembly.
To do this, you need to create a partial class and mark it with the `DerivedTypesAttribute` attribute.

```csharp
using System;
using System.Collections.Generic
using Enhanced.GetTypes;

namespace MyProject;

public partial class ProjectTypes
{
    [DerivedTypes(typeof(IService))]
    public partial IEnumerable<Type> GetServices();
}
```

The body of the method will be generated by the source generator and will contain a list of all derived types of the `IService` interface in the current assembly.

```csharp
// <auto-generated />
namespace MyProject
{
    partial class ProjectTypes
    {
        private partial System.Collections.Generic.IEnumerable<System.Type> GetServices()
        {
            yield return typeof(MyProject.People.PeopleService);
            yield return typeof(MyProject.Pets.PetsService);
            yield return typeof(MyProject.Cars.CarsService);
            yield break;
        }
    }
}
```

Now you can use the generated method to get all derived types of the `IService` interface for different purposes. For example, registering them in the DI container.

```csharp
// ...
var serviceDescriptors = ProjectTypes.GetServices()
                                     .Select(type => ServiceDescriptor.Transient(typeof(IService), type);

builder.Services.TryAddEnumerable(serviceDescriptors);
```

Additionally, you can specify flags for the `DerivedTypesAttribute` attribute to filter the types you need.

- `IncludeInternal` - include internal types.
- `IncludeAbstract` - include abstract types.
- `IncludeInterfaces` - include interfaces.

```csharp
// ...
[DerivedTypes(typeof(IService), IncludeInternal = true, IncludeAbstract = true, IncludeInterfaces = true)]
public partial IEnumerable<Type> GetServices();
```

### Important notes

- The method marked with the `DerivedTypesAttribute` attribute must return `IEnumerable<Type>`.
- Types from referenced assemblies are not included.
