# AutoCompose

[![Nuget](https://img.shields.io/nuget/v/FarSkeptic.AutoCompose?style=flat-square)](https://www.nuget.org/packages/FarSkeptic.AutoCompose/)
[![Nuget Preview](https://img.shields.io/nuget/vpre/FarSkeptic.AutoCompose?style=flat-square&label=nuget%20preview)](https://www.nuget.org/packages/FarSkeptic.AutoCompose/)
[![License](https://img.shields.io/github/license/farskeptic/AutoCompose?style=flat-square)](https://github.com/farskeptic/AutoCompose/blob/main/LICENSE)
[![Downloads](https://img.shields.io/nuget/dt/FarSkeptic.AutoCompose?style=flat-square)](https://www.nuget.org/packages/FarSkeptic.AutoCompose/)
[![GitHub Sponsors](https://img.shields.io/github/sponsors/farskeptic)](https://github.com/sponsors/farskeptic)
[![GitHub](https://img.shields.io/badge/-source-181717.svg?logo=GitHub)](https://github.com/farskeptic/autocompose)

AutoCompose is a .NET source generator that allows the implementation of an interface via composition without having to implement pass-thru code.  There is no runtime reflection.
  - All unimplemented properties and methods on the interface are automatically generated as pass-thru logic.  
  - Any implemented properties or methods will NOT be generated by AutoCompose.
  - As you add or remove implementations, AutoCompose re-generates to compensate.


This allows object composition to be used as easily as inheritance.

# Getting Started

Given an interface named **ISample**:

Create a class implementing **ISample** via composition using AutoCompose by:
1. Implementing a partial class
1. Adding the instance of the interface as a member variable (e.g. _sample)
1. Injecting the variable in the constructor
1. Decorating the class with the AutoCompose attribute

```csharp
[AutoCompose(typeof(ISample), "_sample")]
public partial class Sample: ISample
{
    protected ISample _sample;

    // all non-implemented properties and methods are automatically generated as pass-thru logic
    public Sample(ISample sample) 
    {
        _sample = sample;
    }

    :
}
```

AutoCompose runs at compile time, and generates the source required to fully implement the interface.


# Composition as easily as Inheritance

When trying to decide between inheritance or composition, the amount of pass-thru code that must be coded and maintained often plays a role in the decision.

Example: When we need to override the implementation of a single method for an interface that contains 10 methods, the code burden of implementing and maintaing the 9 pass-thru methods often causes developers to choose inheritance over composition, regardless of other considerations.

**With AutoCompose, this issue goes away.  The developer is free to choose inheritance or composition for purely architectural reasons, without having to worry about implementation or maintenance difficulties.**

# When should I use AutoCompose?

Any time you want to use composition, and have at least one property or method that would be implemented as pass-thru code, AutoCompose can take that burden away from you.

# Known Limitations

1. AutoCompose currently works for interfaces only.  It DOES NOT work (yet) for abstract classes.
1. AutoCompose may not work if your code has multiple definitions of an interface with the same name.  AutoCompose (currently) just picks the first matching symbol, and so does not discriminate the target-interface based purely on namespaces.
1. If your code contains extremely deep namespaces and would generate source code files with very long names, then there can be filename-length conflicts with the windows file system.


