// <auto-generated>
// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator
// The tool used to generate this code may be subject to license terms;
// this generated code is however not subject to those terms, instead it is
// subject to the license (if any) applied to the containing project.
// </auto-generated>
#nullable enable
#pragma warning disable

namespace RhoMicro.CodeAnalysis
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Defines options for generating union types.
    /// </summary>
    [Flags]
    enum UnionTypeOptions
    {
        /// <summary>
        /// The default options.
        /// </summary>
        Default = ImplicitConversionIfSolitary,
        /// <summary>
        /// </summary>
        None = 0x00,
        /// <summary>
        /// Instructs the generator to emit an implicit conversion to the representable type if it is the only one.
        /// In effect, this option will enable the union type to act as an alias wrapper for the representable type.
        /// </summary>
        ImplicitConversionIfSolitary = 0x01,
        /// <summary>
        /// Instructs the generator to emit a superset conversion operator implementation even though
        /// the representable type is a generic type parameter. By default, it is omitted because of possible
        /// unification for certain generic arguments.
        /// </summary>
        //SupersetOfParameter = 0x02,
        /// <summary>
        /// Instructs the generator to treat the representable reference type 
        /// as nullable, allowing for <see langword="null"/> 
        /// arguments in factories, conversions etc.
        /// </summary>
        Nullable = 0x04
    }

    /// <summary>
    /// Defines options for the storage implementation of a representable type.
    /// In order for the generator to generate an efficient storage implementation, 
    /// consumers should communicate whether the representable type is known to
    /// be a struct, class or of unknown nature. This is mostly relevant for generic
    /// type parameters, however an explicit strategy may be selected for any representable
    /// type. Whether or not generic type parameters are known to be reference
    /// or value types depends on their constraints. Parameters constrained to 
    /// <see langword="struct"/> will be assumed to be value types. Conversely,
    /// parameters constrained to <see langword="class"/> will be assumed to be reference types.
    /// </summary>
    /*
               | box |value| auto | field
        struct | rc! | vc  | vc   | cc
        class  | rc  | rc! | rc   | cc
        none   | rc! | vc! | rc!  | cc
    */
    enum StorageOption
    {
        /// <summary>
        /// The generator will automatically decide on a storage strategy.
        /// <para>
        /// If the representable type is <b>known to be a value type</b>,
        /// this will store values of that type inside a shared value type container.
        /// <b>Boxing will not occur.</b>
        /// </para>
        /// <para>
        /// If the representable type is <b>known to be a reference type</b>,
        /// this will store values of that type inside a shared reference type container.
        /// </para>
        /// <para>
        /// If the representable type is <b>neither known to be a reference type
        /// nor a value type</b>, this option will cause values of that type to 
        /// be stored inside a shared reference type container.
        /// <b>If the representable type is a generic type parameter,
        /// boxing will occur for value type arguments to that parameter.</b>
        /// </para>
        /// </summary>
        Auto,

        /// <summary>
        /// The generator will always store values of the representable type
        /// inside a shared reference type container.
        /// <para>
        /// If the representable type is <b>known to be a value type</b>,
        /// <b>boxing will occur</b>.
        /// </para>
        /// <para>
        /// If the representable type is a <b>generic type parameter</b>,
        /// <b>boxing will occur for value type arguments</b> to that parameter.
        /// </para>
        /// </summary>
        Reference,

        /// <summary>
        /// The generator will attempt to store values of the representable type
        /// inside a value type container.
        /// <para>
        /// If the representable type is <b>known to be a value type</b>,
        /// this will store values of that type inside a shared value type container.
        /// <b>Boxing will not occur.</b>
        /// </para>
        /// <para>
        /// If the representable type is <b>known to be a reference type</b>,
        /// this will store values of that type inside a shared reference type container.
        /// <b>Boxing will not occur.</b>
        /// </para>
        /// <para>
        /// If the representable type is <b>neither known to be a reference type
        /// nor a value type</b>, this option will cause values of that type to 
        /// be stored inside a shared value type container.
        /// <b>If the representable type is a generic type parameter,
        /// an exception of type <see cref="TypeLoadException"/> will occur for
        /// reference type arguments to that parameter.</b>
        /// </para>
        /// </summary>
        Value,

        /// <summary>
        /// The generator will attempt to store values of the representable type
        /// inside a dedicated container for that type.
        /// <para>
        /// If the representable type is <b>known to be a value type</b>,
        /// this will store values of that type inside a dedicated 
        /// value type container.
        /// <b>Boxing will not occur.</b>
        /// </para>
        /// <para>
        /// If the representable type is <b>known to be a reference type</b>,
        /// this will store values of that type inside a 
        /// dedicated reference type container.
        /// </para>
        /// <para>
        /// If the representable type is <b>neither known to be a reference type
        /// nor a value type</b>, this option will cause values of that type to 
        /// be stored inside a dedicated strongly typed container.
        /// <b>Boxing will not occur.</b>
        /// </para>
        /// </summary>
        Field
    }

    /// <summary>
    /// Marks the target type as a union type being able to represent the type passed to the constructor.
    /// </summary>
    [AttributeUsage(( (AttributeTargets)( -1 ) ))]
    partial class UnionTypeBaseAttribute : Attribute
    {
        /// <summary>
        /// Gets or sets the alias groups that the representable type is to be a part of. 
        /// Represnetable types that share a group may be checked for using unified methods 
        /// and properties like <c>IsGroup</c> where <c>Group</c> is the name of the group
        /// that the representable type is a part of.
        /// </summary>
        public virtual String[] Groups { get; set; } = Array.Empty<String>();

        /// <summary>
        /// Gets or sets the generator options to use.
        /// </summary>
        public virtual UnionTypeOptions Options { get; set; } = UnionTypeOptions.Default;

        /// <summary>
        /// Gets or sets the option defining storage generation.
        /// </summary>
        public virtual StorageOption Storage { get; set; }
    }
    [AttributeUsage(( (AttributeTargets)( -1 ) ))]
#if UNIONS_GENERATOR
    [GenerateFactory(OmitTypeCheck = true)]
#endif
    partial class AliasedUnionTypeBaseAttribute : UnionTypeBaseAttribute
    {
        /// <summary>
        /// Gets or sets the alias to use for members representing the type represented by the union.
        /// For example, the represented type <see cref="List{T}"/> would be represented using names like
        /// <c>list_of_T</c>. Setting this property to <c>yourAlias</c> will instruct the generator to use
        /// member names like <c>yourAlias</c> instead of <c>list_of_T</c>. Use this property to avoid
        /// name collisions in generated code. Since the alias will be used for member names, it will
        /// only be taken into account if it is a valid identifier name.
        /// </summary>
        public String? Alias { get; set; }
        /// <inheritdoc/>
        public override String[] Groups { get => base.Groups; set => base.Groups = value; }
        /// <inheritdoc/>
        public override UnionTypeOptions Options { get => base.Options; set => base.Options = value; }
        /// <inheritdoc/>
        public override StorageOption Storage { get => base.Storage; set => base.Storage = value; }
    }
    /// <summary>
    /// Marks the target type as a union type being able to represent <typeparamref name="T0"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    sealed partial class UnionTypeAttribute<T0> : AliasedUnionTypeBaseAttribute
    { }
    /// <summary>
    /// Marks the target type as a union type being able to represent 
    /// <typeparamref name="T0"/>
    /// and <typeparamref name="T1"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    sealed partial class UnionTypeAttribute<T0, T1> : UnionTypeBaseAttribute
    { }
    /// <summary>
    /// Marks the target type as a union type being able to represent 
    /// <typeparamref name="T0"/>,
    /// <typeparamref name="T1"/>
    /// and <typeparamref name="T2"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    sealed partial class UnionTypeAttribute<T0, T1, T2> : UnionTypeBaseAttribute
    { }
    /// <summary>
    /// Marks the target type as a union type being able to represent 
    /// <typeparamref name="T0"/>,
    /// <typeparamref name="T1"/>,
    /// <typeparamref name="T2"/>
    /// and <typeparamref name="T3"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    sealed partial class UnionTypeAttribute<T0, T1, T2, T3> : UnionTypeBaseAttribute
    { }
    /// <summary>
    /// Marks the target type as a union type being able to represent 
    /// <typeparamref name="T0"/>,
    /// <typeparamref name="T1"/>,
    /// <typeparamref name="T2"/>,
    /// <typeparamref name="T3"/>
    /// and <typeparamref name="T4"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4> : UnionTypeBaseAttribute
    { }
    /// <summary>
    /// Marks the target type as a union type being able to represent 
    /// <typeparamref name="T0"/>,
    /// <typeparamref name="T1"/>,
    /// <typeparamref name="T2"/>,
    /// <typeparamref name="T3"/>,
    /// <typeparamref name="T4"/>
    /// and <typeparamref name="T5"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4, T5> : UnionTypeBaseAttribute
    { }
    /// <summary>
    /// Marks the target type as a union type being able to represent 
    /// <typeparamref name="T0"/>,
    /// <typeparamref name="T1"/>,
    /// <typeparamref name="T2"/>,
    /// <typeparamref name="T3"/>,
    /// <typeparamref name="T4"/>,
    /// <typeparamref name="T5"/>
    /// and <typeparamref name="T6"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4, T5, T6> : UnionTypeBaseAttribute
    { }
    /// <summary>
    /// Marks the target type as a union type being able to represent 
    /// <typeparamref name="T0"/>,
    /// <typeparamref name="T1"/>,
    /// <typeparamref name="T2"/>,
    /// <typeparamref name="T3"/>,
    /// <typeparamref name="T4"/>,
    /// <typeparamref name="T5"/>,
    /// <typeparamref name="T6"/>
    /// and <typeparamref name="T7"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4, T5, T6, T7> : UnionTypeBaseAttribute
    { }
    /// <summary>
    /// Marks the target type as a union type being able to represent the annotated type parameter.
    /// </summary>
    [AttributeUsage(AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]
    sealed partial class UnionTypeAttribute : AliasedUnionTypeBaseAttribute
    { }
}