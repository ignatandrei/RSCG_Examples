// <auto-generated>
// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator
// The tool used to generate this code may be subject to license terms;
// this generated code is however not subject to those terms, instead it is
// subject to the license (if any) applied to the containing project.
// </auto-generated>
#nullable enable
#pragma warning disable

namespace RhoMicro.CodeAnalysis;

using System;

#region Setting Enums
/// <summary>
/// Defines settings for generating an implementation of <see cref="Object.ToString"/>.
/// </summary>
enum ToStringSetting
{
    /// <summary>
    /// The generator will emit an implementation that returns detailed information, including:
    /// <list type="bullet">
    /// <item><description>the name of the union type</description></item>
    /// <item><description>a list of types representable by the union type</description></item>
    /// <item><description>an indication of which type is being represented by the instance</description></item>
    /// <item><description>the value currently being represented by the instance</description></item>
    /// </list>
    /// </summary>
    Detailed,
    /// <summary>
    /// The generator will not generate an implementation of <see cref="Object.ToString"/>.
    /// </summary>
    None,
    /// <summary>
    /// The generator will generate an implementation that returns the result of calling <see cref="Object.ToString"/> on the currently represented value.
    /// </summary>
    Simple
}
/// <summary>
/// Defines settings for annotating the target with an instance of <see cref="System.Runtime.InteropServices.StructLayoutAttribute"/>.
/// </summary>
enum LayoutSetting
{
    /// <summary>
    /// Generate an annotation optimized for size.
    /// </summary>
    Small,
    /// <summary>
    /// Do not generate any annotations.
    /// </summary>
    Auto
}
/// <summary>
/// Defines settings for controlling the accessibility of generated constructors.
/// </summary>
enum ConstructorAccessibilitySetting
{
    /// <summary>
    /// Generated constructors should always be private, unless
    /// no conversion operators are generated for the type they
    /// accept. This would be the case for interface types or
    /// supertypes of the target union.
    /// </summary>
    PublicIfInconvertible,
    /// <summary>
    /// Generated constructors should always be private.
    /// </summary>
    Private,
    /// <summary>
    /// Generated constructors should always be public
    /// </summary>
    Public
}
/// <summary>
/// Defines settings on how to implement interfaces that all representable
/// types implement.
/// </summary>
enum InterfaceMatchSetting
{
    /// <summary>
    /// Generated interface implementations should be explicit if at least
    /// one of the representable types implements the interface explicitly;
    /// otherwise, interface implementations should be implicit.
    /// </summary>
    Auto,
    /// <summary>
    /// Generated interface implementations should always be explicit.
    /// </summary>
    Explicit,
    /// <summary>
    /// Generated interface implementations should always be implicit.
    /// </summary>
    Implicit,
    /// <summary>
    /// No interfaces implementations should be generated.
    /// </summary>
    Omit
}
/// <summary>
/// Defines settings for the kind of diagnostics to report.
/// </summary>
[Flags]
enum DiagnosticsLevelSettings
{
    /// <summary>
    /// Instructs the analyzer not to emit diagnostics
    /// </summary>
    None = 0x00,
    /// <summary>
    /// Instructs the analyzer to report info diagnostics.
    /// </summary>
    Info = 0x01,
    /// <summary>
    /// Instructs the analyzer to report warning diagnostics.
    /// </summary>
    Warning = 0x02,
    /// <summary>
    /// Instructs the analyzer to report error diagnostics.
    /// </summary>
    Error = 0x04,
    /// <summary>
    /// Instructs the analyzer to report all diagnostics.
    /// </summary>
    All = Info | Warning | Error
}
/// <summary>
/// Defines miscellaneous settings.
/// </summary>
[Flags]
enum MiscellaneousSettings
{
    /// <summary>
    /// </summary>
    None = 0x00,
    /// <summary>
    /// The default settings.
    /// </summary>
    Default = None,
    /// <summary>
    /// Indicates whether the generated source code should be available as a string constant on the union type itself.
    /// This setting is generally only useful if the generated implementation should be emitted from another generator.
    /// </summary>
    EmitGeneratedSourceCode = 0x01,
    /// <summary>
    /// Indicates whether to generate a custom converter type 
    /// for <c>System.Text.Json</c> deserialization. If set, this will also cause
    /// the union type to be annotated with an appropriate <c>JsonConverter</c> attribute.
    /// </summary>
    GenerateJsonConverter = 0x02,
    /// <summary>
    /// Indicates that the generator should emit a comment detailing the structure of the union type.
    /// </summary>
    EmitStructuralRepresentation = 0x04
}

/// <summary>
/// Defines settings pertaining to equality operator implementations.
/// </summary>
enum EqualityOperatorsSetting
{
    /// <summary>
    /// Equality operators will be emitted only if the target union type is a value type.
    /// </summary>
    EmitOperatorsIfValueType,
    /// <summary>
    /// Equality operators will be emitted.
    /// </summary>
    EmitOperators,
    /// <summary>
    /// Equality operators will be omitted.
    /// </summary>
    OmitOperators
}

#endregion
#region Attribute Declaration
/// <summary>
/// Supplies the generator with additional settings on how to generate a targeted union type.
/// If the target member is an assembly, the attribute supplies default values for any union 
/// type setting not defined.
/// </summary>
[AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class | AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)]
#if UNIONS_GENERATOR
[GenerateFactory]
#endif
sealed partial class UnionTypeSettingsAttribute : Attribute
{
    #region Settings
    /// <summary>
    /// Defines how to generate an implementation <see cref="Object.ToString"/>.
    /// </summary>
    public ToStringSetting ToStringSetting { get; set; } = ToStringSetting.Detailed;
    /// <summary>
    /// Defines whether to generate a size optimizing annotation.
    /// </summary>
    public LayoutSetting Layout { get; set; } = LayoutSetting.Auto;
    /// <summary>
    /// The level of diagnostics to be reported by the analyzer.
    /// </summary>
    public DiagnosticsLevelSettings DiagnosticsLevel { get; set; } = DiagnosticsLevelSettings.All;
    /// <summary>
    /// The desired accessibility of generated constructors.
    /// </summary>
    public ConstructorAccessibilitySetting ConstructorAccessibility { get; set; } = ConstructorAccessibilitySetting.Private;
    /// <summary>
    /// Indicates how to generate implementations for
    /// interfaces implemented by all representable types. Implementations will 
    /// map calls to interface instance methods and properties onto the represented
    /// value. 
    /// <para>
    /// Please note that currently, only fully bound and constructed interface implementations are supported.
    /// </para>
    /// </summary>
    public InterfaceMatchSetting InterfaceMatchSetting { get; set; } = InterfaceMatchSetting.Auto;
    /// <summary>
    /// Indicates how to generate equality operators.
    /// By default, equality operators will only be emitted for value types, so as to preserve
    /// reference equality for comparing reference union types via <c>==</c> or <c>!=</c>.
    /// </summary>
    public EqualityOperatorsSetting EqualityOperatorsSetting { get; set; } = EqualityOperatorsSetting.EmitOperatorsIfValueType;
    /// <summary>
    /// Gets or sets miscellaneous settings.
    /// </summary>
    public MiscellaneousSettings Miscellaneous { get; set; } = MiscellaneousSettings.Default;
    #endregion
    #region Strings
    /// <summary>
    /// A raw code preface to prepend before the generated type declaration.
    /// </summary>
    public String TypeDeclarationPreface { get; set; } = "";
    /// <summary>
    /// The name of the generic parameter for generic <c>Is</c>, <c>As</c> and factory methods. 
    /// Set this property in order to avoid name collisions with generic union type parameters
    /// </summary>
    public String GenericTValueName { get; set; } = "TValue";
    /// <summary>
    /// The name of the generic parameter for the <c>TryConvert</c> method. 
    /// Set this property in order to avoid name collisions with generic union type parameters
    /// </summary>
    public String TryConvertTypeName { get; set; } = "TUnion";
    /// <summary>
    /// The name of the generic parameter for the <c>Match</c> method. 
    /// Set this property in order to avoid name collisions with generic union type parameters
    /// </summary>
    public String MatchTypeName { get; set; } = "TMatchResult";
    /// <summary>
    /// The name to use for the discriminating tag type.
    /// </summary>
    public String TagTypeName { get; set; } = "__Tag";
    /// <summary>
    /// The name to use for the container type containing value types.
    /// </summary>
    public String ValueTypeContainerTypeName { get; set; } = "__ValueTypeContainer";
    /// <summary>
    /// The name to use for the field containing value types.
    /// </summary>
    public String ValueTypeContainerName { get; set; } = "__value";
    /// <summary>
    /// The name to use for the field containing reference types.
    /// </summary>
    public String ReferenceTypeContainerName { get; set; } = "__reference";
    /// <summary>
    /// The name to use for the field containing the discriminating tag.
    /// </summary>
    public String TagFieldName { get; set; } = "__tag";
    /// <summary>
    /// The name to use for the default (uninitialized) tag value.
    /// </summary>
    public String TagNoneName { get; set; } = "__None";
    /// <summary>
    /// The name of the generated json converter type.
    /// </summary>
    public String JsonConverterTypeName { get; set; } = "JsonConverter";
    #endregion
}
#endregion