// <auto-generated />
#nullable enable
using System;
using System.CodeDom.Compiler;
using System.Collections;
#if NET8_0_OR_GREATER
using System.Collections.Frozen;
#endif
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace EnumClassDemo;
/// <summary>
/// Extension methods for the <see cref = "Colors"/> enum.
/// </summary>
[GeneratedCode("FusionReactor.SourceGenerators.EnumExtensions", null)]
public static partial class ColorsExtensions
{
#if NET8_0_OR_GREATER
private static readonly FrozenDictionary<Colors, Int32> content
  = new Dictionary<Colors, Int32>
    {
        { Colors.None, 0 },
{ Colors.Red, 1 },
{ Colors.Green, 2 },
{ Colors.Blue, 4 },

    }
    .ToFrozenDictionary();
#else
    private static readonly Dictionary<Colors, Int32> contentDictionary = new Dictionary<Colors, Int32>
    {
        {
            Colors.None,
            0
        },
        {
            Colors.Red,
            1
        },
        {
            Colors.Green,
            2
        },
        {
            Colors.Blue,
            4
        },
    };
    private static readonly IReadOnlyDictionary<Colors, Int32> content = new ReadOnlyDictionary<Colors, Int32>(contentDictionary);
#endif
#if NET8_0_OR_GREATER
private static readonly FrozenSet<string> names = new []
{
    "None",
"Red",
"Green",
"Blue",

}
.ToFrozenSet();
#elif NET5_0_OR_GREATER
private static readonly IReadOnlySet<string> names = new HashSet<string>()
{
    "None",
"Red",
"Green",
"Blue",

};
#else
    private static readonly HashSet<string> names = new HashSet<string>()
    {
        "None",
        "Red",
        "Green",
        "Blue",
    };
#endif
#if NET8_0_OR_GREATER
private static readonly FrozenSet<Colors> values = new []
{
    Colors.None,
Colors.Red,
Colors.Green,
Colors.Blue,

}
.ToFrozenSet();
#elif NET5_0_OR_GREATER
private static readonly IReadOnlySet<Colors> values = new HashSet<Colors>()
{
    Colors.None,
Colors.Red,
Colors.Green,
Colors.Blue,

};
#else
    private static readonly HashSet<Colors> values = new HashSet<Colors>()
    {
        Colors.None,
        Colors.Red,
        Colors.Green,
        Colors.Blue,
    };
#endif
    /// <summary>
    /// Gets the content dictionary containing mappings of <see cref = "Colors"/> enum values to values.
    /// </summary>
    /// <returns>The read-only content dictionary.</returns>
    
#if NET8_0_OR_GREATER
public static FrozenDictionary<Colors, Int32> GetContent()
#else
    public static IReadOnlyDictionary<Colors, Int32> GetContent()
#endif
    {
        return content;
    }

    /// <summary>
    /// Gets the content dictionary containing mappings of <see cref = "Colors"/> enum values to values.
    /// </summary>
    /// <param name = "enumValue">The enum value for which to get the content dictionary.</param>
    /// <returns>The read-only content dictionary.</returns>
    
#if NET8_0_OR_GREATER
public static FrozenDictionary<Colors, Int32> GetContent(this Colors enumValue)
#else
    public static IReadOnlyDictionary<Colors, Int32> GetContent(this Colors enumValue)
#endif
    {
        return content;
    }

    /// <summary>
    /// Retrieves the name of the constant in the <see cref = "Colors"/>.
    /// </summary>
    /// <param name = "enumValue">The enum value to convert.</param>
    /// <returns>
    /// A string containing the name of the <see cref = "Colors"/>;
    /// or <see langword="null"/> if no such constant is found.
    /// </returns>
    public static string? GetName(this Colors enumValue)
    {
        return enumValue switch
        {
            Colors.None => nameof(Colors.None),
            Colors.Red => nameof(Colors.Red),
            Colors.Green => nameof(Colors.Green),
            Colors.Blue => nameof(Colors.Blue),
            _ => null
        };
    }

    /// <summary>
    /// Retrieves all available names of the <see cref = "Colors"/>.
    /// </summary>
    /// <returns>An enumerable collection of <see cref = "Colors"/> names.</returns>
    
#if NET8_0_OR_GREATER
public static FrozenSet<string> GetNames()
#elif NET5_0_OR_GREATER
public static IReadOnlySet<string> GetNames()
#else
    public static HashSet<string> GetNames()
#endif
    {
        return names;
    }

    /// <summary>
    /// Retrieves all available names of the <see cref = "Colors"/>.
    /// </summary>
    /// <param name = "enumValue">The enumeration value.</param>
    /// <returns>An enumerable collection of <see cref = "Colors"/> names.</returns>
    
#if NET8_0_OR_GREATER
public static FrozenSet<string> GetNames(this Colors enumValue)
#elif NET5_0_OR_GREATER
public static IReadOnlySet<string> GetNames(this Colors enumValue)
#else
    public static HashSet<string> GetNames(this Colors enumValue)
#endif
    {
        return names;
    }

    /// <summary>
    /// Retrieves all available values of the <see cref = "Colors"/>.
    /// </summary>
    /// <returns>An enumerable collection of <see cref = "Colors"/> values.</returns>
    
#if NET8_0_OR_GREATER
public static FrozenSet<Colors> GetValues()
#elif NET5_0_OR_GREATER
public static IReadOnlySet<Colors> GetValues()
#else
    public static HashSet<Colors> GetValues()
#endif
    {
        return values;
    }

    /// <summary>
    /// Retrieves all available values of the <see cref = "Colors"/>.
    /// </summary>
    /// <param name = "enumValue">The enumeration value.</param>
    /// <returns>An enumerable collection of <see cref = "Colors"/> values.</returns>
    
#if NET8_0_OR_GREATER
public static FrozenSet<Colors> GetValues(this Colors enumValue)
#elif NET5_0_OR_GREATER
public static IReadOnlySet<Colors> GetValues(this Colors enumValue)
#else
    public static HashSet<Colors> GetValues(this Colors enumValue)
#endif
    {
        return values;
    }

    /// <summary>
    /// Parses the specified string representation of the enumeration value to its corresponding
    /// <see cref = "Colors"/> value.
    /// </summary>
    /// <param name = "value">A string containing the name or value to convert.</param>
    /// <param name = "ignoreCase">
    /// A boolean indicating whether to ignore case during the parsing. Default is <c>false</c>.
    /// </param>
    /// <returns>
    /// The <see cref = "Colors"/> value equivalent to the specified string representation.
    /// </returns>
    public static Colors Parse(string value, bool ignoreCase = false)
    {
        if (ignoreCase)
        {
            return value.ToLowerInvariant() switch
            {
                "none" => Colors.None,
                "red" => Colors.Red,
                "green" => Colors.Green,
                "blue" => Colors.Blue,
                _ => throw new ArgumentException(),
            };
        }
        else
        {
            return value switch
            {
                "None" => Colors.None,
                "Red" => Colors.Red,
                "Green" => Colors.Green,
                "Blue" => Colors.Blue,
                _ => throw new ArgumentException(),
            };
        }
    }

    /// <summary>
    /// Parses the specified string representation of the enumeration value to its corresponding
    /// <see cref = "Colors"/> value.
    /// </summary>
    /// <param name = "enumValue">The current <see cref = "Colors"/> value.</param>
    /// <param name = "value">A string containing the name or value to convert.</param>
    /// <param name = "ignoreCase">
    /// A boolean indicating whether to ignore case during the parsing. Default is <c>false</c>.
    /// </param>
    /// <returns>
    /// The <see cref = "Colors"/> value equivalent to the specified string representation.
    /// </returns>
    public static Colors Parse(this Colors enumValue, string value, bool ignoreCase = false)
    {
        if (ignoreCase)
        {
            return value.ToLowerInvariant() switch
            {
                "none" => Colors.None,
                "red" => Colors.Red,
                "green" => Colors.Green,
                "blue" => Colors.Blue,
                _ => throw new ArgumentException(),
            };
        }
        else
        {
            return value switch
            {
                "None" => Colors.None,
                "Red" => Colors.Red,
                "Green" => Colors.Green,
                "Blue" => Colors.Blue,
                _ => throw new ArgumentException(),
            };
        }
    }

    /// <summary>
    /// Tries to parse the specified string representation of an enumeration value to its corresponding
    /// <see cref = "Colors"/> enumeration value.
    /// </summary>
    /// <param name = "value">The string representation of the enumeration value.</param>
    /// <param name = "result">
    /// When this method returns, contains the <see cref = "Colors"/> value equivalent
    /// to the string representation, if the parse succeeded, or default(Colors) if the parse failed.</param>
    /// <returns><c>true</c> if the parsing was successful; otherwise, <c>false</c>.</returns>
    public static bool TryParse(string value, out Colors? result)
    {
        return TryParse(value, false, out result);
    }

    /// <summary>
    /// Tries to parse the specified string representation of an enumeration value to its corresponding
    /// <see cref = "Colors"/> enumeration value.
    /// </summary>
    /// <param name = "value">The string representation of the enumeration value.</param>
    /// <param name = "ignoreCase">A boolean indicating whether case should be ignored when parsing.</param>
    /// <param name = "result">
    /// When this method returns, contains the <see cref = "Colors"/> value equivalent
    /// to the string representation, if the parse succeeded, or default(Colors) if the parse failed.</param>
    /// <returns><c>true</c> if the parsing was successful; otherwise, <c>false</c>.</returns>
    public static bool TryParse(string value, bool ignoreCase, out Colors? result)
    {
        if (ignoreCase)
        {
            result = value.ToLowerInvariant() switch
            {
                "none" => Colors.None,
                "red" => Colors.Red,
                "green" => Colors.Green,
                "blue" => Colors.Blue,
                _ => null,
            };
        }
        else
        {
            result = value switch
            {
                "None" => Colors.None,
                "Red" => Colors.Red,
                "Green" => Colors.Green,
                "Blue" => Colors.Blue,
                _ => null,
            };
        }

        return result != null;
    }

    /// <summary>
    /// Tries to parse the specified string representation of an enumeration value to its corresponding
    /// <see cref = "Colors"/> enumeration value.
    /// </summary>
    /// <param name = "enumValue">The enumeration value to parse.</param>
    /// <param name = "value">The string representation of the enumeration value.</param>
    /// <param name = "result">
    /// When this method returns, contains the <see cref = "Colors"/> value equivalent
    /// to the string representation, if the parse succeeded, or default(Colors) if the parse failed.</param>
    /// <returns><c>true</c> if the parsing was successful; otherwise, <c>false</c>.</returns>
    public static bool TryParse(this Colors enumValue, string value, out Colors? result)
    {
        return TryParse(value, false, out result);
    }

    /// <summary>
    /// Tries to parse the specified string representation of an enumeration value to its corresponding
    /// <see cref = "Colors"/> enumeration value.
    /// </summary>
    /// <param name = "enumValue">The enumeration value to parse.</param>
    /// <param name = "value">The string representation of the enumeration value.</param>
    /// <param name = "ignoreCase">A boolean indicating whether case should be ignored when parsing.</param>
    /// <param name = "result">
    /// When this method returns, contains the <see cref = "Colors"/> value equivalent
    /// to the string representation, if the parse succeeded, or default(Colors) if the parse failed.</param>
    /// <returns><c>true</c> if the parsing was successful; otherwise, <c>false</c>.</returns>
    public static bool TryParse(this Colors enumValue, string value, bool ignoreCase, out Colors? result)
    {
        if (ignoreCase)
        {
            result = value.ToLowerInvariant() switch
            {
                "none" => Colors.None,
                "red" => Colors.Red,
                "green" => Colors.Green,
                "blue" => Colors.Blue,
                _ => null,
            };
        }
        else
        {
            result = value switch
            {
                "None" => Colors.None,
                "Red" => Colors.Red,
                "Green" => Colors.Green,
                "Blue" => Colors.Blue,
                _ => null,
            };
        }

        return result != null;
    }
}