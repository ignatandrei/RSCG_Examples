// <auto-generated /> 
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace BreezyDemo
{
    public static class PersonExtensions
    {
        /// <summary>
        /// Execute a query asynchronously using Task.
        /// </summary>
        /// <typeparam name = "T">The type of results to return.</typeparam>
        /// <param name = "sql">The SQL to execute for the query.</param>
        /// <param name = "cancellationToken">The cancellation token for this command.</param>
        /// <returns>
        /// A sequence of data of <typeparamref name = "T"/>;
        /// </returns>
        public static async Task<IEnumerable<Person>> QueryAsync<T>(this DbConnection connection, string sql, CancellationToken cancellationToken = default)
            where T : Person
        {
            bool wasClosed = connection.State == ConnectionState.Closed;
            if (wasClosed)
                await connection.OpenAsync(cancellationToken);
            await using var command = connection.CreateCommand();
            command.CommandText = sql;
            await using var reader = await command.ExecuteReaderAsync(cancellationToken: cancellationToken);
            var persons = new Dictionary<int, Person>();
            try
            {
                while (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
                {
                    Person person = null;
                    var person1Id = reader.IsDBNull(0) ? default : reader.GetInt32(0);
                    if (!persons.TryGetValue(person1Id, out person))
                    {
                        person = new Person()
                        {
                            ID = person1Id,
                            FirstName = reader.IsDBNull(1) ? default : reader.GetString(1),
                            LastName = reader.IsDBNull(2) ? default : reader.GetString(2),
                        };
                        persons.Add(person1Id, person);
                    }
                }

                return persons.Values;
            }
            finally
            {
                reader.Close();
                if (wasClosed)
                    connection.Close();
            }
        }

        /// <summary>
        /// Execute a query asynchronously using Task.
        /// </summary>
        /// <typeparam name = "T">The type of results to return.</typeparam>
        /// <param name = "sql">The SQL to execute for the query.</param>
        /// <param name = "param">The parameters to pass, if any.</param>
        /// <param name = "cancellationToken">The cancellation token for this command.</param>
        /// <returns>
        /// A sequence of data of <typeparamref name = "T"/>;
        /// </returns>
        public static async Task<IEnumerable<Person>> QueryAsync<T>(this DbConnection connection, string sql, object param, CancellationToken cancellationToken = default)
            where T : Person
        {
            bool wasClosed = connection.State == ConnectionState.Closed;
            if (wasClosed)
                await connection.OpenAsync(cancellationToken);
            await using var command = connection.CreateCommand();
            command.CommandText = sql;
            foreach (var property in param.GetType().GetProperties())
            {
                var parameter = command.CreateParameter();
                parameter.ParameterName = "@" + property.Name;
                parameter.Value = property.GetValue(param);
                command.Parameters.Add(parameter);
            }

            await using var reader = await command.ExecuteReaderAsync(cancellationToken: cancellationToken);
            var persons = new Dictionary<int, Person>();
            try
            {
                while (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
                {
                    Person person = null;
                    var person1Id = reader.IsDBNull(0) ? default : reader.GetInt32(0);
                    if (!persons.TryGetValue(person1Id, out person))
                    {
                        person = new Person()
                        {
                            ID = person1Id,
                            FirstName = reader.IsDBNull(1) ? default : reader.GetString(1),
                            LastName = reader.IsDBNull(2) ? default : reader.GetString(2),
                        };
                        persons.Add(person1Id, person);
                    }
                }

                return persons.Values;
            }
            finally
            {
                reader.Close();
                if (wasClosed)
                    connection.Close();
            }
        }

        /// <summary>
        /// Execute a query asynchronously using Task.
        /// </summary>
        /// <typeparam name = "T">The type of results to return.</typeparam>
        /// <param name = "sql">The SQL to execute for the query.</param>
        /// <param name = "cacheableQuery">The cache that you need to impl, if you want to be faster.</param>
        /// <param name = "cancellationToken">The cancellation token for this command.</param>
        /// <returns>
        /// A sequence of data of <typeparamref name = "T"/>;
        /// </returns>
        public static async Task<IEnumerable<Person>> QueryAsync<T>(this DbConnection connection, string sql, ICacheableQuery<Person> cacheableQuery, CancellationToken cancellationToken = default)
            where T : Person
        {
            bool wasClosed = connection.State == ConnectionState.Closed;
            if (wasClosed)
                await connection.OpenAsync(cancellationToken);
            await using var command = connection.CreateCommand();
            command.CommandText = sql;
            var identityQuery = new IdentityQuery(sql);
            var cacheableResults = await cacheableQuery.GetCacheableResultsAsync(identityQuery);
            if (cacheableResults.Any())
                return cacheableResults;
            await using var reader = await command.ExecuteReaderAsync(cancellationToken: cancellationToken);
            var persons = new Dictionary<int, Person>();
            try
            {
                while (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
                {
                    Person person = null;
                    var person1Id = reader.IsDBNull(0) ? default : reader.GetInt32(0);
                    if (!persons.TryGetValue(person1Id, out person))
                    {
                        person = new Person()
                        {
                            ID = person1Id,
                            FirstName = reader.IsDBNull(1) ? default : reader.GetString(1),
                            LastName = reader.IsDBNull(2) ? default : reader.GetString(2),
                        };
                        persons.Add(person1Id, person);
                    }
                }

                await cacheableQuery.SetCacheableResultsAsync(identityQuery, persons.Values);
                return persons.Values;
            }
            finally
            {
                reader.Close();
                if (wasClosed)
                    connection.Close();
            }
        }

        /// <summary>
        /// Execute a query asynchronously using Task.
        /// </summary>
        /// <typeparam name = "T">The type of results to return.</typeparam>
        /// <param name = "sql">The SQL to execute for the query.</param>
        /// <param name = "param">The parameters to pass, if any.</param>
        /// <param name = "cacheableQuery">The cache that you need to impl, if you want to be faster.</param>
        /// <param name = "cancellationToken">The cancellation token for this command.</param>
        /// <returns>
        /// A sequence of data of <typeparamref name = "T"/>;
        /// </returns>
        public static async Task<IEnumerable<Person>> QueryAsync<T>(this DbConnection connection, string sql, object param, ICacheableQuery<Person> cacheableQuery, CancellationToken cancellationToken = default)
            where T : Person
        {
            bool wasClosed = connection.State == ConnectionState.Closed;
            if (wasClosed)
                await connection.OpenAsync(cancellationToken);
            await using var command = connection.CreateCommand();
            command.CommandText = sql;
            foreach (var property in param.GetType().GetProperties())
            {
                var parameter = command.CreateParameter();
                parameter.ParameterName = "@" + property.Name;
                parameter.Value = property.GetValue(param);
                command.Parameters.Add(parameter);
            }

            var identityQuery = new IdentityQuery(sql);
            var cacheableResults = await cacheableQuery.GetCacheableResultsAsync(identityQuery);
            if (cacheableResults.Any())
                return cacheableResults;
            await using var reader = await command.ExecuteReaderAsync(cancellationToken: cancellationToken);
            var persons = new Dictionary<int, Person>();
            try
            {
                while (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
                {
                    Person person = null;
                    var person1Id = reader.IsDBNull(0) ? default : reader.GetInt32(0);
                    if (!persons.TryGetValue(person1Id, out person))
                    {
                        person = new Person()
                        {
                            ID = person1Id,
                            FirstName = reader.IsDBNull(1) ? default : reader.GetString(1),
                            LastName = reader.IsDBNull(2) ? default : reader.GetString(2),
                        };
                        persons.Add(person1Id, person);
                    }
                }

                await cacheableQuery.SetCacheableResultsAsync(identityQuery, persons.Values);
                return persons.Values;
            }
            finally
            {
                reader.Close();
                if (wasClosed)
                    connection.Close();
            }
        }

        /// <summary>
        /// Execute a single-row query asynchronously using Task.
        /// </summary>
        /// <typeparam name = "T">The type of result to return.</typeparam>
        /// <param name = "sql">The SQL to execute for the query.</param>
        /// <param name = "cancellationToken">The cancellation token for this command.</param>
        /// <returns>
        /// A first sequence of data of <typeparamref name = "T"/>;
        /// </returns>
        public static async Task<Person?> QueryFirstOrDefaultAsync<T>(this DbConnection connection, string sql, CancellationToken cancellationToken = default)
            where T : Person
        {
            return (await connection.QueryAsync<Person>(sql, cancellationToken)).FirstOrDefault();
        }

        /// <summary>
        /// Execute a single-row query asynchronously using Task.
        /// </summary>
        /// <typeparam name = "T">The type of result to return.</typeparam>
        /// <param name = "sql">The SQL to execute for the query.</param>
        /// <param name = "param">The parameters to pass, if any.</param>
        /// <param name = "cancellationToken">The cancellation token for this command.</param>
        /// <returns>
        /// A first sequence of data of <typeparamref name = "T"/>;
        /// </returns>
        public static async Task<Person?> QueryFirstOrDefaultAsync<T>(this DbConnection connection, string sql, object param, CancellationToken cancellationToken = default)
            where T : Person
        {
            return (await connection.QueryAsync<Person>(sql, param, cancellationToken)).FirstOrDefault();
        }

        /// <summary>
        /// Execute a single-row query asynchronously using Task.
        /// </summary>
        /// <typeparam name = "T">The type of result to return.</typeparam>
        /// <param name = "sql">The SQL to execute for the query.</param>
        /// <param name = "cacheableQuery">The cache that you need to impl, if you want to be faster.</param>
        /// <param name = "cancellationToken">The cancellation token for this command.</param>
        /// <returns>
        /// A first sequence of data of <typeparamref name = "T"/>;
        /// </returns>
        public static async Task<Person?> QueryFirstOrDefaultAsync<T>(this DbConnection connection, string sql, ICacheableQuery<Person> cacheableQuery, CancellationToken cancellationToken = default)
            where T : Person
        {
            return (await connection.QueryAsync<Person>(sql, cacheableQuery, cancellationToken)).FirstOrDefault();
        }

        /// <summary>
        /// Execute a single-row query asynchronously using Task.
        /// </summary>
        /// <typeparam name = "T">The type of result to return.</typeparam>
        /// <param name = "sql">The SQL to execute for the query.</param>
        /// <param name = "param">The parameters to pass, if any.</param>
        /// <param name = "cacheableQuery">The cache that you need to impl, if you want to be faster.</param>
        /// <param name = "cancellationToken">The cancellation token for this command.</param>
        /// <returns>
        /// A first sequence of data of <typeparamref name = "T"/>;
        /// </returns>
        public static async Task<Person?> QueryFirstOrDefaultAsync<T>(this DbConnection connection, string sql, object param, ICacheableQuery<Person> cacheableQuery, CancellationToken cancellationToken = default)
            where T : Person
        {
            return (await connection.QueryAsync<Person>(sql, param, cacheableQuery, cancellationToken)).FirstOrDefault();
        }
    }
}