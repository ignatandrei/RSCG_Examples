---
sidebar_position: 2040
title: 204 - InlineComposition
description: Mixin classes and interfaces together
slug: /InlineComposition
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TOCInline from '@theme/TOCInline';

# InlineComposition  by Black White Yoshi


<TOCInline toc={toc}  />

## NuGet / site data
[![Nuget](https://img.shields.io/nuget/dt/InlineComposition?label=InlineComposition)](https://www.nuget.org/packages/InlineComposition/)
[![GitHub last commit](https://img.shields.io/github/last-commit/BlackWhiteYoshi/InlineComposition?label=updated)](https://github.com/BlackWhiteYoshi/InlineComposition)
![GitHub Repo stars](https://img.shields.io/github/stars/BlackWhiteYoshi/InlineComposition?style=social)

## Details

### Info
:::info

Name: **InlineComposition**

A source generator that merges the content of other classes into one class.

Author: Black White Yoshi

NuGet: 
*https://www.nuget.org/packages/InlineComposition/*   


You can find more details at https://github.com/BlackWhiteYoshi/InlineComposition

Source: https://github.com/BlackWhiteYoshi/InlineComposition

:::

### Original Readme
:::note

# InlineComposition

A source generator that merges the content of other classes into one class.
A simple workaround for struct inheritance or multiple inheritance.

![InlineComposition Example](https://github.com/BlackWhiteYoshi/InlineComposition/README_IMAGE.png)


- Inlined get members of type field, property, event and method (including constructor and finalizer).
- Attributes and summaries of the inlined members get also inlined.
- Inheritance and implements declaration are also inlined.
- Mixing classes and structs works fine (inline struct in class and vice versa).



<br></br>
## Type Hierarchy / Polymorphism

Inheritance gives not only all the content of a base class, you get also a type hierarchy and polymorphism.
If you need a type hierarchy or polymorphism, you can use interfaces to get the same functionality.

```csharp
using InlineCompositionAttributes;

public interface IBaseA { ... }

public interface IBaseB { ... }

[InlineBase]
public class BaseA : IBaseA { ... }

[InlineBase]
public class BaseB : IBaseB { ... }

[Inline<BaseA, BaseB>]
public partial class Derived { ... }


[...]


Derived derived = new();
Console.WriteLine(derived is BaseA);  // False
Console.WriteLine(derived is BaseB);  // False
Console.WriteLine(derived is IBaseA); // True
Console.WriteLine(derived is IBaseB); // True

// polymorphism IBaseA
ExampleA(derived);

// polymorphism IBaseB
ExampleB(derived);


static void ExampleA(IBaseA baseA) { ... }

static void ExampleB(IBaseB baseB) { ... }


[...]


// <auto-generated/>
public partial class Derived : IBaseA, IBaseB { ... }
```



<br></br>
## Conflicts

Members with the same identifier get merged to a single Member.
Make sure merged members have the same signature.
Method-bodies are merged together that every method is executed one after another.  
Merging of nested types is not supported.
If a conflict of nested types happens, the first one is taken and the others are ignored.


```csharp
using InlineCompositionAttributes;

[InlineBase]
public class BaseA
{
    public int MyProperty { get; set; }

    public void MyMethod()
    {
        int a = 5;
        Console.WriteLine(a);
    }
}

[InlineBase]
public class BaseB
{
    public int MyProperty { get; set; }

    public void MyMethod()
    {
        int a = 5;
        Console.WriteLine(a + a);
    }
}

[Inline<BaseA, BaseB>]
public partial class Derived { ... }


[...]


// <auto-generated/>
public partial class Derived
{
    public int MyProperty { get; set; }

    public void MyMethod()
    {
        {
        int a = 5;
        Console.WriteLine(a);
        }

        {
        int a = 5;
        Console.WriteLine(a + a);
        }
    }
}
```



<br></br>
## Generic classes

Inlining of generic classes is supported.
However, inserting the concrete type in place of the type parameter is done by simple text replacement.
There might be situations where things get replaced/not replaced where it should/should not.
So when inlining generic classes, better double check the result.

```csharp
using InlineCompositionAttributes;

[InlineBase]
public class Base<T>
{
    public T MyProperty { get; set; }
}

[Inline<Base<int>>]
public partial class Derived { ... }


[...]


// <auto-generated/>
public partial class Derived
{
    public int MyProperty { get; set; }
}
```



<br></br>
## Attributes

- ### InlineAttribute

Generates a class with the same name and fills it with the content of the classes/structs in the type arguments.  
If you inline a class/struct that has no *InlineBaseAttribute*, it will be ignored.

```csharp
using InlineCompositionAttributes;

[Inline<Example>] // "Example" must have a InlineBaseAttribute, otherwise it has no effect.
public partial class MyClass { ... }


[...]


// <auto-generated/>
public partial class MyClass { ... }
```


This class comes with up to 12 type parameters.
If you need more, you can easily create your own suitable one.

```csharp
namespace InlineCompositionAttributes;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
internal sealed class InlineAttribute<T1, ..., TN> : Attribute { }
```


<br></br>
- ### InlineBaseAttribute

In order *Inline* works as expected, the classes/structs to inline must be decorated with *InlineBase*.

```csharp
using InlineCompositionAttributes;

[InlineBase] // Itself it does nothing, but this class can now be used as type argument in InlineAttribute.
public class MyClass { ... }
```

#### MapBaseType

If this flag is set to true, all occurrences of the type of the inlineBase class/struct get replaced with the type of the inlining class/struct.

```csharp
using InlineCompositionAttributes;

[InlineBase(MapBaseType = true)]
public class Example
{
    public Example Self => this;
}

[Inline<Example>]
public partial class Derived { ... }


[...]


// <auto-generated/>
public partial class Derived
{
    public Derived Self => this;
}
```

#### IgnoreInheritenceAndImplements

If this flag is set to true, the base classes and interfaces of the inlined class are ignored.  
If you want inline classes that inherit from different base classes, you can use this to avoid to inherit multiple classes.

```csharp
using InlineCompositionAttributes;

public abstract class BaseA { ... }

public abstract class BaseB { ... }

[InlineBase(IgnoreInheritenceAndImplements = true)]
public class InlineA : BaseA { ... }

[InlineBase]
public class InlineB : BaseB { ... }

[Inline<InlineA, InlineB>]
public partial class Derived { ... }


[...]


// <auto-generated/>
public partial class Derived : BaseB { ... }
```

#### InlineAttributes

If this flag is set to true, attributes applied to this class/struct are inlined as well.  
The attribute [InlineBase] itself is ignored.

```csharp
using InlineCompositionAttributes;

[SomeAttribute]
[InlineBase(InlineAttributes = true)]
public class Example { ... }

[Inline<Example>]
public partial class Derived { ... }


[...]


// <auto-generated/>
[SomeAttribute]
public partial class Derived { ... }
```


<br></br>
- ### InlineMethodAttribute

Overriding a normal method and adding your own code is native not possible.
The *InlineMethodAttribute* gives support for adding code to the inlined method.
The content of the decorated method is added to the inlined method specified in the *MethodName* parameter and takes the same parameters.

```csharp
using InlineCompositionAttributes;

[InlineBase]
public class Base : IDisposable
{
    public void Dispose()
    {
        Console.WriteLine("base");
    }
}

[Inline<Base>]
public partial class Derived
{
    [InlineMethod(MethodName = "Dispose")]
    public void DisposePartial()
    {
        Console.WriteLine("derived");
    }
}


[...]


// <auto-generated/>
public partial class Derived : IDisposable
{
    [InlineMethod(MethodName = "Dispose")]
    public void Dispose()
    {
        {
        Console.WriteLine("base");
        }
        {
        Console.WriteLine("derived");
        }
    }
}
```

#### MethodName

The *MethodName* is a required parameter that specify the name of the method to add content to.
Make sure the parameters are the same to target the right (overloaded) method.

```csharp
using InlineCompositionAttributes;

[InlineBase]
public class Base
{
    public void PrintSum(int a, int b)
    {
        Console.WriteLine(a + b);
    }
}

[Inline<Base>]
public partial class Derived
{
    [InlineMethod(MethodName = "PrintSum(int, int)")]
    public void PrintSumPartial(int a, int b)
    {
        Console.WriteLine(b + a);
    }
}


[...]


// <auto-generated/>
public partial class Derived
{
    [InlineMethod(MethodName = "PrintSum(int, int)")]
    public void PrintSum()
    {
        {
        Console.WriteLine(a + b);
        }
        {
        Console.WriteLine(b + a);
        }
    }
}
```

#### Modifiers

When inlining your method-body in a method, the summary, attributes and modifiers are overwritten with your method.
If you want different modifiers inlined than your method, you can use the *Modifiers* parameter.
A common scenario is that your method should not be available (private), but the inlined method should still be public.


```csharp
using InlineCompositionAttributes;

[InlineBase]
public class Base : IDisposable
{
    public void Dispose()
    {
        Console.WriteLine("base");
    }
}

[Inline<Base>]
public partial class Derived
{
    [InlineMethod(MethodName = "Dispose", Modifiers = "public")]
    private void DisposePartial()
    {
        Console.WriteLine("derived");
    }
}


[...]


// <auto-generated/>
public partial class Derived : IDisposable
{
    [InlineMethod(MethodName = "Dispose", Modifiers = "public")]
    public void Dispose()
    {
        {
        Console.WriteLine("base");
        }
        {
        Console.WriteLine("derived");
        }
    }
}
```

#### First

When the added code must run before the inlined code, you can set the *First* parameter to true.

```csharp
using InlineCompositionAttributes;

[InlineBase]
public class Base : IDisposable
{
    public void Dispose()
    {
        Console.WriteLine("base");
    }
}

[Inline<Base>]
public partial class Derived
{
    [InlineMethod(MethodName = "Dispose", First = true)]
    public void DisposePartial()
    {
        Console.WriteLine("derived");
    }
}


[...]


// <auto-generated/>
public partial class Derived : IDisposable
{
    [InlineMethod(MethodName = "Dispose")]
    public void Dispose()
    {
        {
        Console.WriteLine("derived");
        }
        {
        Console.WriteLine("base");
        }
    }
}
```


<br></br>
- ### InlineConstructorAttribute

The *InlineConstructorAttribute* lets you add code to the inlined constructor.
The content of the decorated method is added to the inlined constructor.

```csharp
using InlineCompositionAttributes;

[InlineBase]
public class Base
{
    public Base()
    {
        Console.WriteLine("base");
    }
}

[Inline<Base>]
public partial class Derived
{
    [InlineConstructor]
    public void ConstructorPartial()
    {
        Console.WriteLine("derived");
    }
}


[...]


// <auto-generated/>
public partial class Derived
{
    [InlineConstructor]
    public Derived()
    {
        {
        Console.WriteLine("base");
        }
        {
        Console.WriteLine("derived");
        }
    }
}
```

#### Modifiers

The same functionality as *InlineMethodAttribute.Modifiers*

#### First

The same functionality as *InlineMethodAttribute.First*


<br></br>
- ### InlineFinalizerAttribute

The *InlineFinalizerAttribute* lets you add code to the inlined finalizer.
The content of the decorated method is added to the inlined finalizer.

```csharp
[InlineBase]
public class Base
{
    ~Base()
    {
        Console.WriteLine("base");
    }
}

[Inline<Base>]
public partial class Derived
{
    [InlineFinalizer]
    public void FinalizerPartial()
    {
        Console.WriteLine("derived");
    }
}


[...]


// <auto-generated/>
public partial class Derived
{
    [InlineFinalizer]
    ~Derived()
    {
        {
        Console.WriteLine("base");
        }
        {
        Console.WriteLine("derived");
        }
    }
}
```

#### First

The same functionality as *InlineMethodAttribute.First*


<br></br>
- ### NoInlineAttribute

Members decorated with this attribute are ignored.

```csharp
using InlineCompositionAttributes;

[InlineBase]
public class MyBase
{
    [NoInline]
    private int myField;

    public int MyProperty { get; set; }
}

[Inline<MyBase>]
public partial class Derived { ... }


[...]


// <auto-generated/>
public partial class Derived
{
    public int MyProperty { get; set; }
}
```



<br></br>
## Disable Attribute Generation

You can disable the generation of the attributes by defining a constant for your compilation:

```xml
  <PropertyGroup>
    <DefineConstants>INLINECOMPOSITION_EXCLUDE_ATTRIBUTES</DefineConstants>
  </PropertyGroup>
```

This functionality is specific for the use case when you have a project referencing another project, both projects using this generator and you have <i>InternalsVisibleTo</i> enabled.
In that case you have the attributes defined twice in your referencing project and you get a warning about that.
By defining this constant in your referencing project, you prevent one generation, so the attributes are only defined once in the referenced project.


:::

### About
:::note

Mixin classes and interfaces together


:::

## How to use

### Example (source csproj, source files)

<Tabs>

<TabItem value="csproj" label="CSharp Project">

This is the CSharp Project that references **InlineComposition**
```xml showLineNumbers {20}
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>


	
	<PropertyGroup>
		<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
		<CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\GX</CompilerGeneratedFilesOutputPath>
	</PropertyGroup>


	
	<ItemGroup>
	  <PackageReference Include="InlineComposition" Version="1.4.0">
	    <PrivateAssets>all</PrivateAssets>
	    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
	  </PackageReference>
	</ItemGroup>

	
</Project>

```

</TabItem>

  <TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\Program.cs" label="Program.cs" >

  This is the use of **InlineComposition** in *Program.cs*

```csharp showLineNumbers 
// See https://aka.ms/new-console-template for more information
using MixinConsoleDemo;

Console.WriteLine("Hello, World!");
Employee p = new Employee();
p.Name="Andrei Ignat";
p.Age = 55;
p.Salary = 1000;
p.Id = 1;
Console.WriteLine($"Name: {p.Name}, Age: {p.Age}, Salary: {p.Salary}");
```
  </TabItem>

  <TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\Person.cs" label="Person.cs" >

  This is the use of **InlineComposition** in *Person.cs*

```csharp showLineNumbers 

using InlineCompositionAttributes;

namespace MixinConsoleDemo;
[InlineBase]
internal class Person
{
    
    public string Name { get; set; } = string.Empty;
        public int Age { get; set; }
    
}

```
  </TabItem>

  <TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\Employee.cs" label="Employee.cs" >

  This is the use of **InlineComposition** in *Employee.cs*

```csharp showLineNumbers 

using InlineCompositionAttributes;

namespace MixinConsoleDemo;
[Inline<Person,IId>]
internal partial class Employee
{
    public decimal Salary { get; set; }
}

```
  </TabItem>

  <TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\IId.cs" label="IId.cs" >

  This is the use of **InlineComposition** in *IId.cs*

```csharp showLineNumbers 
using InlineCompositionAttributes;

namespace MixinConsoleDemo;
[InlineBase]
internal class IId
{
    public int Id { get; set; }
}

```
  </TabItem>

</Tabs>

### Generated Files

Those are taken from $(BaseIntermediateOutputPath)\GX

<Tabs>


<TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\obj\GX\InlineComposition\InlineComposition.InlineCompositionGenerator\InlineAttribute.g.cs" label="InlineAttribute.g.cs" >


```csharp showLineNumbers 
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


#if !INLINECOMPOSITION_EXCLUDE_ATTRIBUTES

using System;

namespace InlineCompositionAttributes;

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T3">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2, T3> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T3">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T4">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2, T3, T4> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T3">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T4">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T5">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2, T3, T4, T5> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T3">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T4">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T5">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T6">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2, T3, T4, T5, T6> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T3">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T4">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T5">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T6">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T7">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2, T3, T4, T5, T6, T7> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T3">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T4">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T5">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T6">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T7">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T8">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2, T3, T4, T5, T6, T7, T8> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T3">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T4">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T5">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T6">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T7">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T8">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T9">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2, T3, T4, T5, T6, T7, T8, T9> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T3">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T4">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T5">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T6">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T7">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T8">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T9">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T10">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T3">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T4">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T5">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T6">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T7">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T8">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T9">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T10">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T11">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> : Attribute { }

/// <summary>
/// Generates a partial class/struct which includes all members listed in the typeParams.
/// </summary>
/// <typeparam name="T1">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T2">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T3">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T4">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T5">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T6">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T7">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T8">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T9">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T10">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T11">class/struct which members gets inlined.</typeparam>
/// <typeparam name="T12">class/struct which members gets inlined.</typeparam>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineAttribute<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> : Attribute { }

#endif

```

  </TabItem>


<TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\obj\GX\InlineComposition\InlineComposition.InlineCompositionGenerator\InlineBaseAttribute.g.cs" label="InlineBaseAttribute.g.cs" >


```csharp showLineNumbers 
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


#if !INLINECOMPOSITION_EXCLUDE_ATTRIBUTES

using System;

namespace InlineCompositionAttributes;

/// <summary>
/// <para>Marks this class/struct as inlineable, so it can be listed in a <see cref="InlineAttribute{T1}"/> Attribute.</para>
/// </summary>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineBaseAttribute : Attribute {
    /// <summary>
    /// <para>If set all occurrences of the type of the inlineBase class/struct get replaced with the type of the inlining class/struct.</para>
    /// <para>e.g. if "Example" inlines "Test" with this option enabled, all occurrences of type "Test" inside class/struct "Test" will be mapped to "Example".</para>
    /// </summary>
    public bool MapBaseType { get; init; }

    /// <summary>
    /// If set the generator ignores the inherited class and implemented interfaces of this type.
    /// </summary>
    public bool IgnoreInheritenceAndImplements { get; init; }

    /// <summary>
    /// If set attributes of this class/struct are inlined as well.<br />
    /// The attribute [InlineBase] itself is ignored.
    /// </summary>
    public bool InlineAttributes { get; init; }
}

#endif

```

  </TabItem>


<TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\obj\GX\InlineComposition\InlineComposition.InlineCompositionGenerator\InlineConstructorAttribute.g.cs" label="InlineConstructorAttribute.g.cs" >


```csharp showLineNumbers 
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


#if !INLINECOMPOSITION_EXCLUDE_ATTRIBUTES

using System;

namespace InlineCompositionAttributes;

/// <summary>
/// The Method under this attribute will be inlined in the constructor.
/// </summary>
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineConstructorAttribute : Attribute {
    /// <summary>
    /// <para>Modifiers e.g. "public", "protected", "private"</para>
    /// <para>If null, the method modifiers will be taken.</para>
    /// </summary>
    public string? Modifiers { get; init; }

    /// <summary>
    /// Indicates whether this method gets inlined before the other constructors or after.
    /// </summary>
    public bool First { get; init; }
}

#endif

```

  </TabItem>


<TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\obj\GX\InlineComposition\InlineComposition.InlineCompositionGenerator\InlineFinalizerAttribute.g.cs" label="InlineFinalizerAttribute.g.cs" >


```csharp showLineNumbers 
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


#if !INLINECOMPOSITION_EXCLUDE_ATTRIBUTES

using System;

namespace InlineCompositionAttributes;

/// <summary>
/// The Method under this attribute will be inlined in the finalizer.
/// </summary>
[AttributeUsage(AttributeTargets.Method)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineFinalizerAttribute : Attribute {
    /// <summary>
    /// Indicates whether this method gets inlined before the other finalizers or after.
    /// </summary>
    public bool First { get; init; }
}

#endif

```

  </TabItem>


<TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\obj\GX\InlineComposition\InlineComposition.InlineCompositionGenerator\InlineMethodAttribute.g.cs" label="InlineMethodAttribute.g.cs" >


```csharp showLineNumbers 
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


#if !INLINECOMPOSITION_EXCLUDE_ATTRIBUTES

using System;

namespace InlineCompositionAttributes;

/// <summary>
/// The Method under this attribute will be inlined in the method given by <see cref="MethodName"/>.
/// </summary>
[AttributeUsage(AttributeTargets.Method)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class InlineMethodAttribute : Attribute {
    /// <summary>
    /// The method name as string literal.
    /// </summary>
    public required string MethodName { get; init; }

    /// <summary>
    /// <para>Modifiers e.g. "public static extern", "protected abstract"</para>
    /// <para>If null, the method modifiers will be taken.</para>
    /// </summary>
    public string? Modifiers { get; init; }

    /// <summary>
    /// Indicates whether this method gets inlined before the other methods or after.
    /// </summary>
    public bool First { get; init; }
}

#endif

```

  </TabItem>


<TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\obj\GX\InlineComposition\InlineComposition.InlineCompositionGenerator\MixinConsoleDemo.Employee.g.cs" label="MixinConsoleDemo.Employee.g.cs" >


```csharp showLineNumbers 
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using InlineCompositionAttributes;

namespace MixinConsoleDemo;

internal partial class Employee {
    
    public string Name { get; set; } = string.Empty;

        public int Age { get; set; }

    public int Id { get; set; }

}

```

  </TabItem>


<TabItem value="D:\gth\RSCG_Examples\v2\rscg_examples\InlineComposition\src\MixinConsoleDemo\obj\GX\InlineComposition\InlineComposition.InlineCompositionGenerator\NoInlineAttribute.g.cs" label="NoInlineAttribute.g.cs" >


```csharp showLineNumbers 
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


#if !INLINECOMPOSITION_EXCLUDE_ATTRIBUTES

using System;

namespace InlineCompositionAttributes;

/// <summary>
/// <para>Only usefule in a class/struct with a <see cref="InlineBaseAttribute"/>.</para>
/// <para>Skips/Ignores this member.</para>
/// </summary>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Event | AttributeTargets.Method)]
[System.CodeDom.Compiler.GeneratedCodeAttribute("InlineComposition", "1.4.0")]
internal sealed class NoInlineAttribute : Attribute { }

#endif

```

  </TabItem>


</Tabs>

## Useful

### Download Example (.NET  C#)

:::tip

[Download Example project InlineComposition ](/sources/InlineComposition.zip)

:::


### Share InlineComposition 

<ul>
  <li><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FInlineComposition&quote=InlineComposition" title="Share on Facebook" target="_blank">Share on Facebook</a></li>
  <li><a href="https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FInlineComposition&text=InlineComposition:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FInlineComposition" target="_blank" title="Tweet">Share in Twitter</a></li>
  <li><a href="http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FInlineComposition&title=InlineComposition" target="_blank" title="Submit to Reddit">Share on Reddit</a></li>
  <li><a href="http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FInlineComposition&title=InlineComposition&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FInlineComposition" target="_blank" title="Share on LinkedIn">Share on Linkedin</a></li>
</ul>

https://ignatandrei.github.io/RSCG_Examples/v2/docs/InlineComposition

### In the same category (Templating) - 13 other generators


#### [Gobie](/docs/Gobie)


#### [InterceptorTemplate](/docs/InterceptorTemplate)


#### [JKToolKit.TemplatePropertyGenerator](/docs/JKToolKit.TemplatePropertyGenerator)


#### [Microsoft.NET.Sdk.Razor.SourceGenerators](/docs/Microsoft.NET.Sdk.Razor.SourceGenerators)


#### [Minerals.AutoMixins](/docs/Minerals.AutoMixins)


#### [MorrisMoxy](/docs/MorrisMoxy)


#### [NTypewriter](/docs/NTypewriter)


#### [RazorBlade](/docs/RazorBlade)


#### [RazorSlices](/docs/RazorSlices)


#### [RSCG_IFormattable](/docs/RSCG_IFormattable)


#### [RSCG_Templating](/docs/RSCG_Templating)


#### [spreadcheetah](/docs/spreadcheetah)


#### [Tortuga.Shipwright](/docs/Tortuga.Shipwright)

