"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[5205],{4137:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>d});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var p=n.createContext({}),l=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=l(r),h=a,d=m["".concat(p,".").concat(h)]||m[h]||u[h]||o;return r?n.createElement(d,i(i({ref:t},c),{},{components:r})):n.createElement(d,i({ref:t},c))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[m]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},8272:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=r(7462),a=(r(7294),r(4137));const o={},i="ProxyGen.NET [![Build status](https://ci.appveyor.com/api/projects/status/caw7qqtf5tbaa1fq/branch/master?svg=true)](https://ci.appveyor.com/project/Sholtee/proxygen/branch/master) ![AppVeyor tests](https://img.shields.io/appveyor/tests/sholtee/proxygen/master) [![Coverage Status](https://coveralls.io/repos/github/Sholtee/proxygen/badge.svg?branch=master)](https://coveralls.io/github/Sholtee/proxygen?branch=master) [![Nuget (with prereleases)](https://img.shields.io/nuget/vpre/proxygen.net)](https://www.nuget.org/packages/proxygen.net) ![GitHub last commit (branch)](https://img.shields.io/github/last-commit/sholtee/proxygen/master)",s={unversionedId:"RSCG-Examples/ProxyGen_readme",id:"RSCG-Examples/ProxyGen_readme",title:"ProxyGen.NET [![Build status](https://ci.appveyor.com/api/projects/status/caw7qqtf5tbaa1fq/branch/master?svg=true)](https://ci.appveyor.com/project/Sholtee/proxygen/branch/master) ![AppVeyor tests](https://img.shields.io/appveyor/tests/sholtee/proxygen/master) [![Coverage Status](https://coveralls.io/repos/github/Sholtee/proxygen/badge.svg?branch=master)](https://coveralls.io/github/Sholtee/proxygen?branch=master) [![Nuget (with prereleases)](https://img.shields.io/nuget/vpre/proxygen.net)](https://www.nuget.org/packages/proxygen.net) ![GitHub last commit (branch)](https://img.shields.io/github/last-commit/sholtee/proxygen/master)",description:".NET proxy generator powered by Roslyn",source:"@site/docs/RSCG-Examples/ProxyGen_readme.md",sourceDirName:"RSCG-Examples",slug:"/RSCG-Examples/ProxyGen_readme",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/ProxyGen_readme",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"![Project Icon](https://raw.githubusercontent.com/canton7/PropertyChanged.SourceGenerator/master/icon-small.png) PropertyChanged.SourceGenerator",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/PropertyChangedSourceGenerator_readme"},next:{title:"QuickConstructor",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/QuickConstructor_readme"}},p={},l=[{value:"Purposes",id:"purposes",level:2},{value:"To hook into interface method calls:",id:"to-hook-into-interface-method-calls",level:3},{value:"To create ducks:",id:"to-create-ducks",level:3},{value:"Caching the generated assembly",id:"caching-the-generated-assembly",level:2},{value:"Embedding the generated type",id:"embedding-the-generated-type",level:2},{value:"Inspecting the generated code",id:"inspecting-the-generated-code",level:2},{value:"Migrating from version",id:"migrating-from-version",level:2},{value:"Resources",id:"resources",level:2},{value:"Supported frameworks",id:"supported-frameworks",level:2}],c={toc:l},m="wrapper";function u(e){let{components:t,...r}=e;return(0,a.kt)(m,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"proxygennet-build-status-appveyor-tests-coverage-status-nuget-with-prereleases-github-last-commit-branch"},"ProxyGen.NET ",(0,a.kt)("a",{parentName:"h1",href:"https://ci.appveyor.com/project/Sholtee/proxygen/branch/master"},(0,a.kt)("img",{parentName:"a",src:"https://ci.appveyor.com/api/projects/status/caw7qqtf5tbaa1fq/branch/master?svg=true",alt:"Build status"}))," ",(0,a.kt)("img",{parentName:"h1",src:"https://img.shields.io/appveyor/tests/sholtee/proxygen/master",alt:"AppVeyor tests"})," ",(0,a.kt)("a",{parentName:"h1",href:"https://coveralls.io/github/Sholtee/proxygen?branch=master"},(0,a.kt)("img",{parentName:"a",src:"https://coveralls.io/repos/github/Sholtee/proxygen/badge.svg?branch=master",alt:"Coverage Status"}))," ",(0,a.kt)("a",{parentName:"h1",href:"https://www.nuget.org/packages/proxygen.net"},(0,a.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/vpre/proxygen.net",alt:"Nuget (with prereleases)"}))," ",(0,a.kt)("img",{parentName:"h1",src:"https://img.shields.io/github/last-commit/sholtee/proxygen/master",alt:"GitHub last commit (branch)"})),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},".NET proxy generator powered by ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/dotnet/roslyn"},"Roslyn"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"This documentation refers the version 8.X of the library")),(0,a.kt)("h2",{id:"purposes"},"Purposes"),(0,a.kt)("p",null,"This library currently supports generating ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Proxy_pattern"},"proxies")," for interface interception and ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Duck_typing"},"duck typing"),"."),(0,a.kt)("h3",{id:"to-hook-into-interface-method-calls"},"To hook into interface method calls:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Create the interceptor class (which is an ",(0,a.kt)("a",{parentName:"p",href:"https://sholtee.github.io/proxygen/doc/Solti.Utils.Proxy.InterfaceInterceptor-1.html"},"InterfaceInterceptor")," descendant):"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'using Solti.Utils.Proxy;\n...\npublic class MyInterceptor: InterfaceInterceptor<IMyInterface>\n{\n  public MyInterceptor(IMyInterface target) : base(target) {}\n\n  public MyInterceptor(IMyInterface target, MyParam myParam) : base(target) {}  // overloaded constructor\n\n  public override object? Invoke(InvocationContext context) // Invoking the generated proxy instance will trigger this method\n  {\n  if (suppressOriginalMethod)\n  {\n    return something;\n      // ref|out parameters can be assigned by setting the corresponding "context.Args[]" item \n  }\n  \n  context.Args[0] = someNewVal; // "someNewVal" will be forwarded to the original method\n  \n  return base.Invoke(context); // Let the original method do its work\n  }  \n}\n// OR\npublic class MyInterceptorTargetingTheImplementation: InterfaceInterceptor<IMyInterface, MyInterfaceImplementation>\n{\n    public MyInterceptor(MyInterfaceImplementation target) : base(target) {}\n\n    public override object? Invoke(InvocationContext context)\n    {\n        MemberInfo\n            ifaceMember  = context.InterfaceMember,  // Will point to the invoked IMyInterface member (e.g.: IMyInterface.Foo())\n            targetMember = context.TargetMember; // Will point to the underlying MyInterfaceImplementation member (e.g. MyInterfaceImplementation.Foo())\n\n        return base.Invoke(context);\n    }\n}\n'))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Generate a proxy instance invoking the desired constructor:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"using System;\n...\nIMyInterface target = new MyClass();\n...\nIMyInterface proxy;\n\nproxy = ProxyGenerator<IMyInterface, MyInterceptor>.Activate(Tuple.Create(target)); // or ActivateAsync()\nproxy = ProxyGenerator<IMyInterface, MyInterceptor>.Activate(Tuple.Create(target, new MyParam()));\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Enjoy"))),(0,a.kt)("p",null,"Note that the ",(0,a.kt)("em",{parentName:"p"},"target")," can access its most outer enclosing proxy. To achieve this it just has to implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"IProxyAccess<IMyInterface>")," interface:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"using Solti.Utils.Proxy;\n\npublic class MyClass : IMyInterface, IProxyAccess<IMyInterface>\n{\n    ...\n    public IMyInterface Proxy { get; set; }\n}\n")),(0,a.kt)("p",null,"For further usage examples see ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Sholtee/proxygen/blob/master/TEST/ProxyGen.Tests/Generators/ProxyGenerator.cs"},"this")," or ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Sholtee/injector#decorating-services"},"that"),"."),(0,a.kt)("h3",{id:"to-create-ducks"},"To create ducks:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Declare an interface that covers all the desired members of the target class:",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public class TargetClass // does not implement IDuck\n{\n  public void Foo(){...}\n}\n...\npublic interface IDuck \n{\n  void Foo();\n}\n"))),(0,a.kt)("li",{parentName:"ol"},"Generate the duck instance:",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"using Solti.Utils.Proxy.Generators;\n...\nTargetClass target = ...;\nIDuck duck = DuckGenerator<IDuck, TargetClass>.Activate(Tuple.Create(target)); // or ActivateAsync()\n"))),(0,a.kt)("li",{parentName:"ol"},"Quack")),(0,a.kt)("p",null,"Related tests can be seen ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Sholtee/proxygen/blob/master/TEST/ProxyGen.Tests/Generators/DuckGenerator.cs"},"here"),"."),(0,a.kt)("h2",{id:"caching-the-generated-assembly"},"Caching the generated assembly"),(0,a.kt)("p",null,"By setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"ProxyGen.AssemblyCacheDir")," property in ",(0,a.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/core/run-time-config/"},"YourApp.runtimeconfig.json")," you can make the system cache the generated assembly, so next time your app starts and requests the proxy there won't be time consuming emitting operation."),(0,a.kt)("p",null,"You can do it easily by creating a template file named ",(0,a.kt)("inlineCode",{parentName:"p"},"runtimeconfig.template.json")," in your project folder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "configProperties": {\n    "ProxyGen.AssemblyCacheDir": "GeneratedAssemblies"\n  }\n}\n')),(0,a.kt)("h2",{id:"embedding-the-generated-type"},"Embedding the generated type"),(0,a.kt)("p",null,"This library can be used as a ",(0,a.kt)("a",{parentName:"p",href:"https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/"},"source generator")," so you can embed the generated proxy type into the assembly that uses it. This is simply done by the ",(0,a.kt)("inlineCode",{parentName:"p"},"Solti.Utils.Proxy.Attributes.EmbedGeneratedTypeAttribute"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[assembly: EmbedGeneratedType(typeof(ProxyGenerator<IMyInterface, MyInterceptor<IMyInterface>>))]\n[assembly: EmbedGeneratedType(typeof(DuckGenerator<IMyInterface, MyClass>))]\n\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"xXxGenerator.GetGeneratedType()")," method returns the embedded type if it is present in the assembly in which the ",(0,a.kt)("inlineCode",{parentName:"p"},"GetGeneratedType()")," was called. Since all the time consumig operations already happened in compile time, requesting embedded types can singificantly improve the performance."),(0,a.kt)("p",null,"Note that:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Open generics are not supported."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.nuget.org/packages/coveralls.io/"},"coveralls.io")," (and other coverage reporters) may crash if your project was augmented by a source generator. To work this issue around:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Ignore the generated sources in your coverage app (e.g.: in ",(0,a.kt)("a",{parentName:"li",href:"https://www.nuget.org/packages/OpenCover/"},"OpenCover")," use the ",(0,a.kt)("inlineCode",{parentName:"li"},"-filter:-[*]Proxies.GeneratedClass_*")," switch)"),(0,a.kt)("li",{parentName:"ul"},"Create an empty file for each generated class (e.g.: ",(0,a.kt)("inlineCode",{parentName:"li"},"YourProject\\Solti.Utils.Proxy\\Solti.Utils.Proxy.Internals.ProxyEmbedder\\Proxies.GeneratedClass_XxX.cs"),")"),(0,a.kt)("li",{parentName:"ul"},"Exclude these files from your project:")),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<ItemGroup>\n  <Compile Remove="Solti.Utils.Proxy\\**" />\n  <EmbeddedResource Remove="Solti.Utils.Proxy\\**" />\n  <None Remove="Solti.Utils.Proxy\\**" />\n</ItemGroup>\n')))),(0,a.kt)("h2",{id:"inspecting-the-generated-code"},"Inspecting the generated code"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"ProxyGen")," is able to dump the generated sources. Due to performance considerations it is disabled by default. To enable "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"In runtime:"),(0,a.kt)("p",{parentName:"li"},"Set the ",(0,a.kt)("inlineCode",{parentName:"p"},"ProxyGen.SourceDump")," property (in the same way you could see ",(0,a.kt)("a",{parentName:"p",href:"#caching-the-generated-assembly"},"above"),") to the desired directory (note that environment variables are supported):"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "configProperties": {\n    "ProxyGen.SourceDump": "%TEMP%"\n  }\n}\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"In compile time (source generator):"),(0,a.kt)("p",{parentName:"li"},"Extend your ",(0,a.kt)("inlineCode",{parentName:"p"},".csproj")," with the following:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-xml"},"<PropertyGroup>\n  <ProxyGen_SourceDump>$(OutputPath)Logs</ProxyGen_SourceDump>\n</PropertyGroup>\n")))),(0,a.kt)("p",null,"The output should look like ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Sholtee/proxygen/blob/master/TEST/ProxyGen.Tests/ClsSrcUnit.txt"},"this"),"."),(0,a.kt)("h2",{id:"migrating-from-version"},"Migrating from version"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"2.X",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Delete all the cached assemblies (if the ",(0,a.kt)("inlineCode",{parentName:"li"},"[Proxy|Duck]Generator.CacheDirectory")," is set somewhere)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"InterfaceInterceptor.Invoke()")," returns the result of the original method (instead of ",(0,a.kt)("inlineCode",{parentName:"li"},"CALL_TARGET"),") so in the override you may never need to invoke the ",(0,a.kt)("inlineCode",{parentName:"li"},"method")," parameter directly."))),(0,a.kt)("li",{parentName:"ul"},"3.X",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"[Proxy|Duck]Generator.GeneratedType[Async]")," property has been removed. To get the generated proxy type call the ",(0,a.kt)("inlineCode",{parentName:"li"},"[Proxy|Duck]Generator.GetGeneratedType[Async]()")," method."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"[Proxy|Duck]Generator.CacheDirectory")," property has been removed. To set the cache directory tweak the ",(0,a.kt)("a",{parentName:"li",href:"#caching-the-generated-assembly"},"runtimeconfig.json")," file."))),(0,a.kt)("li",{parentName:"ul"},"4.X",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The layout of the ",(0,a.kt)("inlineCode",{parentName:"li"},"InterfaceInterceptor<>.Invoke()")," has been changed. Invocation parameters can be grabbed from the ",(0,a.kt)("inlineCode",{parentName:"li"},"InvocationContext")," passed to the ",(0,a.kt)("inlineCode",{parentName:"li"},"Invoke()")," method."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"ConcurrentInterfaceInterceptor<>")," class has been dropped since the ",(0,a.kt)("inlineCode",{parentName:"li"},"InterfaceInterceptor<>")," class was rewritten in a thread safe manner."))),(0,a.kt)("li",{parentName:"ul"},"5.X",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"You don't need to manually activate the generated proxy type, instead you may use the built-in ",(0,a.kt)("inlineCode",{parentName:"li"},"Generator.Activate()")," method."))),(0,a.kt)("li",{parentName:"ul"},"6.X",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"InvocationContext.InvokeTarget")," property has been removed but you should not be affected by it"),(0,a.kt)("li",{parentName:"ul"},"As proxy embedder has been reimplemented using the ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md"},"v2")," Source Generator API, this feature now requires VS 2022"))),(0,a.kt)("li",{parentName:"ul"},"7.X",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"InterfaceInterceptor<TInterface>.Member|Method")," has been renamed to ",(0,a.kt)("inlineCode",{parentName:"li"},"InterfaceMember|InterfaceMethod"))))),(0,a.kt)("h2",{id:"resources"},"Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://sholtee.github.io/proxygen"},"API Docs")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://sholtee.github.io/proxygen/perf"},"Benchmark Results")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/Sholtee/proxygen/blob/master/history.md"},"Version History"))),(0,a.kt)("h2",{id:"supported-frameworks"},"Supported frameworks"),(0,a.kt)("p",null,"This project currently targets ",(0,a.kt)("em",{parentName:"p"},".NET Standard")," 2.0 and 2.1."))}u.isMDXComponent=!0}}]);