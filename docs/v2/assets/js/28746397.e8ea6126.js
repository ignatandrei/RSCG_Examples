"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[9541],{7650:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>p,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>m,toc:()=>d});var n=t(7462),o=(t(7294),t(4137)),r=t(3992),s=t(425);t(8839);const l={sidebar_position:90,title:"09 - CommunityToolkit.Mvvm",description:"Shows how to implement INotifyPropertyChanged,ObservableProperty and RelayCommand",slug:"/CommunityToolkit.Mvvm"},i="CommunityToolkit.Mvvm  by Microsoft",m={unversionedId:"RSCG-Examples/CommunityToolkit.Mvvm",id:"RSCG-Examples/CommunityToolkit.Mvvm",title:"09 - CommunityToolkit.Mvvm",description:"Shows how to implement INotifyPropertyChanged,ObservableProperty and RelayCommand",source:"@site/docs/RSCG-Examples/CommunityToolkit.Mvvm.md",sourceDirName:"RSCG-Examples",slug:"/CommunityToolkit.Mvvm",permalink:"/RSCG_Examples/v2/docs/CommunityToolkit.Mvvm",draft:!1,tags:[],version:"current",sidebarPosition:90,frontMatter:{sidebar_position:90,title:"09 - CommunityToolkit.Mvvm",description:"Shows how to implement INotifyPropertyChanged,ObservableProperty and RelayCommand",slug:"/CommunityToolkit.Mvvm"},sidebar:"tutorialSidebar",previous:{title:"08 - RSCG_Static",permalink:"/RSCG_Examples/v2/docs/RSCG_Static"},next:{title:"10 - AutoDeconstruct",permalink:"/RSCG_Examples/v2/docs/AutoDeconstruct"}},p={},d=[{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example",id:"download-example",level:3},{value:"Download PDF",id:"download-pdf",level:3},{value:"Share CommunityToolkit.Mvvm",id:"share-communitytoolkitmvvm",level:3}],u={toc:d},y="wrapper";function h(e){let{components:a,...l}=e;return(0,o.kt)(y,(0,n.Z)({},u,l,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"communitytoolkitmvvm--by-microsoft"},"CommunityToolkit.Mvvm  by Microsoft"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/CommunityToolkit.Mvvm"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/CommunityToolkit.Mvvm?label=CommunityToolkit.Mvvm",alt:"Nuget"})),"\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CommunityToolkit/dotnet"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/CommunityToolkit/dotnet?label=updated",alt:"GitHub last commit"})),"\n",(0,o.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/CommunityToolkit/dotnet?style=social",alt:"GitHub Repo stars"})),(0,o.kt)("h2",{id:"details"},"Details"),(0,o.kt)("h3",{id:"info"},"Info"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Name: ",(0,o.kt)("strong",{parentName:"p"},"CommunityToolkit.Mvvm")),(0,o.kt)("p",{parentName:"admonition"},"Author: Microsoft"),(0,o.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/CommunityToolkit.Mvvm"},"https://www.nuget.org/packages/CommunityToolkit.Mvvm")),"   "),(0,o.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,o.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/generators/overview"},"https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/generators/overview")),(0,o.kt)("p",{parentName:"admonition"},"Source : ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CommunityToolkit/dotnet"},"https://github.com/CommunityToolkit/dotnet"))),(0,o.kt)("h3",{id:"about"},"About"),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Shows how to implement INotifyPropertyChanged,ObservableProperty and RelayCommand"),(0,o.kt)("p",{parentName:"admonition"},"Unfortunately , not yet a separate package just for those."),(0,o.kt)("p",{parentName:"admonition"},"Also, this show that RSCG could generate multiple partial declarations")),(0,o.kt)("h2",{id:"how-to-use"},"How to use"),(0,o.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,o.kt)("p",null,"This is the CSharp Project that references ",(0,o.kt)("strong",{parentName:"p"},"CommunityToolkit.Mvvm")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml"},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net7.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.2.0" />\n  </ItemGroup>\n    <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n</Project>\n\n'))),(0,o.kt)(s.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\CommunityToolkit.Mvvm\\src\\ToolkitMVVM\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,o.kt)("p",null,"  This is the use of ",(0,o.kt)("strong",{parentName:"p"},"CommunityToolkit.Mvvm")," in ",(0,o.kt)("em",{parentName:"p"},"Program.cs")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'// See https://aka.ms/new-console-template for more information\nusing test;\n\nConsole.WriteLine("Hello, World!");\n\nMyViewModel myViewModel = new();\nmyViewModel.Name = "Andrei";\nvar x=myViewModel.SayHelloCommand;\n'))),(0,o.kt)(s.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\CommunityToolkit.Mvvm\\src\\ToolkitMVVM\\MyViewModel.cs",label:"MyViewModel.cs",mdxType:"TabItem"},(0,o.kt)("p",null,"  This is the use of ",(0,o.kt)("strong",{parentName:"p"},"CommunityToolkit.Mvvm")," in ",(0,o.kt)("em",{parentName:"p"},"MyViewModel.cs")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'using CommunityToolkit.Mvvm.ComponentModel;\nusing CommunityToolkit.Mvvm.Input;\n\nnamespace test;\n\n[INotifyPropertyChanged]\npublic partial class MyViewModel \n{\n    [ObservableProperty]\n    private string? name;\n\n    [RelayCommand]\n    private void SayHello()\n    {\n        Console.WriteLine("Hello");\n    }\n}\n\n')))),(0,o.kt)("h3",{id:"generated-files"},"Generated Files"),(0,o.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\CommunityToolkit.Mvvm\\src\\ToolkitMVVM\\obj\\GX\\CommunityToolkit.Mvvm.SourceGenerators\\CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator\\test.MyViewModel.g.cs",label:"test.MyViewModel.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'// <auto-generated/>\n#pragma warning disable\n#nullable enable\nnamespace test\n{\n    /// <inheritdoc/>\n    partial class MyViewModel : global::System.ComponentModel.INotifyPropertyChanged\n    {\n        /// <inheritdoc cref = "global::System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        public event global::System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;\n        /// <summary>\n        /// Raises the <see cref = "PropertyChanged"/> event.\n        /// </summary>\n        /// <param name = "e">The input <see cref = "global::System.ComponentModel.PropertyChangedEventArgs"/> instance.</param>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected virtual void OnPropertyChanged(global::System.ComponentModel.PropertyChangedEventArgs e)\n        {\n            PropertyChanged?.Invoke(this, e);\n        }\n\n        /// <summary>\n        /// Raises the <see cref = "PropertyChanged"/> event.\n        /// </summary>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected void OnPropertyChanged([global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n        {\n            OnPropertyChanged(new global::System.ComponentModel.PropertyChangedEventArgs(propertyName));\n        }\n\n        /// <summary>\n        /// Compares the current and new values for a given property. If the value has changed, updates\n        /// the property with the new value, then raises the <see cref = "PropertyChanged"/> event.\n        /// </summary>\n        /// <typeparam name = "T">The type of the property that changed.</typeparam>\n        /// <param name = "field">The field storing the property\'s value.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        /// <remarks>\n        /// The <see cref = "PropertyChanged"/> event is not raised if the current and new value for the target property are the same.\n        /// </remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected bool SetProperty<T>([global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("newValue")] ref T field, T newValue, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n        {\n            if (global::System.Collections.Generic.EqualityComparer<T>.Default.Equals(field, newValue))\n            {\n                return false;\n            }\n\n            field = newValue;\n            OnPropertyChanged(propertyName);\n            return true;\n        }\n\n        /// <summary>\n        /// Compares the current and new values for a given property. If the value has changed, updates\n        /// the property with the new value, then raises the <see cref = "PropertyChanged"/> event.\n        /// See additional notes about this overload in <see cref = "SetProperty{T}(ref T, T, string)"/>.\n        /// </summary>\n        /// <typeparam name = "T">The type of the property that changed.</typeparam>\n        /// <param name = "field">The field storing the property\'s value.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "comparer">The <see cref = "global::System.Collections.Generic.IEqualityComparer{T}"/> instance to use to compare the input values.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected bool SetProperty<T>([global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("newValue")] ref T field, T newValue, global::System.Collections.Generic.IEqualityComparer<T> comparer, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n        {\n            if (comparer.Equals(field, newValue))\n            {\n                return false;\n            }\n\n            field = newValue;\n            OnPropertyChanged(propertyName);\n            return true;\n        }\n\n        /// <summary>\n        /// Compares the current and new values for a given property. If the value has changed, updates\n        /// the property with the new value, then raises the <see cref = "PropertyChanged"/> event.\n        /// This overload is much less efficient than <see cref = "SetProperty{T}(ref T, T, string)"/> and it\n        /// should only be used when the former is not viable (eg. when the target property being\n        /// updated does not directly expose a backing field that can be passed by reference).\n        /// For performance reasons, it is recommended to use a stateful callback if possible through\n        /// the <see cref = "SetProperty{TModel, T}(T, T, TModel, global::System.Action{TModel, T}, string? )"/> whenever possible\n        /// instead of this overload, as that will allow the C# compiler to cache the input callback and\n        /// reduce the memory allocations. More info on that overload are available in the related XML\n        /// docs. This overload is here for completeness and in cases where that is not applicable.\n        /// </summary>\n        /// <typeparam name = "T">The type of the property that changed.</typeparam>\n        /// <param name = "oldValue">The current property value.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "callback">A callback to invoke to update the property value.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        /// <remarks>\n        /// The <see cref = "PropertyChanged"/> event is not raised if the current and new value for the target property are the same.\n        /// </remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected bool SetProperty<T>(T oldValue, T newValue, global::System.Action<T> callback, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n        {\n            if (global::System.Collections.Generic.EqualityComparer<T>.Default.Equals(oldValue, newValue))\n            {\n                return false;\n            }\n\n            callback(newValue);\n            OnPropertyChanged(propertyName);\n            return true;\n        }\n\n        /// <summary>\n        /// Compares the current and new values for a given property. If the value has changed, updates\n        /// the property with the new value, then raises the <see cref = "PropertyChanged"/> event.\n        /// See additional notes about this overload in <see cref = "SetProperty{T}(T, T, global::System.Action{T}, string)"/>.\n        /// </summary>\n        /// <typeparam name = "T">The type of the property that changed.</typeparam>\n        /// <param name = "oldValue">The current property value.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "comparer">The <see cref = "global::System.Collections.Generic.IEqualityComparer{T}"/> instance to use to compare the input values.</param>\n        /// <param name = "callback">A callback to invoke to update the property value.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected bool SetProperty<T>(T oldValue, T newValue, global::System.Collections.Generic.IEqualityComparer<T> comparer, global::System.Action<T> callback, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n        {\n            if (comparer.Equals(oldValue, newValue))\n            {\n                return false;\n            }\n\n            callback(newValue);\n            OnPropertyChanged(propertyName);\n            return true;\n        }\n\n        /// <summary>\n        /// Compares the current and new values for a given nested property. If the value has changed,\n        /// updates the property and then raises the <see cref = "PropertyChanged"/> event.\n        /// The behavior mirrors that of <see cref = "SetProperty{T}(ref T, T, string)"/>,\n        /// with the difference being that this method is used to relay properties from a wrapped model in the\n        /// current instance. This type is useful when creating wrapping, bindable objects that operate over\n        /// models that lack support for notification (eg. for CRUD operations).\n        /// Suppose we have this model (eg. for a database row in a table):\n        /// <code>\n        /// public class Person\n        /// {\n        ///     public string Name { get; set; }\n        /// }\n        /// </code>\n        /// We can then use a property to wrap instances of this type into our observable model (which supports\n        /// notifications), injecting the notification to the properties of that model, like so:\n        /// <code>\n        /// [INotifyPropertyChanged]\n        /// public partial class BindablePerson\n        /// {\n        ///     public Model { get; }\n        ///\n        ///     public BindablePerson(Person model)\n        ///     {\n        ///         Model = model;\n        ///     }\n        ///\n        ///     public string Name\n        ///     {\n        ///         get => Model.Name;\n        ///         set => Set(Model.Name, value, Model, (model, name) => model.Name = name);\n        ///     }\n        /// }\n        /// </code>\n        /// This way we can then use the wrapping object in our application, and all those "proxy" properties will\n        /// also raise notifications when changed. Note that this method is not meant to be a replacement for\n        /// <see cref = "SetProperty{T}(ref T, T, string)"/>, and it should only be used when relaying properties to a model that\n        /// doesn\'t support notifications, and only if you can\'t implement notifications to that model directly (eg. by having\n        /// it implement <see cref = "global::System.ComponentModel.INotifyPropertyChanged"/>). The syntax relies on passing the target model and a stateless callback\n        /// to allow the C# compiler to cache the function, which results in much better performance and no memory usage.\n        /// </summary>\n        /// <typeparam name = "TModel">The type of model whose property (or field) to set.</typeparam>\n        /// <typeparam name = "T">The type of property (or field) to set.</typeparam>\n        /// <param name = "oldValue">The current property value.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "model">The model containing the property being updated.</param>\n        /// <param name = "callback">The callback to invoke to set the target property value, if a change has occurred.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        /// <remarks>\n        /// The <see cref = "PropertyChanged"/> event is not raised if the current and new value for the target property are the same.\n        /// </remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected bool SetProperty<TModel, T>(T oldValue, T newValue, TModel model, global::System.Action<TModel, T> callback, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n            where TModel : class\n        {\n            if (global::System.Collections.Generic.EqualityComparer<T>.Default.Equals(oldValue, newValue))\n            {\n                return false;\n            }\n\n            callback(model, newValue);\n            OnPropertyChanged(propertyName);\n            return true;\n        }\n\n        /// <summary>\n        /// Compares the current and new values for a given nested property. If the value has changed,\n        /// updates the property and then raises the <see cref = "PropertyChanged"/> event.\n        /// The behavior mirrors that of <see cref = "SetProperty{T}(ref T, T, string)"/>,\n        /// with the difference being that this method is used to relay properties from a wrapped model in the\n        /// current instance. See additional notes about this overload in <see cref = "SetProperty{TModel, T}(T, T, TModel, global::System.Action{TModel, T}, string)"/>.\n        /// </summary>\n        /// <typeparam name = "TModel">The type of model whose property (or field) to set.</typeparam>\n        /// <typeparam name = "T">The type of property (or field) to set.</typeparam>\n        /// <param name = "oldValue">The current property value.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "comparer">The <see cref = "global::System.Collections.Generic.IEqualityComparer{T}"/> instance to use to compare the input values.</param>\n        /// <param name = "model">The model containing the property being updated.</param>\n        /// <param name = "callback">The callback to invoke to set the target property value, if a change has occurred.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected bool SetProperty<TModel, T>(T oldValue, T newValue, global::System.Collections.Generic.IEqualityComparer<T> comparer, TModel model, global::System.Action<TModel, T> callback, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n            where TModel : class\n        {\n            if (comparer.Equals(oldValue, newValue))\n            {\n                return false;\n            }\n\n            callback(model, newValue);\n            OnPropertyChanged(propertyName);\n            return true;\n        }\n\n        /// <summary>\n        /// Compares the current and new values for a given field (which should be the backing field for a property).\n        /// If the value has changed, updates the field and then raises the <see cref = "PropertyChanged"/> event.\n        /// The behavior mirrors that of <see cref = "SetProperty{T}(ref T, T, string)"/>, with the difference being that\n        /// this method will also monitor the new value of the property (a generic <see cref = "global::System.Threading.Tasks.Task"/>) and will also\n        /// raise the <see cref = "PropertyChanged"/> again for the target property when it completes.\n        /// This can be used to update bindings observing that <see cref = "global::System.Threading.Tasks.Task"/> or any of its properties.\n        /// This method and its overload specifically rely on the <see cref = "TaskNotifier"/> type, which needs\n        /// to be used in the backing field for the target <see cref = "global::System.Threading.Tasks.Task"/> property. The field doesn\'t need to be\n        /// initialized, as this method will take care of doing that automatically. The <see cref = "TaskNotifier"/>\n        /// type also includes an implicit operator, so it can be assigned to any <see cref = "global::System.Threading.Tasks.Task"/> instance directly.\n        /// Here is a sample property declaration using this method:\n        /// <code>\n        /// private TaskNotifier myTask;\n        ///\n        /// public Task MyTask\n        /// {\n        ///     get => myTask;\n        ///     private set => SetAndNotifyOnCompletion(ref myTask, value);\n        /// }\n        /// </code>\n        /// </summary>\n        /// <param name = "taskNotifier">The field notifier to modify.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        /// <remarks>\n        /// The <see cref = "PropertyChanged"/> event is not raised if the current and new value for the target property are\n        /// the same. The return value being <see langword="true"/> only indicates that the new value being assigned to\n        /// <paramref name = "taskNotifier"/> is different than the previous one, and it does not mean the new\n        /// <see cref = "global::System.Threading.Tasks.Task"/> instance passed as argument is in any particular state.\n        /// </remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected bool SetPropertyAndNotifyOnCompletion([global::System.Diagnostics.CodeAnalysis.NotNull] ref TaskNotifier? taskNotifier, global::System.Threading.Tasks.Task? newValue, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n        {\n            return SetPropertyAndNotifyOnCompletion(taskNotifier ??= new TaskNotifier(), newValue, null, propertyName);\n        }\n\n        /// <summary>\n        /// Compares the current and new values for a given field (which should be the backing field for a property).\n        /// If the value has changed, updates the field and then raises the <see cref = "PropertyChanged"/> event.\n        /// This method is just like <see cref = "SetPropertyAndNotifyOnCompletion(ref TaskNotifier, global::System.Threading.Tasks.Task, string)"/>,\n        /// with the difference being an extra <see cref = "global::System.Action{T}"/> parameter with a callback being invoked\n        /// either immediately, if the new task has already completed or is <see langword="null"/>, or upon completion.\n        /// </summary>\n        /// <param name = "taskNotifier">The field notifier to modify.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "callback">A callback to invoke to update the property value.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        /// <remarks>\n        /// The <see cref = "PropertyChanged"/> event is not raised if the current and new value for the target property are the same.\n        /// </remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected bool SetPropertyAndNotifyOnCompletion([global::System.Diagnostics.CodeAnalysis.NotNull] ref TaskNotifier? taskNotifier, global::System.Threading.Tasks.Task? newValue, global::System.Action<global::System.Threading.Tasks.Task?> callback, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n        {\n            return SetPropertyAndNotifyOnCompletion(taskNotifier ??= new TaskNotifier(), newValue, callback, propertyName);\n        }\n\n        /// <summary>\n        /// Compares the current and new values for a given field (which should be the backing field for a property).\n        /// If the value has changed, updates the field and then raises the <see cref = "PropertyChanged"/> event.\n        /// The behavior mirrors that of <see cref = "SetProperty{T}(ref T, T, string)"/>, with the difference being that\n        /// this method will also monitor the new value of the property (a generic <see cref = "global::System.Threading.Tasks.Task"/>) and will also\n        /// raise the <see cref = "PropertyChanged"/> again for the target property when it completes.\n        /// This can be used to update bindings observing that <see cref = "global::System.Threading.Tasks.Task"/> or any of its properties.\n        /// This method and its overload specifically rely on the <see cref = "TaskNotifier{T}"/> type, which needs\n        /// to be used in the backing field for the target <see cref = "global::System.Threading.Tasks.Task"/> property. The field doesn\'t need to be\n        /// initialized, as this method will take care of doing that automatically. The <see cref = "TaskNotifier{T}"/>\n        /// type also includes an implicit operator, so it can be assigned to any <see cref = "global::System.Threading.Tasks.Task"/> instance directly.\n        /// Here is a sample property declaration using this method:\n        /// <code>\n        /// private TaskNotifier&lt;int&gt; myTask;\n        ///\n        /// public Task&lt;int&gt; MyTask\n        /// {\n        ///     get => myTask;\n        ///     private set => SetAndNotifyOnCompletion(ref myTask, value);\n        /// }\n        /// </code>\n        /// </summary>\n        /// <typeparam name = "T">The type of result for the <see cref = "global::System.Threading.Tasks.Task{TResult}"/> to set and monitor.</typeparam>\n        /// <param name = "taskNotifier">The field notifier to modify.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        /// <remarks>\n        /// The <see cref = "PropertyChanged"/> event is not raised if the current and new value for the target property are\n        /// the same. The return value being <see langword="true"/> only indicates that the new value being assigned to\n        /// <paramref name = "taskNotifier"/> is different than the previous one, and it does not mean the new\n        /// <see cref = "global::System.Threading.Tasks.Task{TResult}"/> instance passed as argument is in any particular state.\n        /// </remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected bool SetPropertyAndNotifyOnCompletion<T>([global::System.Diagnostics.CodeAnalysis.NotNull] ref TaskNotifier<T>? taskNotifier, global::System.Threading.Tasks.Task<T>? newValue, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n        {\n            return SetPropertyAndNotifyOnCompletion(taskNotifier ??= new TaskNotifier<T>(), newValue, null, propertyName);\n        }\n\n        /// <summary>\n        /// Compares the current and new values for a given field (which should be the backing field for a property).\n        /// If the value has changed, updates the field and then raises the <see cref = "PropertyChanged"/> event.\n        /// This method is just like <see cref = "SetPropertyAndNotifyOnCompletion{T}(ref TaskNotifier{T}, global::System.Threading.Tasks.Task{T}, string)"/>,\n        /// with the difference being an extra <see cref = "global::System.Action{T}"/> parameter with a callback being invoked\n        /// either immediately, if the new task has already completed or is <see langword="null"/>, or upon completion.\n        /// </summary>\n        /// <typeparam name = "T">The type of result for the <see cref = "global::System.Threading.Tasks.Task{TResult}"/> to set and monitor.</typeparam>\n        /// <param name = "taskNotifier">The field notifier to modify.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "callback">A callback to invoke to update the property value.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        /// <remarks>\n        /// The <see cref = "PropertyChanged"/> event is not raised if the current and new value for the target property are the same.\n        /// </remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected bool SetPropertyAndNotifyOnCompletion<T>([global::System.Diagnostics.CodeAnalysis.NotNull] ref TaskNotifier<T>? taskNotifier, global::System.Threading.Tasks.Task<T>? newValue, global::System.Action<global::System.Threading.Tasks.Task<T>?> callback, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n        {\n            return SetPropertyAndNotifyOnCompletion(taskNotifier ??= new TaskNotifier<T>(), newValue, callback, propertyName);\n        }\n\n        /// <summary>\n        /// Implements the notification logic for the related methods.\n        /// </summary>\n        /// <typeparam name = "TTask">The type of <see cref = "global::System.Threading.Tasks.Task"/> to set and monitor.</typeparam>\n        /// <param name = "taskNotifier">The field notifier.</param>\n        /// <param name = "newValue">The property\'s value after the change occurred.</param>\n        /// <param name = "callback">(optional) A callback to invoke to update the property value.</param>\n        /// <param name = "propertyName">(optional) The name of the property that changed.</param>\n        /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        private bool SetPropertyAndNotifyOnCompletion<TTask>(ITaskNotifier<TTask> taskNotifier, TTask? newValue, global::System.Action<TTask?>? callback, [global::System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)\n            where TTask : global::System.Threading.Tasks.Task\n        {\n            if (ReferenceEquals(taskNotifier.Task, newValue))\n            {\n                return false;\n            }\n\n            bool isAlreadyCompletedOrNull = newValue?.IsCompleted ?? true;\n            taskNotifier.Task = newValue;\n            OnPropertyChanged(propertyName);\n            if (isAlreadyCompletedOrNull)\n            {\n                if (callback != null)\n                {\n                    callback(newValue);\n                }\n\n                return true;\n            }\n\n            async void MonitorTask()\n            {\n                await global::CommunityToolkit.Mvvm.ComponentModel.__Internals.__TaskExtensions.GetAwaitableWithoutEndValidation(newValue!);\n                if (ReferenceEquals(taskNotifier.Task, newValue))\n                {\n                    OnPropertyChanged(propertyName);\n                }\n\n                if (callback != null)\n                {\n                    callback(newValue);\n                }\n            }\n\n            MonitorTask();\n            return true;\n        }\n\n        /// <summary>\n        /// An interface for task notifiers of a specified type.\n        /// </summary>\n        /// <typeparam name = "TTask">The type of value to store.</typeparam>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        private interface ITaskNotifier<TTask>\n            where TTask : global::System.Threading.Tasks.Task\n        {\n            /// <summary>\n            /// Gets or sets the wrapped <typeparamref name = "TTask"/> value.\n            /// </summary>\n            TTask? Task { get; set; }\n        }\n\n        /// <summary>\n        /// A wrapping class that can hold a <see cref = "global::System.Threading.Tasks.Task"/> value.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected sealed class TaskNotifier : ITaskNotifier<global::System.Threading.Tasks.Task>\n        {\n            /// <summary>\n            /// Initializes a new instance of the <see cref = "TaskNotifier"/> class.\n            /// </summary>\n            internal TaskNotifier()\n            {\n            }\n\n            private global::System.Threading.Tasks.Task? task;\n            /// <inheritdoc/>\n            global::System.Threading.Tasks.Task? ITaskNotifier<global::System.Threading.Tasks.Task>.Task { get => this.task; set => this.task = value; }\n\n            /// <summary>\n            /// Unwraps the <see cref = "global::System.Threading.Tasks.Task"/> value stored in the current instance.\n            /// </summary>\n            /// <param name = "notifier">The input <see cref = "TaskNotifier{TTask}"/> instance.</param>\n            public static implicit operator global::System.Threading.Tasks.Task? (TaskNotifier? notifier)\n            {\n                return notifier?.task;\n            }\n        }\n\n        /// <summary>\n        /// A wrapping class that can hold a <see cref = "global::System.Threading.Tasks.Task{T}"/> value.\n        /// </summary>\n        /// <typeparam name = "T">The type of value for the wrapped <see cref = "global::System.Threading.Tasks.Task{T}"/> instance.</typeparam>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.INotifyPropertyChangedGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.DebuggerNonUserCode]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        protected sealed class TaskNotifier<T> : ITaskNotifier<global::System.Threading.Tasks.Task<T>>\n        {\n            /// <summary>\n            /// Initializes a new instance of the <see cref = "TaskNotifier{TTask}"/> class.\n            /// </summary>\n            internal TaskNotifier()\n            {\n            }\n\n            private global::System.Threading.Tasks.Task<T>? task;\n            /// <inheritdoc/>\n            global::System.Threading.Tasks.Task<T>? ITaskNotifier<global::System.Threading.Tasks.Task<T>>.Task { get => this.task; set => this.task = value; }\n\n            /// <summary>\n            /// Unwraps the <see cref = "global::System.Threading.Tasks.Task{T}"/> value stored in the current instance.\n            /// </summary>\n            /// <param name = "notifier">The input <see cref = "TaskNotifier{TTask}"/> instance.</param>\n            public static implicit operator global::System.Threading.Tasks.Task<T>? (TaskNotifier<T>? notifier)\n            {\n                return notifier?.task;\n            }\n        }\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\CommunityToolkit.Mvvm\\src\\ToolkitMVVM\\obj\\GX\\CommunityToolkit.Mvvm.SourceGenerators\\CommunityToolkit.Mvvm.SourceGenerators.ObservablePropertyGenerator\\test.MyViewModel.g.cs",label:"test.MyViewModel.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'// <auto-generated/>\n#pragma warning disable\n#nullable enable\nnamespace test\n{\n    /// <inheritdoc/>\n    partial class MyViewModel\n    {\n        /// <inheritdoc cref="name"/>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.ObservablePropertyGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        public string? Name\n        {\n            get => name;\n            set\n            {\n                if (!global::System.Collections.Generic.EqualityComparer<string?>.Default.Equals(name, value))\n                {\n                    OnNameChanging(value);\n                    OnNameChanging(default, value);\n                    name = value;\n                    OnNameChanged(value);\n                    OnNameChanged(default, value);\n                    OnPropertyChanged(global::CommunityToolkit.Mvvm.ComponentModel.__Internals.__KnownINotifyPropertyChangedArgs.Name);\n                }\n            }\n        }\n\n        /// <summary>Executes the logic for when <see cref="Name"/> is changing.</summary>\n        /// <param name="value">The new property value being set.</param>\n        /// <remarks>This method is invoked right before the value of <see cref="Name"/> is changed.</remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.ObservablePropertyGenerator", "8.2.0.0")]\n        partial void OnNameChanging(string? value);\n        /// <summary>Executes the logic for when <see cref="Name"/> is changing.</summary>\n        /// <param name="oldValue">The previous property value that is being replaced.</param>\n        /// <param name="newValue">The new property value being set.</param>\n        /// <remarks>This method is invoked right before the value of <see cref="Name"/> is changed.</remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.ObservablePropertyGenerator", "8.2.0.0")]\n        partial void OnNameChanging(string? oldValue, string? newValue);\n        /// <summary>Executes the logic for when <see cref="Name"/> just changed.</summary>\n        /// <param name="value">The new property value that was set.</param>\n        /// <remarks>This method is invoked right after the value of <see cref="Name"/> is changed.</remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.ObservablePropertyGenerator", "8.2.0.0")]\n        partial void OnNameChanged(string? value);\n        /// <summary>Executes the logic for when <see cref="Name"/> just changed.</summary>\n        /// <param name="oldValue">The previous property value that was replaced.</param>\n        /// <param name="newValue">The new property value that was set.</param>\n        /// <remarks>This method is invoked right after the value of <see cref="Name"/> is changed.</remarks>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.ObservablePropertyGenerator", "8.2.0.0")]\n        partial void OnNameChanged(string? oldValue, string? newValue);\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\CommunityToolkit.Mvvm\\src\\ToolkitMVVM\\obj\\GX\\CommunityToolkit.Mvvm.SourceGenerators\\CommunityToolkit.Mvvm.SourceGenerators.ObservablePropertyGenerator\\__KnownINotifyPropertyChangedArgs.g.cs",label:"__KnownINotifyPropertyChangedArgs.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'// <auto-generated/>\n#pragma warning disable\n#nullable enable\nnamespace CommunityToolkit.Mvvm.ComponentModel.__Internals\n{\n    /// <summary>\n    /// A helper type providing cached, reusable <see cref="global::System.ComponentModel.PropertyChangedEventArgs"/> instances\n    /// for all properties generated with <see cref="global::CommunityToolkit.Mvvm.ComponentModel.ObservablePropertyAttribute"/>.\n    /// </summary>\n    [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.ObservablePropertyGenerator", "8.2.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCode]\n    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]\n    [global::System.Obsolete("This type is not intended to be used directly by user code")]\n    internal static class __KnownINotifyPropertyChangedArgs\n    {\n        /// <summary>The cached <see cref="global::System.ComponentModel.PropertyChangedEventArgs"/> instance for all "Name" generated properties.</summary>\n        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]\n        [global::System.Obsolete("This field is not intended to be referenced directly by user code")]\n        public static readonly global::System.ComponentModel.PropertyChangedEventArgs Name = new global::System.ComponentModel.PropertyChangedEventArgs("Name");\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\CommunityToolkit.Mvvm\\src\\ToolkitMVVM\\obj\\GX\\CommunityToolkit.Mvvm.SourceGenerators\\CommunityToolkit.Mvvm.SourceGenerators.RelayCommandGenerator\\test.MyViewModel.SayHello.g.cs",label:"test.MyViewModel.SayHello.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'// <auto-generated/>\n#pragma warning disable\n#nullable enable\nnamespace test\n{\n    /// <inheritdoc/>\n    partial class MyViewModel\n    {\n        /// <summary>The backing field for <see cref="SayHelloCommand"/>.</summary>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.RelayCommandGenerator", "8.2.0.0")]\n        private global::CommunityToolkit.Mvvm.Input.RelayCommand? sayHelloCommand;\n        /// <summary>Gets an <see cref="global::CommunityToolkit.Mvvm.Input.IRelayCommand"/> instance wrapping <see cref="SayHello"/>.</summary>\n        [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.RelayCommandGenerator", "8.2.0.0")]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n        public global::CommunityToolkit.Mvvm.Input.IRelayCommand SayHelloCommand => sayHelloCommand ??= new global::CommunityToolkit.Mvvm.Input.RelayCommand(new global::System.Action(SayHello));\n    }\n}\n')))),(0,o.kt)("h2",{id:"usefull"},"Usefull"),(0,o.kt)("h3",{id:"download-example"},"Download Example"),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("a",{target:"_blank",href:t(634).Z},"Download Example CommunityToolkit.Mvvm "))),(0,o.kt)("h3",{id:"download-pdf"},"Download PDF"),(0,o.kt)("p",null,(0,o.kt)("a",{target:"_blank",href:t(2178).Z},"Download PDF CommunityToolkit.Mvvm ")),(0,o.kt)("h3",{id:"share-communitytoolkitmvvm"},"Share CommunityToolkit.Mvvm"),(0,o.kt)("ul",null,(0,o.kt)("li",null,(0,o.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommunityToolkit.Mvvm&quote=CommunityToolkit.Mvvm",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,o.kt)("li",null,(0,o.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommunityToolkit.Mvvm&text=CommunityToolkit.Mvvm:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommunityToolkit.Mvvm",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,o.kt)("li",null,(0,o.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommunityToolkit.Mvvm&title=CommunityToolkit.Mvvm",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,o.kt)("li",null,(0,o.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommunityToolkit.Mvvm&title=CommunityToolkit.Mvvm&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommunityToolkit.Mvvm",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/CommunityToolkit.Mvvm"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/CommunityToolkit.Mvvm")))}h.isMDXComponent=!0},2178:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/files/CommunityToolkit.Mvvm-8ba22cd750405a81430884680d7fdcf2.pdf"},634:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/files/CommunityToolkit.Mvvm-6e67db4ae5b3abf9525e61051ed65623.zip"}}]);