"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[1105],{11960:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>b,contentTitle:()=>m,default:()=>u,frontMatter:()=>r,metadata:()=>y,toc:()=>c});var a=n(87462),o=(n(67294),n(3905)),l=n(73992),s=n(18679),i=n(68839);const r={sidebar_position:1230,title:"123 - CodeAnalysis",description:"Code to string literal. Unfortunately, it carries also some other CodeAnalysis generated files, which are not so useful.",slug:"/CodeAnalysis"},m="CodeAnalysis  by Feast",y={unversionedId:"RSCG-Examples/CodeAnalysis",id:"RSCG-Examples/CodeAnalysis",title:"123 - CodeAnalysis",description:"Code to string literal. Unfortunately, it carries also some other CodeAnalysis generated files, which are not so useful.",source:"@site/docs/RSCG-Examples/CodeAnalysis.md",sourceDirName:"RSCG-Examples",slug:"/CodeAnalysis",permalink:"/RSCG_Examples/v2/docs/CodeAnalysis",draft:!1,tags:[],version:"current",sidebarPosition:1230,frontMatter:{sidebar_position:1230,title:"123 - CodeAnalysis",description:"Code to string literal. Unfortunately, it carries also some other CodeAnalysis generated files, which are not so useful.",slug:"/CodeAnalysis"},sidebar:"tutorialSidebar",previous:{title:"122 - RSCG_JSON2Class",permalink:"/RSCG_Examples/v2/docs/RSCG_JSON2Class"},next:{title:"124 - Architect.DomainModeling",permalink:"/RSCG_Examples/v2/docs/Architect.DomainModeling"}},b={},c=[{value:"Nuget / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share CodeAnalysis",id:"share-codeanalysis",level:3},{value:"In the same category (CodeToString) - 1 other generators",id:"in-the-same-category-codetostring---1-other-generators",level:3},{value:"SourceGenerator.Helper.CopyCode",id:"sourcegeneratorhelpercopycode",level:4}],d={toc:c},p="wrapper";function u(e){let{components:t,...r}=e;return(0,o.kt)(p,(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"codeanalysis--by-feast"},"CodeAnalysis  by Feast"),(0,o.kt)(i.Z,{toc:c,mdxType:"TOCInline"}),(0,o.kt)("h2",{id:"nuget--site-data"},"Nuget / site data"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Feast.CodeAnalysis/"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/Feast.CodeAnalysis?label=Feast.CodeAnalysis",alt:"Nuget"})),"\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/feast107/CodeAnalysis"},(0,o.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/feast107/CodeAnalysis?label=updated",alt:"GitHub last commit"})),"\n",(0,o.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/feast107/CodeAnalysis?style=social",alt:"GitHub Repo stars"})),(0,o.kt)("h2",{id:"details"},"Details"),(0,o.kt)("h3",{id:"info"},"Info"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Name: ",(0,o.kt)("strong",{parentName:"p"},"CodeAnalysis")),(0,o.kt)("p",{parentName:"admonition"},"Auto generate extensions for Microsoft.CodeAnalysis"),(0,o.kt)("p",{parentName:"admonition"},"Author: Feast"),(0,o.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/Feast.CodeAnalysis/"},"https://www.nuget.org/packages/Feast.CodeAnalysis/")),"   "),(0,o.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/feast107/CodeAnalysis"},"https://github.com/feast107/CodeAnalysis")),(0,o.kt)("p",{parentName:"admonition"},"Source : ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/feast107/CodeAnalysis"},"https://github.com/feast107/CodeAnalysis"))),(0,o.kt)("h3",{id:"original-readme"},"Original Readme"),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("h1",{parentName:"admonition",id:"codeanalysis"},"CodeAnalysis"),(0,o.kt)("p",{parentName:"admonition"},"\u81ea\u52a8\u751f\u6210\u63d0\u4f9b\u7ed9 ",(0,o.kt)("inlineCode",{parentName:"p"},"SourceGenerator")," \u7684\u6269\u5c55"),(0,o.kt)("h2",{parentName:"admonition",id:"requires"},"Requires"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Sergio0694/PolySharp"},"PolySharp"))),(0,o.kt)("h2",{parentName:"admonition",id:"supports"},"Supports"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"[Literal]")),(0,o.kt)("p",{parentName:"li"},"  Auto generate full qualified string literal for target class"),(0,o.kt)("p",{parentName:"li"},"  if you have a class like"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'[Literal("Your.Program.Class")]\npublic class Test\n{\n    public IEnumerable<string> Name { get; set; }\n}\n')),(0,o.kt)("p",{parentName:"li"},"  Then it will generate a class like"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'namespace Your.Program{\n    public class Class{\n        public static string Text = """\npublic class Test\n{\n    public global::System.Collection.Generic.IEnumerable<string> Name { get; set; }\n}\n""";\n    }\n}\n'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"Feast.CompileTime")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"class Assembly : System.Reflection.Assembly;\nclass Module : System.Reflection.Module;\nclass Type : System.Type;\nclass MemberInfo : System.Reflection.MemberInfo;\nclass MethodInfo : System.Reflection.MethodInfo;\nclass EventInfo : System.Reflection.EventInfo;\nclass FieldInfo : System.Reflection.FieldInfo;\nclass PropertyInfo : System.Reflection.PropertyInfo;\nclass ParameterInfo : System.Reflection.ParameterInfo;\nclass ConstructorInfo : System.Reflection.ConstructorInfo;\n")))),(0,o.kt)("h2",{parentName:"admonition",id:"comment"},"Comment"),(0,o.kt)("p",{parentName:"admonition"},"\u6211\u4eec\u9700\u8981 ",(0,o.kt)("inlineCode",{parentName:"p"},"\u6e90\u4ee3\u7801\u751f\u6210\u5668")),(0,o.kt)("p",{parentName:"admonition"},"\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u751f\u6210\u66f4\u591a\u7684\u4ee3\u7801"),(0,o.kt)("p",{parentName:"admonition"},"\u6211\u4eec\u9700\u8981 ",(0,o.kt)("inlineCode",{parentName:"p"},"\u6e90\u4ee3\u7801\u751f\u6210\u5668")," \u7684 ",(0,o.kt)("inlineCode",{parentName:"p"},"\u6e90\u4ee3\u7801\u751f\u6210\u5668")),(0,o.kt)("p",{parentName:"admonition"},"\u56e0\u4e3a ",(0,o.kt)("inlineCode",{parentName:"p"},"\u6e90\u4ee3\u7801\u751f\u6210\u5668")," \u73b0\u5728\u8fd8\u4e0d\u591f\u5f3a\u5927"),(0,o.kt)("p",{parentName:"admonition"},"\u6211\u4eec\u9700\u8981 ",(0,o.kt)("inlineCode",{parentName:"p"},"\u6e90\u4ee3\u7801\u751f\u6210\u5668")," \u7684 ",(0,o.kt)("inlineCode",{parentName:"p"},"\u6e90\u4ee3\u7801\u751f\u6210\u5668")," \u7684 ",(0,o.kt)("inlineCode",{parentName:"p"},"\u6e90\u4ee3\u7801\u751f\u6210\u5668")),(0,o.kt)("p",{parentName:"admonition"},"\u56e0\u4e3a ",(0,o.kt)("inlineCode",{parentName:"p"},"\u6e90\u4ee3\u7801\u751f\u6210\u5668")," \u7684 ",(0,o.kt)("inlineCode",{parentName:"p"},"\u6e90\u4ee3\u7801\u751f\u6210\u5668")," \u73b0\u5728\u8fd8\u4e0d\u80fd\u81ea\u4e3e"),(0,o.kt)("p",{parentName:"admonition"},"\u7531\u6b64\u53ef\u89c1"),(0,o.kt)("p",{parentName:"admonition"},"\u9053\u751f\u4e00\uff0c\u4e00\u751f\u4e8c\uff0c\u4e8c\u751f\u4e09\uff0c\u4e09\u751f\u4e07\u7269"),(0,o.kt)("p",{parentName:"admonition"},"\u603b\u7ed3"),(0,o.kt)("p",{parentName:"admonition"},"\u73a9\u6e90\u751f\u73a9\u7684\u3002")),(0,o.kt)("h3",{id:"about"},"About"),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Code to string literal. Unfortunately, it carries also some other CodeAnalysis generated files, which are not so useful.")),(0,o.kt)("h2",{id:"how-to-use"},"How to use"),(0,o.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,o.kt)("p",null,"This is the CSharp Project that references ",(0,o.kt)("strong",{parentName:"p"},"CodeAnalysis")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {11}",showLineNumbers:!0,"{11}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include="Feast.CodeAnalysis" Version="0.1.4" />\n      <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.3.4">\n          <PrivateAssets>all</PrivateAssets>\n          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n      </PackageReference>\n      <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.0.1" />\n  </ItemGroup>\n    <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n</Project>\n\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,o.kt)("p",null,"  This is the use of ",(0,o.kt)("strong",{parentName:"p"},"CodeAnalysis")," in ",(0,o.kt)("em",{parentName:"p"},"Program.cs")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"Console.WriteLine(Namespace_Andrei.Class_Ignat.Text);\n")))),(0,o.kt)("h3",{id:"generated-files"},"Generated Files"),(0,o.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.AttributeDataExtensionsGenerator\\Feast.CodeAnalysis.AttributeDataExtensions.g.cs",label:"Feast.CodeAnalysis.AttributeDataExtensions.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using System;\nusing System.Linq;\n\nnamespace Microsoft.CodeAnalysis\n{\n    public static class AttributeDataExtensions\n    {\n        internal static T ToAttribute<T>(this global::Microsoft.CodeAnalysis.AttributeData attributeData)\n            where T : global::System.Attribute\n        {\n            if (attributeData.AttributeConstructor == null)\n                throw new global::System.ArgumentException("Attribute constructor not found");\n            var attrType = typeof(T);\n            var ctor = attrType.GetConstructors().FirstOrDefault(x =>\n            {\n                var param = x.GetParameters();\n                if (param.Length != attributeData.AttributeConstructor.Parameters.Length)\n                    return false;\n                return !param.Where((t, i) => attributeData.AttributeConstructor.Parameters[i].Type.ToType().FullName != t.ParameterType.FullName).Any();\n            });\n            if (ctor == null)\n                throw new global::System.MissingMethodException("Cannot find best match ctor for attribute");\n            var param = ctor.GetParameters();\n            var args = attributeData.ConstructorArguments.Select((x, i) => x.GetArgumentValue(param[i].ParameterType)).ToArray();\n            var attribute = (T)global::System.Activator.CreateInstance(typeof(T), args);\n            var publicProps = attrType.GetProperties(global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance).Where(static x => x.CanWrite).ToDictionary(static x => x.Name, static x => x);\n            foreach (var argument in attributeData.NamedArguments)\n            {\n                if (!publicProps.TryGetValue(argument.Key, out var prop))\n                    continue;\n                prop.SetValue(attribute, argument.Value.GetArgumentValue(prop.PropertyType));\n            }\n\n            return attribute;\n        }\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.Assembly.g.cs",label:"Feast.CodeAnalysis.Assembly.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing System.Linq;\nusing Microsoft.CodeAnalysis;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    internal partial class Assembly(global::Microsoft.CodeAnalysis.IAssemblySymbol symbol) : global::System.Reflection.Assembly, global::System.IEquatable<global::System.Reflection.Assembly>\n    {\n        internal readonly global::Microsoft.CodeAnalysis.IAssemblySymbol Symbol = symbol;\n        public override string FullName => Symbol.GetFullyQualifiedName();\n        public override string Location => Symbol.Locations.FirstOrDefault()?.GetLineSpan().Path ?? string.Empty;\n        public override bool ReflectionOnly => !Symbol.CanBeReferencedByName;\n        public override global::System.Collections.Generic.IEnumerable<global::System.Reflection.Module> Modules => Symbol.Modules.Select(static x => new global::Feast.CodeAnalysis.CompileTime.Module(x));\n        public override global::System.Collections.Generic.IEnumerable<global::System.Type> ExportedTypes => Symbol.GetForwardedTypes().Where(static x => x.DeclaredAccessibility == global::Microsoft.CodeAnalysis.Accessibility.Public).Select(static x => new global::Feast.CodeAnalysis.CompileTime.Type(x));\n\n        public bool Equals(global::System.Reflection.Assembly other)\n        {\n            if (other is global::Feast.CodeAnalysis.CompileTime.Assembly compileTime)\n                return global::Microsoft.CodeAnalysis.SymbolEqualityComparer.Default.Equals(Symbol, compileTime.Symbol);\n            return other is not null && FullName == other.FullName;\n        }\n\n        public override int GetHashCode() => Symbol.GetHashCode();\n        public override bool Equals(object o) => o is global::Feast.CodeAnalysis.CompileTime.Assembly assembly && Equals(assembly);\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.AttributeData.g.cs",label:"Feast.CodeAnalysis.AttributeData.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Reflection.Metadata;\nusing Microsoft.CodeAnalysis;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    public partial class AttributeData(global::Microsoft.CodeAnalysis.AttributeData attributeData) : global::System.Reflection.CustomAttributeData\n    {\n        public override global::System.Reflection.ConstructorInfo Constructor => new global::Feast.CodeAnalysis.CompileTime.ConstructorInfo(attributeData.AttributeConstructor!);\n        public override global::System.Collections.Generic.IList<global::System.Reflection.CustomAttributeTypedArgument> ConstructorArguments => attributeData.ConstructorArguments.Select((x, i) =>\n        {\n            var value = x.GetArgumentValue();\n            return new CustomAttributeTypedArgument(attributeData.AttributeConstructor!.Parameters[i].Type.ToType(), value);\n        }).ToList();\n        public override global::System.Collections.Generic.IList<global::System.Reflection.CustomAttributeNamedArgument> NamedArguments => attributeData.NamedArguments.Select(x =>\n        {\n            var value = x.Value.GetArgumentValue();\n            if (value is null)\n                return (global::System.Reflection.CustomAttributeNamedArgument? )null;\n            return new global::System.Reflection.CustomAttributeNamedArgument(attributeData.AttributeClass!.GetMembers().First(p => p.Name == x.Key).ToMemberInfo(), value);\n        }).Where(static x => x != null).Cast<global::System.Reflection.CustomAttributeNamedArgument>().ToList();\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.CompileTimeExtensions.g.cs",label:"Feast.CodeAnalysis.CompileTimeExtensions.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing System.Reflection;\n\nnamespace Microsoft.CodeAnalysis\n{\n    public static partial class CompileTimeExtensions\n    {\n        public static global::System.Reflection.Assembly ToAssembly(this global::Microsoft.CodeAnalysis.IAssemblySymbol symbol) => new global::Feast.CodeAnalysis.CompileTime.Assembly(symbol);\n        public static global::System.Reflection.Module ToModule(this global::Microsoft.CodeAnalysis.IModuleSymbol symbol) => new global::Feast.CodeAnalysis.CompileTime.Module(symbol);\n        public static global::System.Type ToType(this global::Microsoft.CodeAnalysis.ITypeSymbol symbol) => new global::Feast.CodeAnalysis.CompileTime.Type(symbol);\n        public static global::System.Reflection.MemberInfo ToMemberInfo(this global::Microsoft.CodeAnalysis.ISymbol symbol) => new global::Feast.CodeAnalysis.CompileTime.MemberInfo(symbol);\n        public static global::System.Reflection.MethodInfo ToMethodInfo(this global::Microsoft.CodeAnalysis.IMethodSymbol symbol) => new global::Feast.CodeAnalysis.CompileTime.MethodInfo(symbol);\n        public static global::System.Reflection.FieldInfo ToFieldInfo(this global::Microsoft.CodeAnalysis.IFieldSymbol symbol) => new global::Feast.CodeAnalysis.CompileTime.FieldInfo(symbol);\n        public static global::System.Reflection.PropertyInfo ToPropertyInfo(this global::Microsoft.CodeAnalysis.IPropertySymbol symbol) => new global::Feast.CodeAnalysis.CompileTime.PropertyInfo(symbol);\n        public static global::System.Reflection.ConstructorInfo ToConstructorInfo(this global::Microsoft.CodeAnalysis.IMethodSymbol symbol) => new global::Feast.CodeAnalysis.CompileTime.ConstructorInfo(symbol);\n        public static global::System.Reflection.EventInfo ToEventInfo(this global::Microsoft.CodeAnalysis.IEventSymbol symbol) => new global::Feast.CodeAnalysis.CompileTime.EventInfo(symbol);\n        public static global::System.Reflection.ParameterInfo ToParameterInfo(this global::Microsoft.CodeAnalysis.IParameterSymbol symbol) => new global::Feast.CodeAnalysis.CompileTime.ParameterInfo(symbol);\n        public static bool IsAssignableTo(this global::System.Type type, global::System.Type another) => another.IsAssignableFrom(type);\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.ConstructorInfo.g.cs",label:"Feast.CodeAnalysis.ConstructorInfo.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing System.Linq;\nusing System.Reflection;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    internal partial class ConstructorInfo(global::Microsoft.CodeAnalysis.IMethodSymbol constructor) : global::System.Reflection.ConstructorInfo\n    {\n        public override object[] GetCustomAttributes(bool inherit) => constructor.GetAttributes().CastArray<object>().ToArray();\n        public override object[] GetCustomAttributes(global::System.Type attributeType, bool inherit) => constructor.GetAttributes().Where(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName).Cast<object>().ToArray();\n        public override bool IsDefined(global::System.Type attributeType, bool inherit) => constructor.GetAttributes().Any(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName);\n        public override global::System.Type DeclaringType => new global::Feast.CodeAnalysis.CompileTime.Type((constructor.ContainingSymbol as global::Microsoft.CodeAnalysis.ITypeSymbol)!);\n        public override string Name => constructor.MetadataName;\n        public override global::System.Type ReflectedType => new global::Feast.CodeAnalysis.CompileTime.Type(constructor.ReturnType);\n\n        public override global::System.Reflection.MethodImplAttributes GetMethodImplementationFlags() => throw new global::System.NotSupportedException();\n        public override global::System.Reflection.ParameterInfo[] GetParameters() => constructor.Parameters.Select(static x => (global::System.Reflection.ParameterInfo)new global::Feast.CodeAnalysis.CompileTime.ParameterInfo(x)).ToArray();\n        public override object Invoke(object obj, global::System.Reflection.BindingFlags invokeAttr, global::System.Reflection.Binder binder, object[] parameters, global::System.Globalization.CultureInfo culture) => throw new global::System.NotSupportedException();\n        public override global::System.Reflection.MethodAttributes Attributes\n        {\n            get\n            {\n                var ret = global::System.Reflection.MethodAttributes.PrivateScope;\n                if (constructor.IsStatic)\n                    ret |= global::System.Reflection.MethodAttributes.Static;\n                if (constructor.IsVirtual)\n                    ret |= global::System.Reflection.MethodAttributes.Virtual;\n                if (constructor.IsAbstract)\n                    ret |= global::System.Reflection.MethodAttributes.Abstract;\n                switch (constructor.DeclaredAccessibility)\n                {\n                    case global::Microsoft.CodeAnalysis.Accessibility.Public:\n                        ret |= global::System.Reflection.MethodAttributes.Public;\n                        break;\n                    case Microsoft.CodeAnalysis.Accessibility.Protected or Microsoft.CodeAnalysis.Accessibility.Private:\n                        ret |= global::System.Reflection.MethodAttributes.Private;\n                        break;\n                }\n\n                return ret;\n            }\n        }\n\n        public override global::System.RuntimeMethodHandle MethodHandle => throw new global::System.NotSupportedException();\n\n        public override object Invoke(global::System.Reflection.BindingFlags invokeAttr, global::System.Reflection.Binder binder, object[] parameters, global::System.Globalization.CultureInfo culture) => throw new global::System.NotSupportedException();\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.EventInfo.g.cs",label:"Feast.CodeAnalysis.EventInfo.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing System.Linq;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    internal partial class EventInfo(global::Microsoft.CodeAnalysis.IEventSymbol @event) : global::System.Reflection.EventInfo\n    {\n        public override object[] GetCustomAttributes(bool inherit) => @event.GetAttributes().CastArray<object>().ToArray();\n        public override object[] GetCustomAttributes(global::System.Type attributeType, bool inherit) => @event.GetAttributes().Where(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName).Cast<object>().ToArray();\n        public override bool IsDefined(global::System.Type attributeType, bool inherit) => @event.GetAttributes().Any(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName);\n        public override global::System.Type DeclaringType => new global::Feast.CodeAnalysis.CompileTime.Type((@event.ContainingSymbol as global::Microsoft.CodeAnalysis.ITypeSymbol)!);\n        public override string Name => @event.MetadataName;\n        public override global::System.Type ReflectedType => DeclaringType;\n\n        public override global::System.Reflection.MethodInfo GetAddMethod(bool nonPublic) => @event.AddMethod == null ? null : @event.AddMethod.DeclaredAccessibility != global::Microsoft.CodeAnalysis.Accessibility.Public == nonPublic ? new global::Feast.CodeAnalysis.CompileTime.MethodInfo(@event.AddMethod) : null;\n        public override global::System.Reflection.MethodInfo GetRaiseMethod(bool nonPublic) => @event.RaiseMethod == null ? null : @event.RaiseMethod.DeclaredAccessibility != global::Microsoft.CodeAnalysis.Accessibility.Public == nonPublic ? new global::Feast.CodeAnalysis.CompileTime.MethodInfo(@event.RaiseMethod) : null;\n        public override global::System.Reflection.MethodInfo GetRemoveMethod(bool nonPublic) => @event.RemoveMethod == null ? null : @event.RemoveMethod.DeclaredAccessibility != global::Microsoft.CodeAnalysis.Accessibility.Public == nonPublic ? new global::Feast.CodeAnalysis.CompileTime.MethodInfo(@event.RemoveMethod) : null;\n        public override global::System.Reflection.EventAttributes Attributes => global::System.Reflection.EventAttributes.None;\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.FieldInfo.g.cs",label:"Feast.CodeAnalysis.FieldInfo.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing System.Linq;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    internal partial class FieldInfo(global::Microsoft.CodeAnalysis.IFieldSymbol field) : global::System.Reflection.FieldInfo\n    {\n        public override object[] GetCustomAttributes(bool inherit) => field.GetAttributes().CastArray<object>().ToArray();\n        public override object[] GetCustomAttributes(global::System.Type attributeType, bool inherit) => field.GetAttributes().Where(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName).Cast<object>().ToArray();\n        public override bool IsDefined(global::System.Type attributeType, bool inherit) => field.GetAttributes().Any(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName);\n        public override global::System.Type DeclaringType => new global::Feast.CodeAnalysis.CompileTime.Type(field.ContainingType);\n        public override string Name => field.MetadataName;\n        public override global::System.Type ReflectedType => FieldType;\n\n        public override object GetValue(object obj) => throw new global::System.NotSupportedException();\n        public override void SetValue(object obj, object value, global::System.Reflection.BindingFlags invokeAttr, global::System.Reflection.Binder binder, global::System.Globalization.CultureInfo culture) => throw new global::System.NotSupportedException();\n        public override global::System.Reflection.FieldAttributes Attributes\n        {\n            get\n            {\n                var ret = global::System.Reflection.FieldAttributes.PrivateScope;\n                if (field.IsStatic)\n                    ret |= global::System.Reflection.FieldAttributes.Static;\n                if (field.IsReadOnly)\n                    ret |= global::System.Reflection.FieldAttributes.InitOnly;\n                if (field.HasConstantValue)\n                    ret |= global::System.Reflection.FieldAttributes.HasDefault;\n                if (field.IsConst)\n                    ret |= global::System.Reflection.FieldAttributes.Literal;\n                switch (field.DeclaredAccessibility)\n                {\n                    case global::Microsoft.CodeAnalysis.Accessibility.Public:\n                        ret |= global::System.Reflection.FieldAttributes.Public;\n                        break;\n                    default:\n                        ret |= global::System.Reflection.FieldAttributes.Private;\n                        break;\n                }\n\n                return ret;\n            }\n        }\n\n        public override global::System.RuntimeFieldHandle FieldHandle => throw new global::System.NotSupportedException();\n        public override global::System.Type FieldType => new global::Feast.CodeAnalysis.CompileTime.Type(field.Type);\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.MemberInfo.g.cs",label:"Feast.CodeAnalysis.MemberInfo.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing System.Linq;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    internal partial class MemberInfo(global::Microsoft.CodeAnalysis.ISymbol symbol) : global::System.Reflection.MemberInfo\n    {\n        public override object[] GetCustomAttributes(bool inherit) => symbol.GetAttributes().CastArray<object>().ToArray();\n        public override object[] GetCustomAttributes(global::System.Type attributeType, bool inherit) => symbol.GetAttributes().Where(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName).Cast<object>().ToArray();\n        public override bool IsDefined(global::System.Type attributeType, bool inherit) => symbol.GetAttributes().Any(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName);\n        public override global::System.Type DeclaringType => new global::Feast.CodeAnalysis.CompileTime.Type(symbol.ContainingType);\n\n        public override global::System.Reflection.MemberTypes MemberType\n        {\n            get\n            {\n                return symbol switch\n                {\n                    global::Microsoft.CodeAnalysis.ITypeSymbol type => type.ContainingType != null ? global::System.Reflection.MemberTypes.NestedType : global::System.Reflection.MemberTypes.TypeInfo,\n                    global::Microsoft.CodeAnalysis.IPropertySymbol => global::System.Reflection.MemberTypes.Property,\n                    global::Microsoft.CodeAnalysis.IFieldSymbol => global::System.Reflection.MemberTypes.Field,\n                    global::Microsoft.CodeAnalysis.IMethodSymbol method => method.ContainingType.Constructors.Contains(method) ? global::System.Reflection.MemberTypes.Constructor : global::System.Reflection.MemberTypes.Method,\n                    global::Microsoft.CodeAnalysis.IEventSymbol => global::System.Reflection.MemberTypes.Event,\n                    _ => global::System.Reflection.MemberTypes.Custom\n                };\n            }\n        }\n\n        public override string Name => symbol.MetadataName;\n        public override global::System.Type ReflectedType => new global::Feast.CodeAnalysis.CompileTime.Type(symbol switch\n        {\n            global::Microsoft.CodeAnalysis.ITypeSymbol type => type,\n            global::Microsoft.CodeAnalysis.IPropertySymbol property => property.Type,\n            global::Microsoft.CodeAnalysis.IFieldSymbol field => field.Type,\n            global::Microsoft.CodeAnalysis.IMethodSymbol method => method.ReturnType,\n            _ => throw new global::System.ArgumentOutOfRangeException()});\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.MethodInfo.g.cs",label:"Feast.CodeAnalysis.MethodInfo.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing System.Linq;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    internal partial class MethodInfo(global::Microsoft.CodeAnalysis.IMethodSymbol method) : global::System.Reflection.MethodInfo\n    {\n        public override object[] GetCustomAttributes(bool inherit) => method.GetAttributes().CastArray<object>().ToArray();\n        public override object[] GetCustomAttributes(global::System.Type attributeType, bool inherit) => method.GetAttributes().Where(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName).Cast<object>().ToArray();\n        public override bool IsDefined(global::System.Type attributeType, bool inherit) => method.GetAttributes().Any(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName);\n        public override global::System.Type DeclaringType => new global::Feast.CodeAnalysis.CompileTime.Type((method.ContainingSymbol as global::Microsoft.CodeAnalysis.ITypeSymbol)!);\n        public override string Name => method.MetadataName;\n        public override global::System.Type ReflectedType => new global::Feast.CodeAnalysis.CompileTime.Type(method.ReturnType);\n\n        public override global::System.Reflection.MethodImplAttributes GetMethodImplementationFlags()\n        {\n            var ret = global::System.Reflection.MethodImplAttributes.Managed;\n            return ret;\n        }\n\n        public override global::System.Reflection.ParameterInfo[] GetParameters() => method.Parameters.Select(static x => (global::System.Reflection.ParameterInfo)new global::Feast.CodeAnalysis.CompileTime.ParameterInfo(x)).ToArray();\n        public override object Invoke(object obj, global::System.Reflection.BindingFlags invokeAttr, global::System.Reflection.Binder binder, object[] parameters, global::System.Globalization.CultureInfo culture) => throw new global::System.NotSupportedException();\n        public override global::System.Reflection.MethodAttributes Attributes\n        {\n            get\n            {\n                var ret = global::System.Reflection.MethodAttributes.PrivateScope;\n                if (method.IsStatic)\n                    ret |= global::System.Reflection.MethodAttributes.Static;\n                if (method.IsVirtual)\n                    ret |= global::System.Reflection.MethodAttributes.Virtual;\n                if (method.IsAbstract)\n                    ret |= global::System.Reflection.MethodAttributes.Abstract;\n                switch (method.DeclaredAccessibility)\n                {\n                    case global::Microsoft.CodeAnalysis.Accessibility.Public:\n                        ret |= global::System.Reflection.MethodAttributes.Public;\n                        break;\n                    case Microsoft.CodeAnalysis.Accessibility.Protected or Microsoft.CodeAnalysis.Accessibility.Private:\n                        ret |= global::System.Reflection.MethodAttributes.Private;\n                        break;\n                }\n\n                return ret;\n            }\n        }\n\n        public override global::System.RuntimeMethodHandle MethodHandle => throw new global::System.NotSupportedException();\n\n        public override global::System.Reflection.MethodInfo GetBaseDefinition() => new global::Feast.CodeAnalysis.CompileTime.MethodInfo(method.OriginalDefinition);\n        public override global::System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes => throw new global::System.NotImplementedException();\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.Module.g.cs",label:"Feast.CodeAnalysis.Module.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing Microsoft.CodeAnalysis;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    internal partial class Module(global::Microsoft.CodeAnalysis.IModuleSymbol module) : global::System.Reflection.Module\n    {\n        public override string Name => module.MetadataName;\n        public override string FullyQualifiedName => module.GetFullyQualifiedName();\n        public override global::System.Reflection.Assembly Assembly => new global::Feast.CodeAnalysis.CompileTime.Assembly(module.ContainingAssembly);\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.ParameterInfo.g.cs",label:"Feast.CodeAnalysis.ParameterInfo.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    internal partial class ParameterInfo(global::Microsoft.CodeAnalysis.IParameterSymbol parameter) : global::System.Reflection.ParameterInfo\n    {\n        public override string Name => parameter.MetadataName;\n        public override global::System.Type ParameterType => new global::Feast.CodeAnalysis.CompileTime.Type(parameter.Type);\n\n        public override global::System.Reflection.ParameterAttributes Attributes\n        {\n            get\n            {\n                var ret = global::System.Reflection.ParameterAttributes.None;\n                if (parameter.IsOptional)\n                    ret |= global::System.Reflection.ParameterAttributes.Optional;\n                switch (parameter.RefKind)\n                {\n                    case global::Microsoft.CodeAnalysis.RefKind.Out:\n                        ret |= global::System.Reflection.ParameterAttributes.Out;\n                        break;\n                    case global::Microsoft.CodeAnalysis.RefKind.In:\n                        ret |= global::System.Reflection.ParameterAttributes.In;\n                        break;\n                }\n\n                return ret;\n            }\n        }\n\n        public override object DefaultValue => parameter.ExplicitDefaultValue;\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.PropertyInfo.g.cs",label:"Feast.CodeAnalysis.PropertyInfo.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing System.Linq;\nusing Microsoft.CodeAnalysis;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    internal partial class PropertyInfo(global::Microsoft.CodeAnalysis.IPropertySymbol property) : global::System.Reflection.PropertyInfo\n    {\n        public override object[] GetCustomAttributes(bool inherit) => property.GetAttributes().Cast<object>().ToArray();\n        public override object[] GetCustomAttributes(global::System.Type attributeType, bool inherit) => property.GetAttributes().Where(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName).Cast<object>().ToArray();\n        public override bool IsDefined(global::System.Type attributeType, bool inherit) => property.GetAttributes().Any(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName);\n        public override global::System.Type DeclaringType => new global::Feast.CodeAnalysis.CompileTime.Type(property.ContainingType);\n        public override string Name => property.Name;\n        public override global::System.Type ReflectedType => PropertyType;\n\n        public override global::System.Reflection.MethodInfo[] GetAccessors(bool nonPublic) => [GetGetMethod(nonPublic), GetSetMethod(nonPublic)];\n        public override global::System.Reflection.MethodInfo GetGetMethod(bool nonPublic) => property.GetMethod == null ? null : property.GetMethod.DeclaredAccessibility != global::Microsoft.CodeAnalysis.Accessibility.Public == nonPublic ? new global::Feast.CodeAnalysis.CompileTime.MethodInfo(property.GetMethod) : null;\n        public override global::System.Reflection.ParameterInfo[] GetIndexParameters() => property.Parameters.Select(x => (global::System.Reflection.ParameterInfo)new global::Feast.CodeAnalysis.CompileTime.ParameterInfo(x)).ToArray();\n        public override global::System.Reflection.MethodInfo GetSetMethod(bool nonPublic) => property.SetMethod == null ? null : property.SetMethod.DeclaredAccessibility != global::Microsoft.CodeAnalysis.Accessibility.Public == nonPublic ? new global::Feast.CodeAnalysis.CompileTime.MethodInfo(property.SetMethod) : null;\n        public override object GetValue(object obj, global::System.Reflection.BindingFlags invokeAttr, global::System.Reflection.Binder binder, object[] index, global::System.Globalization.CultureInfo culture) => throw new global::System.NotSupportedException();\n        public override void SetValue(object obj, object value, global::System.Reflection.BindingFlags invokeAttr, global::System.Reflection.Binder binder, object[] index, global::System.Globalization.CultureInfo culture) => throw new global::System.NotSupportedException();\n        public override global::System.Reflection.PropertyAttributes Attributes => global::System.Reflection.PropertyAttributes.SpecialName;\n        public override bool CanRead => !property.IsWriteOnly;\n        public override bool CanWrite => !property.IsReadOnly;\n        public override global::System.Reflection.Module Module => property.ContainingModule.ToModule();\n        public override global::System.Type PropertyType => new global::Feast.CodeAnalysis.CompileTime.Type(property.Type);\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.Type.g.cs",label:"Feast.CodeAnalysis.Type.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using System;\nusing System.Linq;\nusing System.Reflection;\nusing Microsoft.CodeAnalysis;\n\nnamespace Feast.CodeAnalysis.CompileTime\n{\n    internal partial class Type(global::Microsoft.CodeAnalysis.ITypeSymbol symbol) : global::System.Type, global::System.IEquatable<global::System.Type>\n    {\n        internal readonly global::Microsoft.CodeAnalysis.ITypeSymbol Symbol = symbol;\n        public override object[] GetCustomAttributes(bool inherit) => Symbol.GetAttributes().CastArray<object>().ToArray();\n        public override object[] GetCustomAttributes(global::System.Type attributeType, bool inherit) => Symbol.GetAttributes().Where(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName).Cast<object>().ToArray();\n        public override bool IsDefined(global::System.Type attributeType, bool inherit) => Symbol.GetAttributes().Any(x => x.AttributeClass?.ToDisplayString() == attributeType.FullName);\n        public override global::System.Collections.Generic.IEnumerable<global::System.Reflection.CustomAttributeData> CustomAttributes => Symbol.GetAttributes().Select(x => new global::Feast.CodeAnalysis.CompileTime.AttributeData(x));\n        public override string Namespace => Symbol.ContainingNamespace.ToDisplayString();\n        public override string Name => Symbol.MetadataName;\n        public override string FullName => Symbol.TypeKind switch\n        {\n            global::Microsoft.CodeAnalysis.TypeKind.Array => $"{GetElementType()!.FullName}[]",\n            global::Microsoft.CodeAnalysis.TypeKind.Pointer => $"{GetElementType()!.FullName}*",\n            _ => $"{Namespace}.{Name}{(!IsGenericType ? string.Empty : \'[\' + string.Join(",", GenericTypeArguments.Select(x => $"[{x.AssemblyQualifiedName}]")) + \']\')}"};\n        public override string AssemblyQualifiedName => $"{FullName}, {Assembly.FullName}";\n        public override global::System.Guid GUID => throw new global::System.NotSupportedException();\n        public override global::System.Reflection.MemberTypes MemberType => Symbol.ContainingType is not null ? global::System.Reflection.MemberTypes.NestedType : global::System.Reflection.MemberTypes.TypeInfo;\n        public override global::System.Type BaseType => Symbol.BaseType == null ? null : new global::Feast.CodeAnalysis.CompileTime.Type(Symbol.BaseType);\n        public override global::System.Type ReflectedType => Symbol.ContainingType is null ? null : new global::Feast.CodeAnalysis.CompileTime.Type(Symbol.ContainingType);\n        public override global::System.Type DeclaringType => Symbol.ContainingType is null ? null : new global::Feast.CodeAnalysis.CompileTime.Type(Symbol.ContainingType);\n        public override global::System.Reflection.MethodBase DeclaringMethod => Symbol.ContainingSymbol is not IMethodSymbol methodSymbol ? null : new global::Feast.CodeAnalysis.CompileTime.MethodInfo(methodSymbol);\n        public override bool IsEnum => Symbol.TypeKind == global::Microsoft.CodeAnalysis.TypeKind.Enum;\n        public override global::System.Reflection.Assembly Assembly => new global::Feast.CodeAnalysis.CompileTime.Assembly(Symbol.ContainingAssembly);\n        public override global::System.Reflection.Module Module => new global::Feast.CodeAnalysis.CompileTime.Module(Symbol.ContainingModule);\n        public override global::System.Type UnderlyingSystemType => new global::Feast.CodeAnalysis.CompileTime.Type(Symbol);\n        public override bool IsGenericType => Symbol is INamedTypeSymbol { TypeArguments.Length: > 0 };\n        public override bool ContainsGenericParameters => Symbol is INamedTypeSymbol { TypeParameters.Length: > 0 };\n        public override bool IsGenericParameter => Symbol.TypeKind == global::Microsoft.CodeAnalysis.TypeKind.TypeParameter;\n        public override bool IsGenericTypeDefinition => Symbol is global::Microsoft.CodeAnalysis.INamedTypeSymbol namedType && namedType.TypeParameters.Length > namedType.TypeArguments.Length;\n        public override bool IsConstructedGenericType => Symbol is global::Microsoft.CodeAnalysis.INamedTypeSymbol namedType && namedType.TypeParameters.Length == namedType.TypeArguments.Length;\n        public override global::System.Type[] GenericTypeArguments => Symbol is INamedTypeSymbol { TypeArguments.Length: > 0 } typeSymbol ? typeSymbol.TypeArguments.Select(static x => (global::System.Type)new global::Feast.CodeAnalysis.CompileTime.Type(x)).ToArray() : global::System.Array.Empty<global::System.Type>();\n\n        public override global::System.Type[] GetGenericParameterConstraints()\n        {\n            if (Symbol is not ITypeParameterSymbol typeParameterSymbol)\n                return global::System.Array.Empty<global::System.Type>();\n            return typeParameterSymbol.ConstraintTypes.Select(static x => (global::System.Type)new global::Feast.CodeAnalysis.CompileTime.Type(x)).ToArray();\n        }\n\n        protected override global::System.Reflection.TypeAttributes GetAttributeFlagsImpl()\n        {\n            var ret = Symbol.TypeKind switch\n            {\n                global::Microsoft.CodeAnalysis.TypeKind.Interface => global::System.Reflection.TypeAttributes.Interface,\n                global::Microsoft.CodeAnalysis.TypeKind.Class => global::System.Reflection.TypeAttributes.Class,\n                _ => global::System.Reflection.TypeAttributes.NotPublic\n            };\n            if (Symbol.DeclaredAccessibility == global::Microsoft.CodeAnalysis.Accessibility.Public)\n            {\n                ret |= global::System.Reflection.TypeAttributes.Public;\n                if (Symbol.ContainingType != null)\n                {\n                    ret |= global::System.Reflection.TypeAttributes.NestedPublic;\n                }\n            }\n            else if (Symbol is { DeclaredAccessibility: Accessibility.Private, ContainingType: not null })\n            {\n                ret |= TypeAttributes.NestedPrivate;\n            }\n\n            if (Symbol.IsAbstract)\n            {\n                ret |= global::System.Reflection.TypeAttributes.Abstract;\n            }\n\n            if (Symbol.IsSealed)\n            {\n                ret |= global::System.Reflection.TypeAttributes.Sealed;\n            }\n\n            return ret;\n        }\n\n        protected override global::System.Reflection.ConstructorInfo GetConstructorImpl(global::System.Reflection.BindingFlags bindingAttr, global::System.Reflection.Binder binder, global::System.Reflection.CallingConventions callConvention, global::System.Type[] types, global::System.Reflection.ParameterModifier[] modifiers)\n        {\n            var ret = Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IMethodSymbol>().FirstOrDefault(x => Qualified(x, bindingAttr) && !types.Where((c, i) => new global::Feast.CodeAnalysis.CompileTime.Type(x.Parameters[i].Type).Equals(c)).Any());\n            return ret == null ? null : new global::Feast.CodeAnalysis.CompileTime.ConstructorInfo(ret);\n        }\n\n        public override global::System.Reflection.ConstructorInfo[] GetConstructors(global::System.Reflection.BindingFlags bindingAttr)\n        {\n            switch (Symbol.TypeKind)\n            {\n                case global::Microsoft.CodeAnalysis.TypeKind.Class:\n                case global::Microsoft.CodeAnalysis.TypeKind.Array:\n                case global::Microsoft.CodeAnalysis.TypeKind.Delegate:\n                case global::Microsoft.CodeAnalysis.TypeKind.Struct:\n                    return (Symbol as global::Microsoft.CodeAnalysis.INamedTypeSymbol)!.Constructors.Select(static x => (global::System.Reflection.ConstructorInfo)new global::Feast.CodeAnalysis.CompileTime.ConstructorInfo(x)).ToArray();\n            }\n\n            return global::System.Array.Empty<global::System.Reflection.ConstructorInfo>();\n        }\n\n        public override global::System.Reflection.EventInfo GetEvent(string name, global::System.Reflection.BindingFlags bindingAttr)\n        {\n            var ret = Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IEventSymbol>().FirstOrDefault(x => x.Name == name && Qualified(x, bindingAttr));\n            return ret == null ? null : new global::Feast.CodeAnalysis.CompileTime.EventInfo(ret);\n        }\n\n        public override global::System.Reflection.EventInfo[] GetEvents(global::System.Reflection.BindingFlags bindingAttr)\n        {\n            return Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IEventSymbol>().Where(x => Qualified(x, bindingAttr)).Select(static x => (global::System.Reflection.EventInfo)new global::Feast.CodeAnalysis.CompileTime.EventInfo(x)).ToArray();\n        }\n\n        public override global::System.Reflection.FieldInfo GetField(string name, global::System.Reflection.BindingFlags bindingAttr)\n        {\n            var ret = Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IFieldSymbol>().FirstOrDefault(x => Qualified(x, bindingAttr) && x.Name == name);\n            return ret == null ? null : new global::Feast.CodeAnalysis.CompileTime.FieldInfo(ret);\n        }\n\n        public override global::System.Reflection.FieldInfo[] GetFields(global::System.Reflection.BindingFlags bindingAttr) => Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IFieldSymbol>().Where(x => Qualified(x, bindingAttr)).Select(static x => (global::System.Reflection.FieldInfo)new global::Feast.CodeAnalysis.CompileTime.FieldInfo(x)).ToArray();\n        private static bool Qualified(global::Microsoft.CodeAnalysis.ISymbol symbol, global::System.Reflection.BindingFlags flags) => (!flags.HasFlag(global::System.Reflection.BindingFlags.Instance) || !symbol.IsStatic) && (!flags.HasFlag(global::System.Reflection.BindingFlags.Static) || symbol.IsStatic) && (!flags.HasFlag(global::System.Reflection.BindingFlags.Public) || symbol.DeclaredAccessibility == global::Microsoft.CodeAnalysis.Accessibility.Public) && (!flags.HasFlag(global::System.Reflection.BindingFlags.NonPublic) || symbol.DeclaredAccessibility != global::Microsoft.CodeAnalysis.Accessibility.Public);\n        private static bool Qualified(global::Microsoft.CodeAnalysis.ISymbol symbol, global::System.Reflection.MemberTypes memberTypes) => memberTypes is MemberTypes.All || symbol switch\n        {\n            global::Microsoft.CodeAnalysis.IFieldSymbol => memberTypes.HasFlag(global::System.Reflection.MemberTypes.Field),\n            global::Microsoft.CodeAnalysis.IMethodSymbol method => method.MethodKind == global::Microsoft.CodeAnalysis.MethodKind.Constructor ? memberTypes.HasFlag(global::System.Reflection.MemberTypes.Constructor) : memberTypes.HasFlag(global::System.Reflection.MemberTypes.Method),\n            global::Microsoft.CodeAnalysis.IPropertySymbol => memberTypes.HasFlag(global::System.Reflection.MemberTypes.Property),\n            global::Microsoft.CodeAnalysis.IEventSymbol => memberTypes.HasFlag(global::System.Reflection.MemberTypes.Event),\n            global::Microsoft.CodeAnalysis.INamedTypeSymbol => memberTypes.HasFlag(global::System.Reflection.MemberTypes.NestedType),\n            _ => false\n        };\n        public override global::System.Reflection.MemberInfo[] GetMembers(global::System.Reflection.BindingFlags bindingAttr) => Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.ISymbol>().Where(x => Qualified(x, bindingAttr)).Select(static x => (global::System.Reflection.MemberInfo)new global::Feast.CodeAnalysis.CompileTime.MemberInfo(x)).ToArray();\n        protected override global::System.Reflection.MethodInfo GetMethodImpl(string name, global::System.Reflection.BindingFlags bindingAttr, global::System.Reflection.Binder binder, global::System.Reflection.CallingConventions callConvention, global::System.Type[] types, global::System.Reflection.ParameterModifier[] modifiers)\n        {\n            var ret = Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IMethodSymbol>().FirstOrDefault(x => x.Name == name && Qualified(x, bindingAttr) && x.Parameters.Length == types.Length && !x.Parameters.Where((p, i) => types[i] != new global::Feast.CodeAnalysis.CompileTime.Type(p.Type)).Any());\n            return ret == null ? null : new global::Feast.CodeAnalysis.CompileTime.MethodInfo(ret);\n        }\n\n        public override global::System.Reflection.MethodInfo[] GetMethods(global::System.Reflection.BindingFlags bindingAttr) => Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IMethodSymbol>().Where(x => Qualified(x, bindingAttr)).Select(static x => (global::System.Reflection.MethodInfo)new global::Feast.CodeAnalysis.CompileTime.MethodInfo(x)).ToArray();\n        public override global::System.Reflection.PropertyInfo[] GetProperties(global::System.Reflection.BindingFlags bindingAttr) => Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IPropertySymbol>().Where(x => Qualified(x, bindingAttr)).Select(static x => (global::System.Reflection.PropertyInfo)new global::Feast.CodeAnalysis.CompileTime.PropertyInfo(x)).ToArray();\n        public override global::System.Reflection.EventInfo[] GetEvents() => Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IEventSymbol>().Select(static x => (global::System.Reflection.EventInfo)new global::Feast.CodeAnalysis.CompileTime.EventInfo(x)).ToArray();\n        public override bool IsSerializable => Symbol.GetAttributes().Any(static x => x.AttributeClass?.ToType().Equals(typeof(global::System.SerializableAttribute))is true);\n\n        public override global::System.Reflection.MemberInfo[] GetMember(string name, global::System.Reflection.BindingFlags bindingAttr) => Symbol.GetMembers().Where(x => Qualified(x, bindingAttr)).Select(static x => (global::System.Reflection.MemberInfo)new global::Feast.CodeAnalysis.CompileTime.MemberInfo(x)).ToArray();\n        public override global::System.Reflection.MemberInfo[] GetMember(string name, global::System.Reflection.MemberTypes type, global::System.Reflection.BindingFlags bindingAttr) => Symbol.GetMembers().Where(x => x.Name == name && Qualified(x, bindingAttr) && Qualified(x, type)).Select(static x => (global::System.Reflection.MemberInfo)new global::Feast.CodeAnalysis.CompileTime.MemberInfo(x)).ToArray();\n        public override bool IsEnumDefined(object value) => IsEnum && Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IFieldSymbol>().Any(x => x.ConstantValue == value);\n        public override object InvokeMember(string name, global::System.Reflection.BindingFlags invokeAttr, global::System.Reflection.Binder binder, object target, object[] args, global::System.Reflection.ParameterModifier[] modifiers, global::System.Globalization.CultureInfo culture, string[] namedParameters) => throw new global::System.NotSupportedException();\n        protected override bool IsArrayImpl() => Symbol.SpecialType == global::Microsoft.CodeAnalysis.SpecialType.System_Array;\n        protected override bool IsByRefImpl() => Symbol.IsReferenceType || Symbol.IsRefLikeType;\n        protected override bool IsCOMObjectImpl() => Symbol is INamedTypeSymbol { IsComImport: true };\n        protected override bool IsPointerImpl() => Symbol.Kind == global::Microsoft.CodeAnalysis.SymbolKind.PointerType;\n        protected override bool IsPrimitiveImpl() => Symbol.SpecialType is >= SpecialType.System_Boolean and <= SpecialType.System_Double or global::Microsoft.CodeAnalysis.SpecialType.System_Object or global::Microsoft.CodeAnalysis.SpecialType.System_String;\n        public override global::System.Array GetEnumValues() => IsEnum ? Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IFieldSymbol>().Select(x => x.ConstantValue).ToArray() : throw new global::System.InvalidOperationException();\n        public override global::System.Reflection.GenericParameterAttributes GenericParameterAttributes => throw new global::System.InvalidOperationException();\n\n        protected override global::System.Reflection.PropertyInfo GetPropertyImpl(string name, global::System.Reflection.BindingFlags bindingAttr, global::System.Reflection.Binder binder, global::System.Type returnType, global::System.Type[] types, global::System.Reflection.ParameterModifier[] modifiers)\n        {\n            var ret = Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.IPropertySymbol>().FirstOrDefault(x => Qualified(x, bindingAttr) && new global::Feast.CodeAnalysis.CompileTime.Type(x.Type).Equals(returnType));\n            return ret == null ? null : new global::Feast.CodeAnalysis.CompileTime.PropertyInfo(ret);\n        }\n\n        protected override bool HasElementTypeImpl() => Symbol.TypeKind == global::Microsoft.CodeAnalysis.TypeKind.Array || Symbol.TypeKind == global::Microsoft.CodeAnalysis.TypeKind.Pointer || Symbol.IsReferenceType;\n        public override global::System.Type GetElementType() => Symbol switch\n        {\n            { TypeKind: TypeKind.Array } => new global::Feast.CodeAnalysis.CompileTime.Type(Symbol.Interfaces.First(x => x.TypeArguments.Length == 1).TypeArguments[0]),\n            { TypeKind: TypeKind.Pointer } and global::Microsoft.CodeAnalysis.IPointerTypeSymbol pointer => new global::Feast.CodeAnalysis.CompileTime.Type(pointer.PointedAtType),\n            { IsReferenceType: true } => this,\n            _ => null\n        };\n        protected override bool IsValueTypeImpl() => Symbol.TypeKind is global::Microsoft.CodeAnalysis.TypeKind.Struct or global::Microsoft.CodeAnalysis.TypeKind.Structure;\n        public override global::System.Type GetNestedType(string name, global::System.Reflection.BindingFlags bindingAttr)\n        {\n            var ret = Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.INamedTypeSymbol>().FirstOrDefault(x => x.Name == name && Qualified(x, bindingAttr));\n            return ret == null ? null : new global::Feast.CodeAnalysis.CompileTime.Type(ret);\n        }\n\n        public override global::System.Type[] GetNestedTypes(global::System.Reflection.BindingFlags bindingAttr) => Symbol.GetMembers().OfType<global::Microsoft.CodeAnalysis.INamedTypeSymbol>().Select(x => (global::System.Type)new global::Feast.CodeAnalysis.CompileTime.Type(x)).ToArray();\n        public override global::System.Type GetInterface(string name, bool ignoreCase)\n        {\n            var ret = Symbol.AllInterfaces.FirstOrDefault(x => ignoreCase ? string.Equals(name, x.Name, global::System.StringComparison.OrdinalIgnoreCase) : name == x.Name);\n            return ret == null ? null : new global::Feast.CodeAnalysis.CompileTime.Type(ret);\n        }\n\n        public override global::System.Type[] GetInterfaces() => Symbol.AllInterfaces.Select(x => (global::System.Type)new global::Feast.CodeAnalysis.CompileTime.Type(x)).ToArray();\n        public override bool Equals(global::System.Type o)\n        {\n            switch (o)\n            {\n                case null:\n                    return false;\n                case Type ct:\n                    return global::Microsoft.CodeAnalysis.SymbolEqualityComparer.Default.Equals(ct.Symbol, Symbol);\n            }\n\n            if (o.FullName != FullName)\n                return false;\n            return !IsGenericParameter || DeclaringType?.Equals(o.DeclaringType)is true || DeclaringMethod?.Equals(o.DeclaringMethod)is true;\n        }\n\n        public override bool IsAssignableFrom(global::System.Type c)\n        {\n            if (c is null)\n                return false;\n            if (Equals(c))\n                return true;\n            switch (this)\n            {\n                case { IsClass: true }when c.IsClass:\n                    return c.IsSubclassOf(this);\n                case { IsInterface: true }when c.IsInterface || c.IsClass:\n                    return c.GetInterfaces().Any(Equals);\n                case { IsGenericParameter: true }:\n                    return true;\n            }\n\n            return false;\n        }\n\n        public override string ToString() => $"{Namespace}.{Name}{(!IsGenericType ? string.Empty : \'[\' + string.Join(",", GenericTypeArguments.Select(x => x.FullName)) + \']\')}";\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.CompileTimeGenerator\\Feast.CodeAnalysis.TypeEqualityComparer.g.cs",label:"Feast.CodeAnalysis.TypeEqualityComparer.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\n\nnamespace Feast.CodeAnalysis\n{\n    public partial class TypeEqualityComparer : global::System.Collections.Generic.IEqualityComparer<global::System.Type>\n    {\n        public bool Equals(global::System.Type x, global::System.Type y) => x is global::Feast.CodeAnalysis.CompileTime.Type ? x.Equals(y) : y is global::Feast.CodeAnalysis.CompileTime.Type ? y.Equals(x) : x.Equals(y);\n        public int GetHashCode(global::System.Type obj) => obj is global::Feast.CodeAnalysis.CompileTime.Type type ? type.GetHashCode() : obj.GetHashCode();\n        public static global::Feast.CodeAnalysis.TypeEqualityComparer Default { get; } = new();\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.ExtendedClassGenerator\\Feast.CodeAnalysis.GeneratorAttributeSyntaxContext.g.cs",label:"Feast.CodeAnalysis.GeneratorAttributeSyntaxContext.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'#if !ROSLYN_4_3_1_OR_GREATER\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\nusing System;\nusing System.Collections.Immutable;\n\nnamespace Microsoft.CodeAnalysis.Internal\n{\n    internal readonly struct GeneratorAttributeSyntaxContext\n    {\n        /// <summary>\n        /// Creates a new <see cref="GeneratorAttributeSyntaxContext"/> instance with the specified parameters.\n        /// </summary>\n        /// <param name="targetNode">The syntax node the attribute is attached to.</param>\n        /// <param name="targetSymbol">The symbol that the attribute is attached to.</param>\n        /// <param name="semanticModel">Semantic model for the file that <see cref="TargetNode"/> is contained within.</param>\n        /// <param name="attributes">The collection of matching attributes.</param>\n        internal GeneratorAttributeSyntaxContext(global::Microsoft.CodeAnalysis.SyntaxNode targetNode, global::Microsoft.CodeAnalysis.ISymbol targetSymbol, global::Microsoft.CodeAnalysis.SemanticModel semanticModel, global::System.Collections.Immutable.ImmutableArray<global::Microsoft.CodeAnalysis.AttributeData> attributes)\n        {\n            TargetNode = targetNode;\n            TargetSymbol = targetSymbol;\n            SemanticModel = semanticModel;\n            Attributes = attributes;\n        }\n\n        /// <summary>\n        /// The syntax node the attribute is attached to. For example, with <c>[CLSCompliant] class C { }</c> this would the class declaration node.\n        /// </summary>\n        public global::Microsoft.CodeAnalysis.SyntaxNode TargetNode { get; }\n        /// <summary>\n        /// The symbol that the attribute is attached to. For example, with <c>[CLSCompliant] class C { }</c> this would be the <see cref="INamedTypeSymbol"/> for <c>"C"</c>.\n        /// </summary>\n        public global::Microsoft.CodeAnalysis.ISymbol TargetSymbol { get; }\n        /// <summary>\n        /// Semantic model for the file that <see cref="TargetNode"/> is contained within.\n        /// </summary>\n        public global::Microsoft.CodeAnalysis.SemanticModel SemanticModel { get; }\n        /// <summary>\n        /// <see cref="AttributeData"/>s for any matching attributes on <see cref="TargetSymbol"/>. Always non-empty. All\n        /// these attributes will have an <see cref="AttributeData.AttributeClass"/> whose fully qualified name metadata\n        /// name matches the name requested in <see cref="SyntaxValueProviderExtensions.ForAttributeWithMetadataName"/>.\n        /// <para>\n        /// To get the entire list of attributes, use <see cref="ISymbol.GetAttributes"/> on <see cref="TargetSymbol"/>.\n        /// </para>\n        /// </summary>\n        public global::System.Collections.Immutable.ImmutableArray<global::Microsoft.CodeAnalysis.AttributeData> Attributes { get; }\n    }\n}\n#endif\n\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.ExtendedClassGenerator\\Feast.CodeAnalysis.Global.g.cs",label:"Feast.CodeAnalysis.Global.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"#if !ROSLYN_4_3_1_OR_GREATER\nusing Microsoft.CodeAnalysis.Internal;\n#endif\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.ExtendedClassGenerator\\Feast.CodeAnalysis.ImmutableArrayBuilder{T}.g.cs",label:"Feast.CodeAnalysis.ImmutableArrayBuilder{T}.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n// This file is ported and adapted from ComputeSharp (Sergio0694/ComputeSharp),\n// more info in ThirdPartyNotices.txt in the root of the project.\nusing System;\nusing System.Buffers;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Runtime.CompilerServices;\n\nnamespace Microsoft.CodeAnalysis\n{\n    internal ref struct ImmutableArrayBuilder<T>\n    {\n        /// <summary>\n        /// The rented <see cref="Writer"/> instance to use.\n        /// </summary>\n        private global::Microsoft.CodeAnalysis.ImmutableArrayBuilder<T>.Writer writer;\n        /// <summary>\n        /// Creates a <see cref="ImmutableArrayBuilder{T}"/> value with a pooled underlying data writer.\n        /// </summary>\n        /// <returns>A <see cref="ImmutableArrayBuilder{T}"/> instance to write data to.</returns>\n        public static global::Microsoft.CodeAnalysis.ImmutableArrayBuilder<T> Rent()\n        {\n            return new(new global::Microsoft.CodeAnalysis.ImmutableArrayBuilder<T>.Writer());\n        }\n\n        /// <summary>\n        /// Creates a new <see cref="ImmutableArrayBuilder{T}"/> object with the specified parameters.\n        /// </summary>\n        /// <param name="writer">The target data writer to use.</param>\n        private ImmutableArrayBuilder(global::Microsoft.CodeAnalysis.ImmutableArrayBuilder<T>.Writer writer)\n        {\n            this.writer = writer;\n        }\n\n        /// <inheritdoc cref="ImmutableArray{T}.Builder.Count"/>\n        public readonly int Count {[MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get => this.writer!.Count; }\n\n        /// <summary>\n        /// Gets the data written to the underlying buffer so far, as a <see cref="ReadOnlySpan{T}"/>.\n        /// </summary>\n        [UnscopedRef]\n        public readonly global::System.ReadOnlySpan<T> WrittenSpan {[MethodImpl(MethodImplOptions.AggressiveInlining)]\n            get => this.writer!.WrittenSpan; }\n\n        /// <inheritdoc cref="ImmutableArray{T}.Builder.Add(T)"/>\n        public readonly void Add(T item)\n        {\n            this.writer!.Add(item);\n        }\n\n        /// <summary>\n        /// Adds the specified items to the end of the array.\n        /// </summary>\n        /// <param name="items">The items to add at the end of the array.</param>\n        public readonly void AddRange(scoped global::System.ReadOnlySpan<T> items)\n        {\n            this.writer!.AddRange(items);\n        }\n\n        /// <inheritdoc cref="ImmutableArray{T}.Builder.ToImmutable"/>\n        public readonly global::System.Collections.Immutable.ImmutableArray<T> ToImmutable()\n        {\n            T[] array = this.writer!.WrittenSpan.ToArray();\n            return global::System.Runtime.CompilerServices.Unsafe.As<T[], global::System.Collections.Immutable.ImmutableArray<T>>(ref array);\n        }\n\n        /// <inheritdoc cref="ImmutableArray{T}.Builder.ToArray"/>\n        public readonly T[] ToArray()\n        {\n            return this.writer!.WrittenSpan.ToArray();\n        }\n\n        /// <summary>\n        /// Gets an <see cref="IEnumerable{T}"/> instance for the current builder.\n        /// </summary>\n        /// <returns>An <see cref="IEnumerable{T}"/> instance for the current builder.</returns>\n        /// <remarks>\n        /// The builder should not be mutated while an enumerator is in use.\n        /// </remarks>\n        public readonly global::System.Collections.Generic.IEnumerable<T> AsEnumerable()\n        {\n            return this.writer!;\n        }\n\n        /// <inheritdoc/>\n        public readonly override string ToString()\n        {\n            return this.writer!.WrittenSpan.ToString();\n        }\n\n        /// <inheritdoc cref="IDisposable.Dispose"/>\n        public void Dispose()\n        {\n            global::Microsoft.CodeAnalysis.ImmutableArrayBuilder<T>.Writer writer = this.writer;\n            this.writer = null;\n            writer?.Dispose();\n        }\n\n        /// <summary>\n        /// A class handling the actual buffer writing.\n        /// </summary>\n        private sealed class Writer : global::System.Collections.Generic.ICollection<T>, global::System.IDisposable\n        {\n            /// <summary>\n            /// The underlying <typeparamref name="T"/> array.\n            /// </summary>\n            private T[] array;\n            /// <summary>\n            /// The starting offset within <see cref="array"/>.\n            /// </summary>\n            private int index;\n            /// <summary>\n            /// Creates a new <see cref="Writer"/> instance with the specified parameters.\n            /// </summary>\n            public Writer()\n            {\n                this.array = global::System.Buffers.ArrayPool<T>.Shared.Rent(typeof(T) == typeof(char) ? 1024 : 8);\n                this.index = 0;\n            }\n\n            /// <inheritdoc cref="ImmutableArrayBuilder{T}.Count"/>\n            public int Count {[MethodImpl(MethodImplOptions.AggressiveInlining)]\n                get => this.index; }\n            /// <inheritdoc cref="ImmutableArrayBuilder{T}.WrittenSpan"/>\n            public global::System.ReadOnlySpan<T> WrittenSpan {[MethodImpl(MethodImplOptions.AggressiveInlining)]\n                get => new(this.array!, 0, this.index); }\n\n            bool ICollection<T>.IsReadOnly => true;\n\n            /// <inheritdoc cref="ImmutableArrayBuilder{T}.Add"/>\n            public void Add(T value)\n            {\n                EnsureCapacity(1);\n                this.array![this.index++] = value;\n            }\n\n            /// <inheritdoc cref="ImmutableArrayBuilder{T}.AddRange"/>\n            public void AddRange(global::System.ReadOnlySpan<T> items)\n            {\n                EnsureCapacity(items.Length);\n                items.CopyTo(this.array.AsSpan(this.index)!);\n                this.index += items.Length;\n            }\n\n            /// <inheritdoc/>\n            public void Dispose()\n            {\n                T[] array = this.array;\n                this.array = null;\n                if (array is not null)\n                {\n                    global::System.Buffers.ArrayPool<T>.Shared.Return(array, clearArray: typeof(T) != typeof(char));\n                }\n            }\n\n            void ICollection<T>.Clear()\n            {\n                throw new global::System.NotSupportedException();\n            }\n\n            bool ICollection<T>.Contains(T item)\n            {\n                throw new global::System.NotSupportedException();\n            }\n\n            void ICollection<T>.CopyTo(T[] array, int arrayIndex)\n            {\n                global::System.Array.Copy(this.array!, 0, array, arrayIndex, this.index);\n            }\n\n            global::System.Collections.Generic.IEnumerator<T> IEnumerable<T>.GetEnumerator()\n            {\n                T[] array = this.array!;\n                int length = this.index;\n                for (int i = 0; i < length; i++)\n                {\n                    yield return array[i]!;\n                }\n            }\n\n            global::System.Collections.IEnumerator IEnumerable.GetEnumerator()\n            {\n                return ((global::System.Collections.Generic.IEnumerable<T>)this).GetEnumerator();\n            }\n\n            bool ICollection<T>.Remove(T item)\n            {\n                throw new global::System.NotSupportedException();\n            }\n\n            /// <summary>\n            /// Ensures that <see cref="array"/> has enough free space to contain a given number of new items.\n            /// </summary>\n            /// <param name="requestedSize">The minimum number of items to ensure space for in <see cref="array"/>.</param>\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            private void EnsureCapacity(int requestedSize)\n            {\n                if (requestedSize > this.array!.Length - this.index)\n                {\n                    ResizeBuffer(requestedSize);\n                }\n            }\n\n            /// <summary>\n            /// Resizes <see cref="array"/> to ensure it can fit the specified number of new items.\n            /// </summary>\n            /// <param name="sizeHint">The minimum number of items to ensure space for in <see cref="array"/>.</param>\n            [MethodImpl(MethodImplOptions.NoInlining)]\n            private void ResizeBuffer(int sizeHint)\n            {\n                int minimumSize = this.index + sizeHint;\n                T[] oldArray = this.array!;\n                T[] newArray = global::System.Buffers.ArrayPool<T>.Shared.Rent(minimumSize);\n                global::System.Array.Copy(oldArray, newArray, this.index);\n                this.array = newArray;\n                global::System.Buffers.ArrayPool<T>.Shared.Return(oldArray, clearArray: typeof(T) != typeof(char));\n            }\n        }\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.ExtendedClassGenerator\\Feast.CodeAnalysis.SyntaxValueProviderExtensions.g.cs",label:"Feast.CodeAnalysis.SyntaxValueProviderExtensions.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'#if !ROSLYN_4_3_1_OR_GREATER\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\nusing System.Threading;\nusing System;\nusing System.Collections.Immutable;\n\nnamespace Microsoft.CodeAnalysis\n{\n    internal static class SyntaxValueProviderExtensions\n    {\n        /// <summary>\n        /// Creates an <see cref="IncrementalValuesProvider{T}"/> that can provide a transform over all <see\n        /// cref="SyntaxNode"/>s if that node has an attribute on it that binds to a <see cref="INamedTypeSymbol"/> with the\n        /// same fully-qualified metadata as the provided <paramref name="fullyQualifiedMetadataName"/>. <paramref\n        /// name="fullyQualifiedMetadataName"/> should be the fully-qualified, metadata name of the attribute, including the\n        /// <c>Attribute</c> suffix.  For example <c>"System.CLSCompliantAttribute</c> for <see cref="CLSCompliantAttribute"/>.\n        /// </summary>\n        /// <param name="syntaxValueProvider">The source <see cref="SyntaxValueProvider"/> instance to use.</param>\n        /// <param name="fullyQualifiedMetadataName">The fully qualified metadata name of the attribute to look for.</param>\n        /// <param name="predicate">A function that determines if the given <see cref="SyntaxNode"/> attribute target (<see\n        /// cref="GeneratorAttributeSyntaxContext.TargetNode"/>) should be transformed.  Nodes that do not pass this\n        /// predicate will not have their attributes looked at at all.</param>\n        /// <param name="transform">A function that performs the transform. This will only be passed nodes that return <see\n        /// langword="true"/> for <paramref name="predicate"/> and which have a matching <see cref="AttributeData"/> whose\n        /// <see cref="AttributeData.AttributeClass"/> has the same fully qualified, metadata name as <paramref\n        /// name="fullyQualifiedMetadataName"/>.</param>\n        public static global::Microsoft.CodeAnalysis.IncrementalValuesProvider<T> ForAttributeWithMetadataName<T>(this global::Microsoft.CodeAnalysis.SyntaxValueProvider syntaxValueProvider, string fullyQualifiedMetadataName, global::System.Func<global::Microsoft.CodeAnalysis.SyntaxNode, global::System.Threading.CancellationToken, bool> predicate, global::System.Func<global::Microsoft.CodeAnalysis.Internal.GeneratorAttributeSyntaxContext, global::System.Threading.CancellationToken, T> transform)\n        {\n            return syntaxValueProvider.CreateSyntaxProvider(predicate, (context, token) =>\n            {\n                ISymbol? symbol = context.SemanticModel.GetDeclaredSymbol(context.Node, token);\n                // If the syntax node doesn\'t have a declared symbol, just skip this node. This would be\n                // the case for eg. lambda attributes, but those are not supported by the MVVM Toolkit.\n                if (symbol is null)\n                {\n                    return null;\n                }\n\n                // Skip symbols without the target attribute\n                if (!symbol.TryGetAttributeWithFullyQualifiedMetadataName(fullyQualifiedMetadataName, out AttributeData? attributeData))\n                {\n                    return null;\n                }\n\n                // Edge case: if the symbol is a partial method, skip the implementation part and only process the partial method\n                // definition. This is needed because attributes will be reported as available on both the definition and the\n                // implementation part. To avoid generating duplicate files, we only give priority to the definition part.\n                // On Roslyn 4.3+, ForAttributeWithMetadataName will already only return the symbol the attribute was located on.\n                if (symbol is IMethodSymbol { IsPartialDefinition: false, PartialDefinitionPart: not null })\n                {\n                    return null;\n                }\n\n                // Create the GeneratorAttributeSyntaxContext value to pass to the input transform. The attributes array\n                // will only ever have a single value, but that\'s fine with the attributes the various generators look for.\n                global::Microsoft.CodeAnalysis.Internal.GeneratorAttributeSyntaxContext syntaxContext = new(targetNode: context.Node, targetSymbol: symbol, semanticModel: context.SemanticModel, attributes: ImmutableArray.Create(attributeData));\n                return new Option<T>(transform(syntaxContext, token));\n            }).Where(static item => item is not null).Select(static (item, _) => item!.Value)!;\n        }\n\n        /// <summary>\n        /// A simple record to wrap a value that might be missing.\n        /// </summary>\n        /// <typeparam name="T">The type of values to wrap</typeparam>\n        /// <param name="Value">The wrapped value, if it exists.</param>\n        private sealed record Option<T>(T? Value);\n    }\n}\n#endif\n\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.ISymbolExtensionsGenerator\\Feast.CodeAnalysis.ISymbolExtensions.g.cs",label:"Feast.CodeAnalysis.ISymbolExtensions.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using System;\nusing Feast.CodeAnalysis;\n\nnamespace Microsoft.CodeAnalysis\n{\n    internal static class ISymbolExtensions\n    {\n        public static bool Is(this global::Microsoft.CodeAnalysis.ISymbol symbol, global::Microsoft.CodeAnalysis.ISymbol other) => global::Microsoft.CodeAnalysis.SymbolEqualityComparer.Default.Equals(symbol, other);\n        public static string GlobalName(this global::Microsoft.CodeAnalysis.ISymbol symbol) => symbol.ToDisplayString(global::Microsoft.CodeAnalysis.SymbolDisplayFormat.FullyQualifiedFormat);\n        public static string GetFullyQualifiedName(this global::Microsoft.CodeAnalysis.ISymbol symbol) => symbol.ToDisplayString(global::Microsoft.CodeAnalysis.SymbolDisplayFormat.FullyQualifiedFormat);\n        public static bool IsInitOnly(this global::Microsoft.CodeAnalysis.IPropertySymbol symbol) => !symbol.IsReadOnly && symbol.SetMethod!.IsInitOnly;\n        public static global::System.Collections.Generic.IEnumerable<global::Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetSyntaxKind(this global::Microsoft.CodeAnalysis.Accessibility accessibility)\n        {\n            switch (accessibility)\n            {\n                case global::Microsoft.CodeAnalysis.Accessibility.Public:\n                    yield return global::Microsoft.CodeAnalysis.CSharp.SyntaxKind.PublicKeyword;\n                    yield break;\n                case global::Microsoft.CodeAnalysis.Accessibility.Protected:\n                    yield return global::Microsoft.CodeAnalysis.CSharp.SyntaxKind.ProtectedKeyword;\n                    yield break;\n                case global::Microsoft.CodeAnalysis.Accessibility.Internal:\n                    yield return global::Microsoft.CodeAnalysis.CSharp.SyntaxKind.InternalKeyword;\n                    yield break;\n                case global::Microsoft.CodeAnalysis.Accessibility.Private:\n                    yield return global::Microsoft.CodeAnalysis.CSharp.SyntaxKind.PrivateKeyword;\n                    yield break;\n                case global::Microsoft.CodeAnalysis.Accessibility.ProtectedOrInternal:\n                    yield return global::Microsoft.CodeAnalysis.CSharp.SyntaxKind.ProtectedKeyword;\n                    yield return global::Microsoft.CodeAnalysis.CSharp.SyntaxKind.InternalKeyword;\n                    yield break;\n                default:\n                    throw new global::System.ArgumentOutOfRangeException(nameof(accessibility), accessibility, null);\n            }\n        }\n\n#if !ROSLYN_4_3_1_OR_GREATER\n        /// <summary>\n        /// Tries to get an attribute with the specified fully qualified metadata name.\n        /// </summary>\n        /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>\n        /// <param name="name">The attribute name to look for.</param>\n        /// <param name="attributeData">The resulting attribute, if it was found.</param>\n        /// <returns>Whether or not <paramref name="symbol"/> has an attribute with the specified name.</returns>\n        public static bool TryGetAttributeWithFullyQualifiedMetadataName(this global::Microsoft.CodeAnalysis.ISymbol symbol, string name, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Microsoft.CodeAnalysis.AttributeData attributeData)\n        {\n            foreach (var attribute in symbol.GetAttributes())\n            {\n                if (attribute.AttributeClass?.HasFullyQualifiedMetadataName(name) == true)\n                {\n                    attributeData = attribute;\n                    return true;\n                }\n            }\n\n            attributeData = null;\n            return false;\n        }\n#endif\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.ITypeSymbolExtensionsGenerator\\Feast.CodeAnalysis.ITypeSymbolExtensions.g.cs",label:"Feast.CodeAnalysis.ITypeSymbolExtensions.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using System;\nusing System.Linq;\n\nnamespace Microsoft.CodeAnalysis\n{\n    internal static class ITypeSymbolExtensions\n    {\n        /// <summary>\n        /// Checks whether or not a given type symbol has a specified fully qualified metadata name.\n        /// </summary>\n        /// <param name="symbol">The input <see cref="ITypeSymbol"/> instance to check.</param>\n        /// <param name="name">The full name to check.</param>\n        /// <returns>Whether <paramref name="symbol"/> has a full name equals to <paramref name="name"/>.</returns>\n        public static bool HasFullyQualifiedMetadataName(this global::Microsoft.CodeAnalysis.ITypeSymbol symbol, string name)\n        {\n            using global::Microsoft.CodeAnalysis.ImmutableArrayBuilder<char> builder = global::Microsoft.CodeAnalysis.ImmutableArrayBuilder<char>.Rent();\n            symbol.AppendFullyQualifiedMetadataName(in builder);\n            return builder.WrittenSpan.SequenceEqual(name.AsSpan());\n        }\n\n        /// <summary>\n        /// Appends the fully qualified metadata name for a given symbol to a target builder.\n        /// </summary>\n        /// <param name="symbol">The input <see cref="ITypeSymbol"/> instance.</param>\n        /// <param name="builder">The target <see cref="ImmutableArrayBuilder{T}"/> instance.</param>\n        private static void AppendFullyQualifiedMetadataName(this global::Microsoft.CodeAnalysis.ITypeSymbol symbol, in global::Microsoft.CodeAnalysis.ImmutableArrayBuilder<char> builder)\n        {\n            static void BuildFrom(global::Microsoft.CodeAnalysis.ISymbol? symbol, in global::Microsoft.CodeAnalysis.ImmutableArrayBuilder<global::System.Char> builder)\n            {\n                switch (symbol)\n                {\n                    // Namespaces that are nested also append a leading \'.\'\n                    case global::Microsoft.CodeAnalysis.INamespaceSymbol { ContainingNamespace.IsGlobalNamespace: false }:\n                        BuildFrom(symbol.ContainingNamespace, in builder);\n                        builder.Add(\'.\');\n                        builder.AddRange(symbol.MetadataName.AsSpan());\n                        break;\n                    // Other namespaces (ie. the one right before global) skip the leading \'.\'\n                    case global::Microsoft.CodeAnalysis.INamespaceSymbol { IsGlobalNamespace: false }:\n                        builder.AddRange(symbol.MetadataName.AsSpan());\n                        break;\n                    // Types with no namespace just have their metadata name directly written\n                    case global::Microsoft.CodeAnalysis.ITypeSymbol { ContainingSymbol: global::Microsoft.CodeAnalysis.INamespaceSymbol { IsGlobalNamespace: true } }:\n                        builder.AddRange(symbol.MetadataName.AsSpan());\n                        break;\n                    // Types with a containing non-global namespace also append a leading \'.\'\n                    case global::Microsoft.CodeAnalysis.ITypeSymbol { ContainingSymbol: global::Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol }:\n                        BuildFrom(namespaceSymbol, in builder);\n                        builder.Add(\'.\');\n                        builder.AddRange(symbol.MetadataName.AsSpan());\n                        break;\n                    // Nested types append a leading \'+\'\n                    case global::Microsoft.CodeAnalysis.ITypeSymbol { ContainingSymbol: global::Microsoft.CodeAnalysis.ITypeSymbol typeSymbol }:\n                        BuildFrom(typeSymbol, in builder);\n                        builder.Add(\'+\');\n                        builder.AddRange(symbol.MetadataName.AsSpan());\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            BuildFrom(symbol, in builder);\n        }\n\n        public static T AsNoneErrorType<T>(this T symbol)\n            where T : global::Microsoft.CodeAnalysis.ITypeSymbol\n        {\n            return symbol is global::Microsoft.CodeAnalysis.IErrorTypeSymbol errorTypeSymbol ? (T)errorTypeSymbol.CandidateSymbols.FirstOrDefault()! : (T)symbol;\n        }\n\n        public static global::Microsoft.CodeAnalysis.INamespaceOrTypeSymbol AsNoneErrorType(this global::Microsoft.CodeAnalysis.INamespaceOrTypeSymbol symbol)\n        {\n            return symbol is global::Microsoft.CodeAnalysis.IErrorTypeSymbol errorTypeSymbol ? (global::Microsoft.CodeAnalysis.INamespaceOrTypeSymbol)errorTypeSymbol.CandidateSymbols.FirstOrDefault()! : symbol;\n        }\n\n        public static bool IsJsonBool(this global::Microsoft.CodeAnalysis.ITypeSymbol symbol) => symbol.SpecialType == global::Microsoft.CodeAnalysis.SpecialType.System_Boolean;\n        public static bool IsJsonNumber(this global::Microsoft.CodeAnalysis.ITypeSymbol symbol) => symbol is { SpecialType: >= global::Microsoft.CodeAnalysis.SpecialType.System_SByte and <= global::Microsoft.CodeAnalysis.SpecialType.System_Single };\n        public static bool IsJsonString(this global::Microsoft.CodeAnalysis.ITypeSymbol symbol) => symbol.SpecialType is global::Microsoft.CodeAnalysis.SpecialType.System_String or global::Microsoft.CodeAnalysis.SpecialType.System_Char;\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.LiteralGenerator.LiteralGenerator\\LiteralAttribute.g.cs",label:"LiteralAttribute.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"#nullable enable\nusing System;\nnamespace System\n{\n    [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct | global::System.AttributeTargets.Interface | global::System.AttributeTargets.Enum | global::System.AttributeTargets.Delegate)]\n    public class LiteralAttribute : Attribute\n    {\n        public string? FieldName { get; set; }\n    \n        public LiteralAttribute(string belongToFullyQualifiedClassName){ }\n    }\n}\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.LiteralGenerator.LiteralGenerator\\Namespace_Andrei.Class_Ignat.g.cs",label:"Namespace_Andrei.Class_Ignat.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated/> By Feast.CodeAnalysis\n#pragma warning disable\n#nullable enable\nnamespace Namespace_Andrei\n{\n    partial class Class_Ignat\n    {\n        internal static string Text = """\nnamespace DemoLit\n{\n    internal class Person\n    {\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n    }\n}\n""".Replace("\\"^\\"\\"", "\\"\\"\\"");\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.SyntaxExtensionsGenerator\\Feast.CodeAnalysis.SyntaxExtensions.g.cs",label:"Feast.CodeAnalysis.SyntaxExtensions.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using System;\nusing System.Linq;\nusing Feast.CodeAnalysis;\n\nnamespace Microsoft.CodeAnalysis\n{\n    internal static class SyntaxExtensions\n    {\n        public static global::System.Collections.Generic.IEnumerable<global::Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> GetAllAttributes(this global::Microsoft.CodeAnalysis.SyntaxNode syntax)\n        {\n            var attributeLists = syntax switch\n            {\n                global::Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax compilationUnitSyntax => compilationUnitSyntax.AttributeLists,\n                global::Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax memberDeclarationSyntax => memberDeclarationSyntax.AttributeLists,\n                global::Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax lambdaExpressionSyntax => lambdaExpressionSyntax.AttributeLists,\n                global::Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax baseParameterSyntax => baseParameterSyntax.AttributeLists,\n                global::Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statementSyntax => statementSyntax.AttributeLists,\n                _ => throw new global::System.NotSupportedException($"{syntax.GetType()} has no attribute")};\n            return attributeLists.SelectMany(attributeListSyntax => attributeListSyntax.Attributes);\n        }\n\n        public static global::System.Collections.Generic.IEnumerable<global::Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> GetSpecifiedAttributes(this global::Microsoft.CodeAnalysis.SyntaxNode syntax, global::Microsoft.CodeAnalysis.SemanticModel semanticModel, string fullAttributeName, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))\n        {\n            foreach (var attributeSyntax in syntax.GetAllAttributes())\n            {\n                if (cancellationToken.IsCancellationRequested)\n                    yield break;\n                if (semanticModel.GetSymbolInfo(attributeSyntax, cancellationToken).Symbol is not global::Microsoft.CodeAnalysis.IMethodSymbol attributeSymbol)\n                    continue;\n                string attributeName = attributeSymbol.ContainingType.ToDisplayString();\n                if (attributeName == fullAttributeName)\n                    yield return attributeSyntax;\n            }\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax GetSpecifiedAttribute(this global::Microsoft.CodeAnalysis.SyntaxNode syntax, global::Microsoft.CodeAnalysis.SemanticModel semanticModel, string fullAttributeName, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))\n        {\n            foreach (var attributeSyntax in syntax.GetSpecifiedAttributes(semanticModel, fullAttributeName, cancellationToken))\n            {\n                return attributeSyntax;\n            }\n\n            return null;\n        }\n\n        public static bool HasSpecifiedAttribute(this global::Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax syntax, global::Microsoft.CodeAnalysis.SemanticModel semanticModel, string fullAttributeName)\n        {\n            return syntax.GetSpecifiedAttribute(semanticModel, fullAttributeName)is not null;\n        }\n\n        public static string GetArgumentString(this global::Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax syntax)\n        {\n            if (syntax.Expression is not global::Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax literalExpressionSyntax)\n                return null;\n            if (!literalExpressionSyntax.IsKind(global::Microsoft.CodeAnalysis.CSharp.SyntaxKind.StringLiteralExpression))\n                return null;\n            return literalExpressionSyntax.Token.ValueText;\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax GetArgumentType(this global::Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax syntax)\n        {\n            if (syntax.Expression is not global::Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax typeOfExpression)\n                return null;\n            return typeOfExpression.Type;\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax ToNameSyntax(this string text, int offset = 0, bool consumeFullText = true)\n        {\n            return global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseName(text, offset, consumeFullText);\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax ToNamespaceDeclaration(this global::Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax syntax)\n        {\n            return global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NamespaceDeclaration(syntax);\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax ToClassDeclaration(this string identifier)\n        {\n            return global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassDeclaration(identifier);\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddMembers(this global::Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax syntax, params string[] members)\n        {\n            return syntax.AddMembers(members.Select(x => global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseMemberDeclaration(x) ?? throw new global::System.Exception($"Text : {x} , Parse failed")).ToArray());\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddMembers(this global::Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax syntax, params string[] members)\n        {\n            return syntax.AddMembers(members.Select(x => global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseMemberDeclaration(x) ?? throw new global::System.Exception($"Text : {x} , Parse failed")).ToArray());\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddUsings(this global::Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax syntax, params string[] usings)\n        {\n            return syntax.AddUsings(usings.Select(x => global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingDirective(global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseName(x))).ToArray());\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddNamespace(this global::Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax syntax, string @namespace)\n        {\n            return syntax.AddMembers(global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NamespaceDeclaration(global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseName(@namespace)));\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddModifiers(this global::Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax syntax, params global::Microsoft.CodeAnalysis.CSharp.SyntaxKind[] items)\n        {\n            return syntax.AddModifiers(items.Select(x => global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Token(x)).ToArray());\n        }\n\n        public static global::Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddBaseListTypes(this global::Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax syntax, params string[] identifiers)\n        {\n            return syntax.AddBaseListTypes(identifiers.Select(x => global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SimpleBaseType(global::Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(x))).ToArray());\n        }\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\Feast.CodeAnalysis.SourceGenerators\\Feast.CodeAnalysis.Generators.TypedConstantGenerator\\Feast.CodeAnalysis.TypedConstantExtensions.g.cs",label:"Feast.CodeAnalysis.TypedConstantExtensions.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using System;\nusing System.Linq;\n\nnamespace Microsoft.CodeAnalysis\n{\n    internal static class TypedConstantExtensions\n    {\n        private static global::System.Type GetElementType(this global::System.Type type)\n        {\n            return type.IsArray ? type.GetElementType()! : throw new global::System.ArgumentException("type is not an array");\n        }\n\n        internal static object GenericList(this global::System.Type type, params object[] values)\n        {\n            var listType = type.MakeGenericType(type.GetGenericArguments());\n            var list = global::System.Activator.CreateInstance(listType);\n            var add = listType.GetMethod(nameof(global::System.Collections.Generic.List<object>.Add))!;\n            foreach (var value in values)\n            {\n                add.Invoke(list, new object[] { value });\n            }\n\n            return list;\n        }\n\n        private static object ToArray(object genericList)\n        {\n            var toArray = genericList.GetType().GetMethod(nameof(global::System.Collections.Generic.List<object>.ToArray))!;\n            return toArray.Invoke(genericList, null);\n        }\n\n        public static object GetArgumentValue(this global::Microsoft.CodeAnalysis.TypedConstant constant) => constant.Kind switch\n        {\n            global::Microsoft.CodeAnalysis.TypedConstantKind.Array => constant.Values.Select(x => x.GetArgumentValue()).ToArray(),\n            global::Microsoft.CodeAnalysis.TypedConstantKind.Error => null,\n            global::Microsoft.CodeAnalysis.TypedConstantKind.Type => (constant.Value as global::Microsoft.CodeAnalysis.INamedTypeSymbol)?.ToType(),\n            _ => constant.Value\n        };\n        public static object GetArgumentValue(this global::Microsoft.CodeAnalysis.TypedConstant constant, global::System.Type type)\n        {\n            var value = constant.GetArgumentValue();\n            if (!type.IsArray)\n                return type.IsEnum ? value == null ? null : global::System.Enum.ToObject(type, (int)value) : value;\n            if (value is not object[] arr)\n                throw new global::System.ArgumentException("constant is not an array");\n            var ret = global::System.Array.CreateInstance(type.GetElementType()!, arr.Length);\n            global::System.Array.Copy(arr, ret, arr.Length);\n            return ret;\n        }\n\n        public static global::Microsoft.CodeAnalysis.INamedTypeSymbol GetArgumentType(this global::Microsoft.CodeAnalysis.TypedConstant constant) => constant.Kind == global::Microsoft.CodeAnalysis.TypedConstantKind.Type ? constant.Value as global::Microsoft.CodeAnalysis.INamedTypeSymbol : throw new global::System.ArgumentException("constant is not a type");\n        public static string GetArgumentString(this global::Microsoft.CodeAnalysis.TypedConstant constant) => constant.Kind == global::Microsoft.CodeAnalysis.TypedConstantKind.Primitive ? constant.Value as string : throw new global::System.ArgumentException("constant is not a string");\n        public static T GetArgumentEnum<T>(this global::Microsoft.CodeAnalysis.TypedConstant constant)\n            where T : global::System.Enum => constant.Kind == global::Microsoft.CodeAnalysis.TypedConstantKind.Enum ? (T)constant.Value : throw new global::System.ArgumentException("constant is not an enum");\n        public static T? GetArgumentPrimitive<T>(this global::Microsoft.CodeAnalysis.TypedConstant constant)\n            where T : struct => constant.Kind == global::Microsoft.CodeAnalysis.TypedConstantKind.Primitive ? (T? )constant.Value : throw new global::System.ArgumentException("constant is not a primitive");\n        public static T[] GetArgumentArray<T>(this global::Microsoft.CodeAnalysis.TypedConstant constant) => constant.Kind == global::Microsoft.CodeAnalysis.TypedConstantKind.Array ? constant.Values.Select(x => (T)x.Value).ToArray() : throw new global::System.ArgumentException("constant is not an array");\n    }\n}\n'))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\PolySharp.SourceGenerators\\PolySharp.SourceGenerators.PolyfillsGenerator\\System.Runtime.CompilerServices.IsExternalInit.g.cs",label:"System.Runtime.CompilerServices.IsExternalInit.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated/>\n#pragma warning disable\n\n[assembly: global::System.Runtime.CompilerServices.TypeForwardedTo(typeof(global::System.Runtime.CompilerServices.IsExternalInit))]\n"))),(0,o.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CodeAnalysis\\src\\DemoLit\\obj\\GX\\PolySharp.SourceGenerators\\PolySharp.SourceGenerators.PolyfillsGenerator\\System.Runtime.CompilerServices.RequiresLocationAttribute.g.cs",label:"System.Runtime.CompilerServices.RequiresLocationAttribute.g.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated/>\n#pragma warning disable\n\n[assembly: global::System.Runtime.CompilerServices.TypeForwardedTo(typeof(global::System.Runtime.CompilerServices.RequiresLocationAttribute))]\n")))),(0,o.kt)("h2",{id:"usefull"},"Usefull"),(0,o.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("a",{target:"_blank",href:n(57571).Z},"Download Example project CodeAnalysis "))),(0,o.kt)("h3",{id:"share-codeanalysis"},"Share CodeAnalysis"),(0,o.kt)("ul",null,(0,o.kt)("li",null,(0,o.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCodeAnalysis&quote=CodeAnalysis",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,o.kt)("li",null,(0,o.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCodeAnalysis&text=CodeAnalysis:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCodeAnalysis",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,o.kt)("li",null,(0,o.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCodeAnalysis&title=CodeAnalysis",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,o.kt)("li",null,(0,o.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCodeAnalysis&title=CodeAnalysis&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCodeAnalysis",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/CodeAnalysis"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/CodeAnalysis")),(0,o.kt)("h3",{id:"in-the-same-category-codetostring---1-other-generators"},"In the same category (CodeToString) - 1 other generators"),(0,o.kt)("h4",{id:"sourcegeneratorhelpercopycode"},(0,o.kt)("a",{parentName:"h4",href:"/docs/SourceGenerator.Helper.CopyCode"},"SourceGenerator.Helper.CopyCode")))}u.isMDXComponent=!0},57571:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/CodeAnalysis-3dd50e2fca3294a7247c936787d63402.zip"}}]);