"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[3052],{95394:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>N,frontMatter:()=>p,metadata:()=>m,toc:()=>u});var a=t(87462),i=(t(67294),t(3905)),r=t(73992),o=t(18679),l=t(68839);const p={sidebar_position:1940,title:"194 - zlinq",description:"zero allocations for LINQ operations, high performance, functional programming",slug:"/zlinq"},s="zlinq  by Cysharp - subsidiary of Cygames",m={unversionedId:"RSCG-Examples/zlinq",id:"RSCG-Examples/zlinq",title:"194 - zlinq",description:"zero allocations for LINQ operations, high performance, functional programming",source:"@site/docs/RSCG-Examples/zlinq.md",sourceDirName:"RSCG-Examples",slug:"/zlinq",permalink:"/RSCG_Examples/v2/docs/zlinq",draft:!1,tags:[],version:"current",sidebarPosition:1940,frontMatter:{sidebar_position:1940,title:"194 - zlinq",description:"zero allocations for LINQ operations, high performance, functional programming",slug:"/zlinq"},sidebar:"tutorialSidebar",previous:{title:"193 - NativeObjects",permalink:"/RSCG_Examples/v2/docs/NativeObjects"},next:{title:"195 - Comparison",permalink:"/RSCG_Examples/v2/docs/Comparison"}},d={},u=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example (source csproj, source files)",id:"example-source-csproj-source-files",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share zlinq",id:"share-zlinq",level:3},{value:"In the same category (Linq) - 0 other generators",id:"in-the-same-category-linq---0-other-generators",level:3}],c={toc:u},h="wrapper";function N(e){let{components:n,...p}=e;return(0,i.kt)(h,(0,a.Z)({},c,p,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"zlinq--by-cysharp---subsidiary-of-cygames"},"zlinq  by Cysharp - subsidiary of Cygames"),(0,i.kt)(l.Z,{toc:u,mdxType:"TOCInline"}),(0,i.kt)("h2",{id:"nuget--site-data"},"NuGet / site data"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/ZLinq.DropInGenerator/"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/ZLinq.DropInGenerator?label=ZLinq.DropInGenerator",alt:"Nuget"})),(0,i.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/ZLinq/"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/ZLinq?label=ZLinq",alt:"Nuget"})),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/ZLinq"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/Cysharp/ZLinq?label=updated",alt:"GitHub last commit"})),"\n",(0,i.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/Cysharp/ZLinq?style=social",alt:"GitHub Repo stars"})),(0,i.kt)("h2",{id:"details"},"Details"),(0,i.kt)("h3",{id:"info"},"Info"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Name: ",(0,i.kt)("strong",{parentName:"p"},"zlinq")),(0,i.kt)("p",{parentName:"admonition"},"DropIn replacement Source Generator for ZLinq."),(0,i.kt)("p",{parentName:"admonition"},"Author: Cysharp - subsidiary of Cygames"),(0,i.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/ZLinq.DropInGenerator/"},"https://www.nuget.org/packages/ZLinq.DropInGenerator/")),"   "),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/ZLinq/"},"https://www.nuget.org/packages/ZLinq/")),"   "),(0,i.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,i.kt)("a",{parentName:"p",href:"https://neuecc.medium.com/zlinq-a-zero-allocation-linq-library-for-net-1bb0a3e5c749"},"https://neuecc.medium.com/zlinq-a-zero-allocation-linq-library-for-net-1bb0a3e5c749")),(0,i.kt)("p",{parentName:"admonition"},"Source: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/ZLinq"},"https://github.com/Cysharp/ZLinq"))),(0,i.kt)("h3",{id:"original-readme"},"Original Readme"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("h1",{parentName:"admonition",id:"zlinq"},"ZLinq"),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/ZLinq/actions/workflows/build-debug.yaml"},(0,i.kt)("img",{parentName:"a",src:"https://github.com/Cysharp/ZLinq/actions/workflows/build-debug.yaml/badge.svg",alt:"CI"})),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/ZLinq/actions/workflows/benchmark.yaml"},(0,i.kt)("img",{parentName:"a",src:"https://github.com/Cysharp/ZLinq/actions/workflows/benchmark.yaml/badge.svg",alt:"Benchmark"})),"\n",(0,i.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/ZLinq"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/v/ZLinq",alt:"NuGet"})),"\n",(0,i.kt)("a",{parentName:"p",href:"https://deepwiki.com/Cysharp/ZLinq"},(0,i.kt)("img",{parentName:"a",src:"https://deepwiki.com/badge.svg",alt:"Ask DeepWiki"}))),(0,i.kt)("p",{parentName:"admonition"},"Zero allocation LINQ with LINQ to Span, LINQ to SIMD, and LINQ to Tree (FileSystem, JSON, GameObject, etc.) for all .NET platforms(netstandard2.0, 2.1, net8, net9) and Unity, Godot."),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("img",{parentName:"p",src:"https://github.com/Cysharp/ZLinq/img/benchmarkhead.jpg",alt:null})),(0,i.kt)("p",{parentName:"admonition"},"Unlike regular LINQ, ZLinq doesn't increase allocations when adding more method chains, and it also has higher basic performance. You can check various benchmark patterns at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/ZLinq/actions/runs/14569138271"},"GitHub Actions/Benchmark"),". ZLinq shows high performance in almost all patterns, with some benchmarks showing overwhelming differences."),(0,i.kt)("p",{parentName:"admonition"},"As a bonus, LINQ operators and optimizations equivalent to .NET 10 can be used in .NET Framework 4.8 (netstandard2.0) and Unity (netstandard2.1)."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet add package ZLinq\n")),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"using ZLinq;\n\nvar seq = source\n    .AsValueEnumerable() // only add this line\n    .Where(x => x % 2 == 0)\n    .Select(x => x * 3);\n\nforeach (var item in seq) { }\n")),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"99% compatibility")," with .NET 10's LINQ (including new ",(0,i.kt)("inlineCode",{parentName:"li"},"Shuffle"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"RightJoin"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"LeftJoin")," operators)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Zero allocation")," for method chains through struct-based Enumerable via ",(0,i.kt)("inlineCode",{parentName:"li"},"ValueEnumerable")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"LINQ to Span")," to full support LINQ operations on ",(0,i.kt)("inlineCode",{parentName:"li"},"Span<T>")," using .NET 9/C# 13's ",(0,i.kt)("inlineCode",{parentName:"li"},"allows ref struct")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"LINQ to Tree")," to extend tree-structured objects (built-in support for FileSystem, JSON, GameObject)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"LINQ to SIMD")," to automatic application of SIMD where possible and customizable arbitrary operations"),(0,i.kt)("li",{parentName:"ul"},"Optional ",(0,i.kt)("strong",{parentName:"li"},"Drop-in replacement")," Source Generator to automatically accelerate all LINQ methods")),(0,i.kt)("p",{parentName:"admonition"},"In ZLinq, we have proven high compatibility and performance by running ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/ZLinq/tree/main/tests/System.Linq.Tests"},"dotnet/runtime's System.Linq.Tests")," as a drop-in replacement, passing 9000 tests."),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("img",{parentName:"p",src:"https://github.com/Cysharp/ZLinq/img/testrun.png",alt:null})),(0,i.kt)("p",{parentName:"admonition"},"Previously, value type-based LINQ implementations were often experimental, but ZLinq fully implements all methods to completely replace standard LINQ in production use, delivering high performance suitable even for demanding applications like games. The performance aspects are based on my experience with previous LINQ implementations (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/neuecc/linq.js/"},"linq.js"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/SimdLinq/"},"SimdLinq"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/neuecc/UniRx"},"UniRx"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/R3"},"R3"),"), zero-allocation implementations (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/ZString"},"ZString"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/ZLogger"},"ZLogger"),"), and high-performance serializers (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/MessagePack-CSharp/MessagePack-CSharp/"},"MessagePack-CSharp"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/MemoryPack"},"MemoryPack"),")."),(0,i.kt)("p",{parentName:"admonition"},"ZLinq achieves zero-allocation LINQ implementation using the following structs and interfaces."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public readonly ref struct ValueEnumerable<TEnumerator, T>(TEnumerator enumerator)\n    where TEnumerator : struct, IValueEnumerator<T>, allows ref struct\n{\n    public readonly TEnumerator Enumerator = enumerator;\n}\n\npublic interface IValueEnumerator<T> : IDisposable\n{\n    bool TryGetNext(out T current); // as MoveNext + Current\n\n    // Optimization helper\n    bool TryGetNonEnumeratedCount(out int count);\n    bool TryGetSpan(out ReadOnlySpan<T> span);\n    bool TryCopyTo(scoped Span<T> destination, Index offset);\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"Besides changing to a struct-based approach, we've integrated MoveNext and Current to reduce the number of iterator calls. Also, some operators don't need to hold Current, which allows minimizing the struct size. Additionally, being struct-based, we efficiently separate internal state by copying the Enumerator instead of using GetEnumerator. With .NET 9/C# 13 or later, ",(0,i.kt)("inlineCode",{parentName:"p"},"allows ref struct")," enables natural integration of ",(0,i.kt)("inlineCode",{parentName:"p"},"Span<T>")," into LINQ."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public static ValueEnumerable<Where<TEnumerator, TSource>, TSource> Where<TEnumerator, TSource>(this ValueEnumerable<TEnumerator, TSource> source, Func<TSource, Boolean> predicate)\n    where TEnumerator : struct, IValueEnumerator<TSource>, allows ref struct\n")),(0,i.kt)("p",{parentName:"admonition"},"Operators have this method signature. C# cannot infer types from generic constraints(",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dotnet/csharplang/discussions/6930"},"dotnet/csharplang#6930"),"). Therefore, the traditional Struct LINQ approach required implementing all operator combinations as instance methods, resulting in ",(0,i.kt)("a",{parentName:"p",href:"https://kevinmontrose.com/2018/01/17/linqaf-replacing-linq-and-not-allocating/"},"100,000+ methods and massive assembly sizes"),". However, in ZLinq, we've successfully avoided all the boilerplate method implementations by devising an approach that properly conveys types to C# compiler."),(0,i.kt)("p",{parentName:"admonition"},"Additionally, ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetNonEnumeratedCount(out int count)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetSpan(out ReadOnlySpan<T> span)"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCopyTo(Span<T> destination, Index offset)")," defined in the interface itself enable flexible optimizations. To minimize assembly size, we've designed the library to achieve maximum optimization with minimal method additions. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCopyTo")," works efficiently with methods like ",(0,i.kt)("inlineCode",{parentName:"p"},"ToArray")," when combined with ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetNonEnumeratedCount"),". However, it also allows copying to smaller-sized destinations. By combining this with Index, we can optimize ",(0,i.kt)("inlineCode",{parentName:"p"},"First"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Last"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementAt")," using just ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCopyTo")," by passing a single-element Span along with an Index."),(0,i.kt)("p",{parentName:"admonition"},"If you're interested in architecture, please read my blog post ",(0,i.kt)("a",{parentName:"p",href:"https://neuecc.medium.com/zlinq-a-zero-allocation-linq-library-for-net-1bb0a3e5c749"},(0,i.kt)("strong",{parentName:"a"},'"ZLinq", a Zero-Allocation LINQ Library for .NET'))," where I wrote the details."),(0,i.kt)("h2",{parentName:"admonition",id:"getting-started"},"Getting Started"),(0,i.kt)("p",{parentName:"admonition"},"You can install package from ",(0,i.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/ZLinq"},"NuGet/ZLinq"),". For Unity usage, refer to the ",(0,i.kt)("a",{parentName:"p",href:"#unity"},"Unity section"),". For Godot usage, refer to the ",(0,i.kt)("a",{parentName:"p",href:"#godot"},"Godot section"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet add package ZLinq\n")),(0,i.kt)("p",{parentName:"admonition"},"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"using ZLinq;")," and call ",(0,i.kt)("inlineCode",{parentName:"p"},"AsValueEnumerable()")," on any iterable type to use ZLinq's zero-allocation LINQ."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"using ZLinq;\n\nvar source = new int[] { 1, 2, 3, 4, 5 };\n\n// Call AsValueEnumerable to apply ZLinq\nvar seq1 = source.AsValueEnumerable().Where(x => x % 2 == 0);\n\n// Can also be applied to Span (only in .NET 9/C# 13 environments that support allows ref struct)\nSpan<int> span = stackalloc int[5] { 1, 2, 3, 4, 5 };\nvar seq2 = span.AsValueEnumerable().Select(x => x * x);\n")),(0,i.kt)("p",{parentName:"admonition"},"Even if it's netstandard 2.0 or below .NET 10, all operators up to .NET 10 are available."),(0,i.kt)("p",{parentName:"admonition"},"You can method chain and foreach like regular LINQ, but there are some limitations. Please see ",(0,i.kt)("a",{parentName:"p",href:"#difference-and-limitation"},"Difference and Limitation")," for details. ZLinq has drop-in replacements that apply ZLinq without needing to call ",(0,i.kt)("inlineCode",{parentName:"p"},"AsValueEnumerable()"),". For more information, see ",(0,i.kt)("a",{parentName:"p",href:"#drop-in-replacement"},"Drop-in replacement"),". Detailed information about ",(0,i.kt)("a",{parentName:"p",href:"#linq-to-tree"},"LINQ to Tree")," for LINQ-ifying tree structures (FileSystems and JSON) and ",(0,i.kt)("a",{parentName:"p",href:"#linq-to-simd"},"LINQ to SIMD")," for expanding SIMD application range can be found in their respective sections."),(0,i.kt)("h2",{parentName:"admonition",id:"additional-operators"},"Additional Operators"),(0,i.kt)("p",{parentName:"admonition"},"In ZLinq, we prioritize compatibility, so we try to minimize adding custom operators. However, the following methods have been added to enable efficient processing with zero allocation:"),(0,i.kt)("h3",{parentName:"admonition",id:"asvalueenumerable"},(0,i.kt)("inlineCode",{parentName:"h3"},"AsValueEnumerable()")),(0,i.kt)("p",{parentName:"admonition"},"Converts existing collections to a type that can be chained with ZLinq. Any ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," can be converted, but for the following types, conversion is done with zero allocation without ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>.GetEnumerator()")," allocation. Standard supported types are ",(0,i.kt)("inlineCode",{parentName:"p"},"T[]"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ArraySegment<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Memory<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadOnlyMemory<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadOnlySequence<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Dictionary<TKey, TValue>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Stack<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ImmutableArray<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Span<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadOnlySpan<T>"),". However, conversion from ",(0,i.kt)("inlineCode",{parentName:"p"},"ImmutableArray<T>")," requires ",(0,i.kt)("inlineCode",{parentName:"p"},".NET 8")," or higher, and conversion from ",(0,i.kt)("inlineCode",{parentName:"p"},"Span<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadOnlySpan<T>")," requires ",(0,i.kt)("inlineCode",{parentName:"p"},".NET 9")," or higher."),(0,i.kt)("p",{parentName:"admonition"},"When a type is declared as ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ICollection<T>")," rather than concrete types like ",(0,i.kt)("inlineCode",{parentName:"p"},"T[]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>"),", generally additional allocations occur when using foreach. In ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinq"),", even when these interfaces are declared, if the actual type is ",(0,i.kt)("inlineCode",{parentName:"p"},"T[]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>"),", processing is performed with zero allocation."),(0,i.kt)("p",{parentName:"admonition"},"Convert from ",(0,i.kt)("inlineCode",{parentName:"p"},"System.Collections.IEnumerable")," is also supported. In that case, using ",(0,i.kt)("inlineCode",{parentName:"p"},"AsValueEnumerable()")," without specifying a type converts to ",(0,i.kt)("inlineCode",{parentName:"p"},"ValueEnumerable<, object>"),", but you can also cast it simultaneously by ",(0,i.kt)("inlineCode",{parentName:"p"},"AsValueEnumerable<T>()"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"IEnumerable nonGenericCollection = default!;\nnonGenericCollection.AsValueEnumerable(); // ValueEnumerable<, object>\nnonGenericCollection.AsValueEnumerable<int>(); // ValueEnumerable<, int>\n")),(0,i.kt)("h3",{parentName:"admonition",id:"valueenumerablerange-valueenumerablerepeat-valueenumerableempty"},(0,i.kt)("inlineCode",{parentName:"h3"},"ValueEnumerable.Range()"),", ",(0,i.kt)("inlineCode",{parentName:"h3"},"ValueEnumerable.Repeat()"),", ",(0,i.kt)("inlineCode",{parentName:"h3"},"ValueEnumerable.Empty()")),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"ValueEnumerable.Range")," operates more efficiently when handling with ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinq")," than ",(0,i.kt)("inlineCode",{parentName:"p"},"Enumerable.Range().AsValueEnumerable()"),". The same applies to ",(0,i.kt)("inlineCode",{parentName:"p"},"Repeat")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Empty"),". The Range can also handle ",(0,i.kt)("inlineCode",{parentName:"p"},"System.Range"),", step increments, ",(0,i.kt)("inlineCode",{parentName:"p"},"IAdditionOperators<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTime"),", and more. Please refer to the ",(0,i.kt)("a",{parentName:"p",href:"#range"},"Range")," section for details."),(0,i.kt)("h3",{parentName:"admonition",id:"average--where-inumbert-sum--where-inumbert"},(0,i.kt)("inlineCode",{parentName:"h3"},"Average() : where INumber<T>"),", ",(0,i.kt)("inlineCode",{parentName:"h3"},"Sum() : where INumber<T>")),(0,i.kt)("p",{parentName:"admonition"},"System.Linq's ",(0,i.kt)("inlineCode",{parentName:"p"},"Average")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Sum")," are limited to certain primitive types, but ZLinq extends them to all ",(0,i.kt)("inlineCode",{parentName:"p"},"INumber<T>")," types. In ",(0,i.kt)("inlineCode",{parentName:"p"},".NET 8")," or higher, where constraints are included, but for others (netstandard2.0, 2.1), runtime errors will occur when called with non-primitive target types."),(0,i.kt)("h3",{parentName:"admonition",id:"sumunchecked"},(0,i.kt)("inlineCode",{parentName:"h3"},"SumUnchecked()")),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"Sum")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"checked"),", but checking for overflow during SIMD execution creates performance overhead. ",(0,i.kt)("inlineCode",{parentName:"p"},"SumUnchecked")," skips overflow checking to achieve maximum SIMD aggregation performance. Note that this requires ",(0,i.kt)("inlineCode",{parentName:"p"},".NET 8")," or higher, and SIMD-supported types are ",(0,i.kt)("inlineCode",{parentName:"p"},"sbyte"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"short"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"long"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"byte"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ushort"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"uint"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ulong"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"double"),", and the source must be able to get a Span (",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetSpan")," returns true)."),(0,i.kt)("h3",{parentName:"admonition",id:"aggregateby-countby-constraints"},(0,i.kt)("inlineCode",{parentName:"h3"},"AggregateBy"),", ",(0,i.kt)("inlineCode",{parentName:"h3"},"CountBy")," constraints"),(0,i.kt)("p",{parentName:"admonition"},".NET 9 ",(0,i.kt)("inlineCode",{parentName:"p"},"AggregateBy")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CountBy")," has ",(0,i.kt)("inlineCode",{parentName:"p"},"TKey : notnull")," constraints. However, this is due to internal implementation considerations, and it lacks consistency with traditional operators such as Lookup and Join. Therefore, in ZLinq, the notnull constraint was removed."),(0,i.kt)("h3",{parentName:"admonition",id:"int-copytospant-destination-void-copytolistt-list"},(0,i.kt)("inlineCode",{parentName:"h3"},"int CopyTo(Span<T> destination)"),", ",(0,i.kt)("inlineCode",{parentName:"h3"},"void CopyTo(List<T> list)")),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"CopyTo")," can be used to avoid allocation of the return collection unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"ToArray")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ToList"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"int CopyTo(Span<T> destination)")," allows the destination to be smaller than the source, returning the number of elements copied. ",(0,i.kt)("inlineCode",{parentName:"p"},"void CopyTo(List<T> list)")," clears the list and then fills it with elements from the source, so the destination size is list.Count."),(0,i.kt)("h3",{parentName:"admonition",id:"pooledarraytsource-toarraypool"},(0,i.kt)("inlineCode",{parentName:"h3"},"PooledArray<TSource> ToArrayPool()")),(0,i.kt)("p",{parentName:"admonition"},"The returned array is rented from ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayPool<TSource>.Shared"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"PooledArray<TSource>")," defines ",(0,i.kt)("inlineCode",{parentName:"p"},".Span"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".Memory"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".AsEnumerable()")," and other methods. These allow you to pass a ",(0,i.kt)("inlineCode",{parentName:"p"},"ValueEnumerable")," to another method while minimizing allocations. Additionally, through ",(0,i.kt)("inlineCode",{parentName:"p"},".AsValueEnumerable()"),", you can call ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinq")," methods, which is useful for temporarily materializing computationally expensive operations. Being ",(0,i.kt)("inlineCode",{parentName:"p"},"IDisposable"),", you can return the borrowed array to ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayPool<TSource>.Shared")," using the ",(0,i.kt)("inlineCode",{parentName:"p"},"using")," statement."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"using var array = ValueEnumerable.Range(1, 1000).ToArrayPool();\n\nvar size = array.Size; // same as Length/Count in other types\nvar span = array.Span;\nvar memory = array.Memory;\nvar arraySegment = array.ArraySegment;\nvar enumerable = array.AsEnumerable();\nvar valueEnumerable = array.AsValueEnumerable();\n")),(0,i.kt)("p",{parentName:"admonition"},"For performance reasons to reduce allocations, ",(0,i.kt)("inlineCode",{parentName:"p"},"PooledArray<TSource>")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"struct"),". This creates a risk of returning the same array multiple times due to boxing or copying. Also, ArrayPool is not suitable for long-term array storage. It is recommended to simply use ",(0,i.kt)("inlineCode",{parentName:"p"},"ToArrayPool()")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"using")," and keep the lifetime short."),(0,i.kt)("p",{parentName:"admonition"},"If you absolutely need the raw internal array, you can ",(0,i.kt)("inlineCode",{parentName:"p"},"Deconstruct")," it to ",(0,i.kt)("inlineCode",{parentName:"p"},"(T[] Array, int Size)"),". After deconstructing, ownership is considered transferred, and all methods of ",(0,i.kt)("inlineCode",{parentName:"p"},"PooledArray<TSource>")," become unavailable."),(0,i.kt)("h3",{parentName:"admonition",id:"jointostringcharstring-seperator"},(0,i.kt)("inlineCode",{parentName:"h3"},"JoinToString(char|string seperator)")),(0,i.kt)("p",{parentName:"admonition"},"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinq")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),", it cannot be passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"String.Join"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"JoinToString")," provides the same functionality as ",(0,i.kt)("inlineCode",{parentName:"p"},"String.Join"),", returning a string joined with the separator."),(0,i.kt)("h2",{parentName:"admonition",id:"range"},"Range"),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"Range")," is not only compatible with System.Linq's ",(0,i.kt)("inlineCode",{parentName:"p"},"Range(int start, int count)")," but also has many additional overloads such as ",(0,i.kt)("inlineCode",{parentName:"p"},"System.Range")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTime"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// 95, 96, 97, 98, 99\nvar range1 = ValueEnumerable.Range(95..100);\n\n// 95, 96, 97, 98, 99, 100\nvar range2 = ValueEnumerable.Range(95..100, RightBound.Inclusive);\n\n// 10, 12, 14, 16, 18\nvar step = ValueEnumerable.Range(start: 10, count: 5, step: 2);\n\n// 10, 9, 8, 7, 6\nvar reverse = ValueEnumerable.Range(start: 10, count: 5, step: -1);\n\n// 10, 9, 8, 7, 6, 5\nvar downTo = ValueEnumerable.Range(start: 10, end: 5, RightBound.Inclusive);\n\n// 0, 1,.........\nvar infinite = ValueEnumerable.Range(..);\n\n// a, b, c,..., z\nvar alphabets = ValueEnumerable.Range(start: 'a', end: 'z', RightBound.Inclusive);\n\n// 5/13, 5/14, 5/15, 5/16, 5/17, 5/18, 5/19\nvar daysOfweek = ValueEnumerable.Range(DateTime.Now, 7, TimeSpan.FromDays(1)); ;\n\n// 5/1, 5/2,...,5/31\nvar now = DateTime.Now;\nvar calendarOfThisMonth = ValueEnumerable.Range(new DateTime(now.Year, now.Month, 1), DateTime.DaysInMonth(now.Year, now.Month), TimeSpan.FromDays(1));\n")),(0,i.kt)("p",{parentName:"admonition"},"Passing ",(0,i.kt)("inlineCode",{parentName:"p"},"..")," as Range creates an infinite stream. Range is Exclusive by default, but you can also run it as Inclusive by specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"RightBound.Inclusive/Exclusive"),". Also, in .NET 8 or later, it supports ",(0,i.kt)("inlineCode",{parentName:"p"},"IAdditionOperators<T>"),", allowing you to generate not only int but also ",(0,i.kt)("inlineCode",{parentName:"p"},"char"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),", etc. In addition, it supports more generic generation with not only count but also ",(0,i.kt)("inlineCode",{parentName:"p"},"T end")," specification and ",(0,i.kt)("inlineCode",{parentName:"p"},"TStep step"),"."),(0,i.kt)("p",{parentName:"admonition"},"It supports ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTime"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTimeOffset")," + ",(0,i.kt)("inlineCode",{parentName:"p"},"TimeSpan")," for all platforms. ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dotnet/runtime/issues/76225"},"Unfortunately, ",(0,i.kt)("inlineCode",{parentName:"a"},"DateTime")," and ",(0,i.kt)("inlineCode",{parentName:"a"},"DateTimeOffset")," do not support Generic Math"),", but we have prepared our own implementation that provides functionality equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"IAdditionOperators<T>")," support. This makes it easy to generate date sequences."),(0,i.kt)("p",{parentName:"admonition"},"The complete list of Range APIs is as follows."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public enum RightBound\n{\n    Inclusive,\n    Exclusive\n}\n\npublic static partial class ValueEnumerable\n{\n    public static ValueEnumerable<FromRange, int> Range(int start, int count)\n\n    public static ValueEnumerable<FromRange2, int> Range(Range range, RightBound rightBound = RightBound.Exclusive)\n\n#if NET8_0_OR_GREATER\n\n    public static ValueEnumerable<FromRange<T, T>, T> Range<T>(T start, int count)\n        where T : INumberBase<T>\n\n    public static ValueEnumerable<FromRange<T, TStep>, T> Range<T, TStep>(T start, int count, TStep step)\n        where T : IAdditionOperators<T, TStep, T>\n\n    public static ValueEnumerable<FromRangeTo<T, T>, T> Range<T>(T start, T end, RightBound rightBound)\n        where T : INumberBase<T>, IComparisonOperators<T, T, bool>\n\n    public static ValueEnumerable<FromRangeTo<T, TStep>, T> Range<T, TStep>(T start, T end, TStep step, RightBound rightBound)\n        where T : IAdditionOperators<T, TStep, T>, IComparisonOperators<T, T, bool>\n\n#endif\n\n    public static ValueEnumerable<FromRangeDateTime, DateTime> Range(DateTime start, int count, TimeSpan step)\n    public static ValueEnumerable<FromRangeDateTimeTo, DateTime> Range(DateTime start, DateTime end, TimeSpan step, RightBound rightBound)\n    public static ValueEnumerable<FromRangeDateTimeOffset, DateTimeOffset> Range(DateTimeOffset start, int count, TimeSpan step)\n    public static ValueEnumerable<FromRangeDateTimeOffsetTo, DateTimeOffset> Range(DateTimeOffset start, DateTimeOffset end, TimeSpan step, RightBound rightBound)\n}\n")),(0,i.kt)("h2",{parentName:"admonition",id:"difference-and-limitation"},"Difference and Limitation"),(0,i.kt)("p",{parentName:"admonition"},"For .NET 9 and above, ",(0,i.kt)("inlineCode",{parentName:"p"},"ValueEnumerable<T>")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"ref struct")," and cannot be converted to ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),". To ensure compatibility when upgrading, ",(0,i.kt)("inlineCode",{parentName:"p"},"AsEnumerable")," is not provided by default even for versions prior to .NET 9."),(0,i.kt)("p",{parentName:"admonition"},"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"ValueEnumerable<T>")," is not an ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),", it cannot be passed to methods that require ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),". It's also difficult to pass it to other methods due to the complex type signatures required by generics (implementation is explained in the ",(0,i.kt)("a",{parentName:"p",href:"#custom-extensions"},"Custom Extensions")," section). Using ",(0,i.kt)("inlineCode",{parentName:"p"},"ToArray()")," is one solution, but this can cause unnecessary allocations in some cases. For temporary use, you can call ",(0,i.kt)("inlineCode",{parentName:"p"},"ToArrayPool")," to pass to methods that require ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," without allocations. However, be careful that this ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," will be returned within the using scope, so you must ensure it doesn't leak outside the scope (storing it in a field is not allowed)."),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"String.Join")," has overloads for both ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<string>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"params object[]"),". Passing ",(0,i.kt)("inlineCode",{parentName:"p"},"ValueEnumerable<T>")," directly will select the ",(0,i.kt)("inlineCode",{parentName:"p"},"object[]")," overload, which may not give the desired result. In this case, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"JoinToString")," operator instead."),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"ValueEnumerable<T>")," is a struct, and its size increases slightly with each method chain. With many chained methods, copy costs can become significant. When iterating over small collections, these copy costs can outweigh the benefits, causing performance to be worse than standard LINQ. However, this is only an issue with extremely long method chains and small iteration counts, so it's rarely a practical concern."),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"ValueEnumerable<T>")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"ref struct")," in .NET 9 or above, this means that it cannot span across yield or await. Using yield or await inside foreach also fails and shows compilation errors. If enumeration is needed, please materialize the data using methods like ",(0,i.kt)("a",{parentName:"p",href:"#pooledarraytsource-toarraypool"},"ToArrayPool"),"."),(0,i.kt)("p",{parentName:"admonition"},"Each chain operation returns a different type, so you cannot reassign to the same variable. For example, code that continuously reassigns ",(0,i.kt)("inlineCode",{parentName:"p"},"Concat")," in a for loop cannot be implemented."),(0,i.kt)("p",{parentName:"admonition"},"In .NET 8 and above, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Sum")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Average")," methods for ",(0,i.kt)("inlineCode",{parentName:"p"},"double")," use SIMD processing, which performs parallel processing based on SIMD width. This results in calculation errors that differ from normal ones due to the different order of addition."),(0,i.kt)("h2",{parentName:"admonition",id:"drop-in-replacement"},"Drop-in replacement"),(0,i.kt)("p",{parentName:"admonition"},"When introducing ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinq.DropInGenerator"),", you can automatically use ZLinq for all LINQ methods without calling ",(0,i.kt)("inlineCode",{parentName:"p"},"AsValueEnumerable()"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet add package ZLinq.DropInGenerator\n")),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("img",{parentName:"p",src:"https://github.com/Cysharp/ZLinq/img/dropin.jpg",alt:null})),(0,i.kt)("p",{parentName:"admonition"},"It works by using a Source Generator to add extension methods for each type that take priority, making ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinq")," methods be selected instead of System.Linq when the same name and arguments are used.\nAfter installing the package, you need to configure it with an assembly attribute."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[assembly: ZLinq.ZLinqDropInAttribute("ZLinq", ZLinq.DropInGenerateTypes.Array)]\n')),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"generateNamespace")," is the namespace for the generated code, and ",(0,i.kt)("inlineCode",{parentName:"p"},"DropInGenerateTypes")," selects the target types.\n",(0,i.kt)("inlineCode",{parentName:"p"},"DropInGenerateTypes")," allows you to choose from ",(0,i.kt)("inlineCode",{parentName:"p"},"Array"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Span")," (Span/ReadOnlySpan), ",(0,i.kt)("inlineCode",{parentName:"p"},"Memory")," (Memory/ReadOnlyMemory), ",(0,i.kt)("inlineCode",{parentName:"p"},"List"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Enumerable")," (IEnumerable).\nThese are Flags, so you can combine them, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"DropInGenerateTypes.Array | DropInGenerateTypes.Span"),".\nThere are also predefined combinations: ",(0,i.kt)("inlineCode",{parentName:"p"},"Collection = Array | Span | Memory | List")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Everything = Array | Span | Memory | List | Enumerable"),"."),(0,i.kt)("p",{parentName:"admonition"},"When using ",(0,i.kt)("inlineCode",{parentName:"p"},"DropInGenerateTypes.Enumerable"),", which generates extension methods for ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),", you need to make ",(0,i.kt)("inlineCode",{parentName:"p"},"generateNamespace")," global as a namespace priority.\nFor example:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[assembly: ZLinq.ZLinqDropInAttribute("", ZLinq.DropInGenerateTypes.Everything)]\n')),(0,i.kt)("p",{parentName:"admonition"},"This is the most aggressive configuration, causing all LINQ methods to be processed by ZLinq, and making it impossible to use normal LINQ methods (if Enumerable is not included, you can call AsEnumerable() to execute with System.Linq)."),(0,i.kt)("p",{parentName:"admonition"},"It's better to use application's default namespace rather than globally, as this allows you to switch between normal LINQ using namespaces. This approach is recommended when you need to target ",(0,i.kt)("inlineCode",{parentName:"p"},"Enumerable"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using ZLinq;\n\n[assembly: ZLinqDropInAttribute("MyApp", DropInGenerateTypes.Everything)]\n\n// namespace under MyApp\nnamespace MyApp.Foo\n{\n    public class Bar\n    {\n        public static void Foo(IEnumerable<int> source)\n        {\n            // ZLinq ValueEnumerable<T>\n            var seq = source.Select(x => x * 2).Shuffle();\n            using var e = seq.Enumerator;\n            while (e.TryGetNext(out var current))\n            {\n                Console.WriteLine(current);\n            }\n        }\n    }\n}\n\n// not under MyApp namespace\nnamespace NotMyApp\n{\n    public class Baz\n    {\n        public static void Foo(IEnumerable<int> source)\n        {\n            // IEnumerable<T>\n            var seq = source.Select(x => x * 2); // .Shuffle();\n            using var e = seq.GetEnumerator();\n            while (e.MoveNext())\n            {\n                Console.WriteLine(e.Current);\n            }\n        }\n    }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"ZLinq is powerful and in many cases it performs better than regular LINQ, but it also has its limitations. For more information, please refer to ",(0,i.kt)("a",{parentName:"p",href:"#difference-and-limitation"},"Difference and Limitation"),". When you are not familiar with it, we recommend that you use ",(0,i.kt)("inlineCode",{parentName:"p"},"DropInGenerateTypes.Collection")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"DropInGenerateTypes.Everything"),"."),(0,i.kt)("p",{parentName:"admonition"},"Other options for ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinqDropInAttribute")," include ",(0,i.kt)("inlineCode",{parentName:"p"},"GenerateAsPublic"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ConditionalCompilationSymbols"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"DisableEmitSource"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)]\npublic sealed class ZLinqDropInAttribute : Attribute\n{\n    /// <summary>\n    /// Gets the namespace where the generated LINQ implementations will be placed.\n    /// If empty, the implementations will be generated in the global namespace.\n    /// </summary>\n    public string GenerateNamespace { get; }\n\n    /// <summary>\n    /// Gets the types of collections for which LINQ implementations should be generated.\n    /// </summary>\n    public DropInGenerateTypes DropInGenerateTypes { get; }\n\n    /// <summary>\n    /// Gets whether the generated LINQ implementations should be public.\n    /// When true, the implementations will be generated with public visibility.\n    /// When false (default), the implementations will be generated with internal visibility.\n    /// </summary>\n    public bool GenerateAsPublic { get; set; }\n\n    /// <summary>\n    /// Gets or sets the conditional compilation symbols to wrap the generated code with #if directives.\n    /// If specified, the generated code will be wrapped in #if/#endif directives using these symbols.\n    /// </summary>\n    public string? ConditionalCompilationSymbols { get; set; }\n\n    /// <summary>\n    /// Gets or sets whether to disable source generation in emitted code.\n    /// When true, the source code comments will not be included in the generated code.\n    /// When false (default), source code comments will be included in the generated code.\n    /// </summary>\n    public bool DisableEmitSource { get; set; }\n\n    /// <summary>\n    /// Initializes a new instance of the <see cref="ZLinqDropInAttribute"/> class.\n    /// </summary>\n    /// <param name="generateNamespace">The namespace where the generated LINQ implementations will be placed. If empty, place to global.</param>\n    /// <param name="dropInGenerateTypes">The types of collections for which LINQ implementations should be generated.</param>\n    public ZLinqDropInAttribute(string generateNamespace, DropInGenerateTypes dropInGenerateTypes)\n    {\n        GenerateNamespace = generateNamespace;\n        DropInGenerateTypes = dropInGenerateTypes;\n    }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"To support DropIn types other than ",(0,i.kt)("inlineCode",{parentName:"p"},"DropInGenerateTypes"),", you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinqDropInExternalExtensionAttribute"),". This attribute allows you to generate DropIn for any type by specifying its fully qualified name. For example, to add support for ",(0,i.kt)("inlineCode",{parentName:"p"},"IReadOnlyCollection<T>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"IReadOnlyList<T>"),", write:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'// T must be written as `1 (metadata-name). For nested types, connect with +\n[assembly: ZLinqDropInExternalExtension("ZLinq", "System.Collections.Generic.IReadOnlyCollection`1")]\n[assembly: ZLinqDropInExternalExtension("ZLinq", "System.Collections.Generic.IReadOnlyList`1")]\n')),(0,i.kt)("p",{parentName:"admonition"},"For types that support ",(0,i.kt)("inlineCode",{parentName:"p"},"IValueEnumerator<T>")," through ",(0,i.kt)("inlineCode",{parentName:"p"},"AsValueEnumerable()"),", specify the ValueEnumerator type name as the second argument. For example, with ",(0,i.kt)("inlineCode",{parentName:"p"},"ImmutableArray<T>"),":"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[assembly: ZLinqDropInExternalExtension("ZLinq", "System.Collections.Immutable.ImmutableArray`1", "ZLinq.Linq.FromImmutableArray`1")]\n')),(0,i.kt)("p",{parentName:"admonition"},"This allows all operators to be processed by ZLinq using an optimized type."),(0,i.kt)("p",{parentName:"admonition"},"If you want to make your custom collection types DropIn compatible, you can embed them in your assembly using ",(0,i.kt)("inlineCode",{parentName:"p"},"[ZLinqDropInExtension]"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"[ZLinqDropInExtension]\npublic class AddOnlyIntList : IEnumerable<int>\n{\n    List<int> list = new List<int>();\n\n    public void Add(int x) => list.Add(x);\n\n    public IEnumerator<int> GetEnumerator() => list.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => list.GetEnumerator();\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"This generates a ",(0,i.kt)("inlineCode",{parentName:"p"},"public static partial class AddOnlyIntListZLinqDropInExtensions")," in the same namespace, overriding all LINQ operators with ZLinq. This works with generic types as well:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"[ZLinqDropInExtension]\npublic class AddOnlyList<T> : IEnumerable<T>\n")),(0,i.kt)("p",{parentName:"admonition"},"While ",(0,i.kt)("inlineCode",{parentName:"p"},"[ZLinqDropInExtension]")," works with classes implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),", implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"IValueEnumerable<TEnumerator, T>")," provides zero-allocation optimization for ZLinq:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"[ZLinqDropInExtension]\npublic class AddOnlyIntList2 : IValueEnumerable<AddOnlyIntList2.Enumerator, int>\n{\n    List<int> list = new List<int>();\n\n    public void Add(int x) => list.Add(x);\n\n    public ValueEnumerable<FromValueEnumerable<Enumerator, int>, int> AsValueEnumerable()\n    {\n        // you need to write new(new(new())) magic.\n        return new(new(new(list)));\n    }\n\n    // `public` struct enumerator\n    public struct Enumerator(List<int> source) : IValueEnumerator<int>\n    {\n        int index;\n\n        public bool TryGetNonEnumeratedCount(out int count)\n        {\n            count = source.Count;\n            return true;\n        }\n\n        public bool TryGetSpan(out ReadOnlySpan<int> span)\n        {\n            span = CollectionsMarshal.AsSpan(source);\n            return true;\n        }\n\n        public bool TryCopyTo(scoped Span<int> destination, Index offset)\n        {\n            // Optional path: if you can not write this, always return false is ok.\n            ReadOnlySpan<int> span = CollectionsMarshal.AsSpan(source);\n            if (ZLinq.Internal.EnumeratorHelper.TryGetSlice(span, offset, destination.Length, out var slice))\n            {\n                slice.CopyTo(destination);\n                return true;\n\n            }\n            return false;\n        }\n\n        public bool TryGetNext(out int current)\n        {\n            if (index < source.Count)\n            {\n                current = source[index];\n                index++;\n                return true;\n            }\n\n            current = default;\n            return false;\n        }\n\n        public void Dispose() { }\n    }\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"In this case, implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," is not necessary. If a collection implements both ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"IValueEnumerable<TEnumerator, T>"),", the latter takes precedence."),(0,i.kt)("h2",{parentName:"admonition",id:"linq-to-tree"},"LINQ to Tree"),(0,i.kt)("p",{parentName:"admonition"},"LINQ to XML introduced the concept of querying around axes to C#. Even if you don't use XML, similar APIs are incorporated into Roslyn and effectively used for exploring SyntaxTrees. ZLinq extends this concept to make it applicable to anything that can be considered a Tree, allowing ",(0,i.kt)("inlineCode",{parentName:"p"},"Ancestors"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Children"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Descendants"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"BeforeSelf"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"AfterSelf")," to be applied."),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("img",{parentName:"p",src:"https://github.com/Cysharp/ZLinq/img/axis.jpg",alt:null})),(0,i.kt)("p",{parentName:"admonition"},"Specifically, by defining a struct that implements the following interface, it becomes iterable:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public interface ITraverser<TTraverser, T> : IDisposable\n    where TTraverser : struct, ITraverser<TTraverser, T> // self\n{\n    T Origin { get; }\n    TTraverser ConvertToTraverser(T next); // for Descendants\n    bool TryGetHasChild(out bool hasChild); // optional: optimize use for Descendants\n    bool TryGetChildCount(out int count);   // optional: optimize use for Children\n    bool TryGetParent(out T parent); // for Ancestors\n    bool TryGetNextChild(out T child); // for Children | Descendants\n    bool TryGetNextSibling(out T next); // for AfterSelf\n    bool TryGetPreviousSibling(out T previous); // BeforeSelf\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"Standard packages are available for FileSystemInfo and JsonNode. For Unity, it's applicable to GameObject and Transform."),(0,i.kt)("h3",{parentName:"admonition",id:"filesystem"},"FileSystem"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet add package ZLinq.FileSystem\n")),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using ZLinq;\n\nvar root = new DirectoryInfo("C:\\\\Program Files (x86)\\\\Steam");\n\n// FileSystemInfo(FileInfo/DirectoryInfo) can call `Ancestors`, `Children`, `Descendants`, `BeforeSelf`, `AfterSelf`\nvar allDlls = root\n    .Descendants()\n    .OfType<FileInfo>()\n    .Where(x => x.Extension == ".dll");\n\nvar grouped = allDlls\n    .GroupBy(x => x.Name)\n    .Select(x => new { FileName = x.Key, Count = x.Count() })\n    .OrderByDescending(x => x.Count);\n\nforeach (var item in grouped)\n{\n    Console.WriteLine(item);\n}\n')),(0,i.kt)("h3",{parentName:"admonition",id:"jsonsystemtextjson"},"JSON(System.Text.Json)"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet add package ZLinq.Json\n")),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using ZLinq;\n\n// System.Text.Json\'s JsonNode is the target of LINQ to JSON(not JsonDocument/JsonElement).\nvar json = JsonNode.Parse("""\n{\n    "nesting": {\n      "level1": {\n        "description": "First level of nesting",\n        "value": 100,\n        "level2": {\n          "description": "Second level of nesting",\n          "flags": [true, false, true],\n          "level3": {\n            "description": "Third level of nesting",\n            "coordinates": {\n              "x": 10.5,\n              "y": 20.75,\n              "z": -5.0\n            },\n            "level4": {\n              "description": "Fourth level of nesting",\n              "metadata": {\n                "created": "2025-02-15T14:30:00Z",\n                "modified": null,\n                "version": 2.1\n              },\n              "level5": {\n                "description": "Fifth level of nesting",\n                "settings": {\n                  "enabled": true,\n                  "threshold": 0.85,\n                  "options": ["fast", "accurate", "balanced"],\n                  "config": {\n                    "timeout": 30000,\n                    "retries": 3,\n                    "deepSetting": {\n                      "algorithm": "advanced",\n                      "parameters": [1, 1, 2, 3, 5, 8, 13]\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n}\n""");\n\n// JsonNode\nvar origin = json!["nesting"]!["level1"]!["level2"]!;\n\n// JsonNode axis, Children, Descendants, Anestors, BeforeSelf, AfterSelf and ***Self.\nforeach (var item in origin.Descendants().Select(x => x.Node).OfType<JsonArray>())\n{\n    // [true, false, true], ["fast", "accurate", "balanced"], [1, 1, 2, 3, 5, 8, 13]\n    Console.WriteLine(item.ToJsonString(JsonSerializerOptions.Web));\n}\n')),(0,i.kt)("h3",{parentName:"admonition",id:"gameobjecttransformunity"},"GameObject/Transform(Unity)"),(0,i.kt)("p",{parentName:"admonition"},"see: ",(0,i.kt)("a",{parentName:"p",href:"#unity"},"unity")," section."),(0,i.kt)("h2",{parentName:"admonition",id:"linq-to-simd"},"LINQ to SIMD"),(0,i.kt)("p",{parentName:"admonition"},"In .NET 8 and above, there are operators that apply SIMD when ",(0,i.kt)("inlineCode",{parentName:"p"},"ValueEnumerable<T>.TryGetSpan")," returns true. The scope of application is wider than in regular System.Linq."),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Range")," to ToArray/ToList/CopyTo/etc..."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Repeat")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"unmanaged struct")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"size is power of 2")," to ToArray/ToList/CopyTo/etc..."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Sum")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"sbyte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"short"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"long"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"byte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ushort"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"uint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ulong"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"double")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"SumUnchecked")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"sbyte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"short"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"long"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"byte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ushort"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"uint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ulong"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"double")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Average")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"sbyte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"short"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"long"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"byte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ushort"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"uint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ulong"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"double")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Max")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"byte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"sbyte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"short"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ushort"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"uint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"long"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ulong"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"nint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"nuint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Int128"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"UInt128")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Min")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"byte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"sbyte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"short"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ushort"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"uint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"long"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ulong"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"nint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"nuint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Int128"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"UInt128")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Contains")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"byte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"sbyte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"short"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ushort"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"uint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"long"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ulong"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"char"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"nint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"nuint")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"SequenceEqual")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"byte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"sbyte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"short"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ushort"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"uint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"long"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ulong"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"char"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"nint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"nuint"))),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"Sum")," performs calculations as checked, but if you don't need to worry about overflow, using ",(0,i.kt)("inlineCode",{parentName:"p"},"SumUnchecked")," is faster."),(0,i.kt)("table",{parentName:"admonition"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Method"),(0,i.kt)("th",{parentName:"tr",align:null},"N"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Mean"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Allocated"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ForLoop"),(0,i.kt)("td",{parentName:"tr",align:null},"16384"),(0,i.kt)("td",{parentName:"tr",align:"right"},"25,198.556 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SystemLinqSum"),(0,i.kt)("td",{parentName:"tr",align:null},"16384"),(0,i.kt)("td",{parentName:"tr",align:"right"},"1,402.259 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZLinqSum"),(0,i.kt)("td",{parentName:"tr",align:null},"16384"),(0,i.kt)("td",{parentName:"tr",align:"right"},"1,351.449 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZLinqSumUnchecked"),(0,i.kt)("td",{parentName:"tr",align:null},"16384"),(0,i.kt)("td",{parentName:"tr",align:"right"},"721.832 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"-")))),(0,i.kt)("p",{parentName:"admonition"},"By using ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinq.Simd")," in your using statements, you can call ",(0,i.kt)("inlineCode",{parentName:"p"},".AsVectorizable()")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"T[]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Span<T>")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadOnlySpan<T>"),", which allows you to use ",(0,i.kt)("inlineCode",{parentName:"p"},"Sum"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"SumUnchecked"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Average"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Max"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Min"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Contains"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"SequenceEqual"),". This explicitly indicates execution with SIMD regardless of the LINQ chain state (though type checking is ambiguous so processing might occur in a normal loop, and if ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector.IsHardwareAccelerated && Vector<T>.IsSupported")," is false, normal loop processing will be used)."),(0,i.kt)("p",{parentName:"admonition"},"From ",(0,i.kt)("inlineCode",{parentName:"p"},"int[]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Span<int>"),", you can call ",(0,i.kt)("inlineCode",{parentName:"p"},"VectorizedFillRange"),". This is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"ValueEunmerable.Range().CopyTo()")," and allows you to quickly generate sequential numbers through SIMD processing."),(0,i.kt)("table",{parentName:"admonition"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Method"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Mean"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Allocated"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Range"),(0,i.kt)("td",{parentName:"tr",align:"right"},"540.0 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"For"),(0,i.kt)("td",{parentName:"tr",align:"right"},"6,228.9 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"-")))),(0,i.kt)("h3",{parentName:"admonition",id:"vectorizedupdate"},(0,i.kt)("inlineCode",{parentName:"h3"},"VectorizedUpdate")),(0,i.kt)("p",{parentName:"admonition"},"In ZLinq, you can perform relatively flexible vectorized loop processing using ",(0,i.kt)("inlineCode",{parentName:"p"},"Func"),". With ",(0,i.kt)("inlineCode",{parentName:"p"},"T[]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Span<T>"),", you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"VectorizedUpdate")," method. By writing two lambda expressions - ",(0,i.kt)("inlineCode",{parentName:"p"},"Func<Vector<T>, Vector<T>> vectorFunc")," for vector operations and ",(0,i.kt)("inlineCode",{parentName:"p"},"Func<T, T> func")," for handling remainder elements - you can perform loop update processing at SIMD width."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"using ZLinq.Simd; // needs using\n\nint[] source = Enumerable.Range(0, 10000).ToArray();\n\n[Benchmark]\npublic void For()\n{\n    for (int i = 0; i < source.Length; i++)\n    {\n        source[i] = source[i] * 10;\n    }\n}\n\n[Benchmark]\npublic void VectorizedUpdate()\n{\n    // arg1: Vector<int> => Vector<int>\n    // arg2: int => int\n    source.VectorizedUpdate(static x => x * 10, static x => x * 10);\n}\n")),(0,i.kt)("table",{parentName:"admonition"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Method"),(0,i.kt)("th",{parentName:"tr",align:null},"N"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Mean"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Error"),(0,i.kt)("th",{parentName:"tr",align:"right"},"StdDev"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Allocated"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"For"),(0,i.kt)("td",{parentName:"tr",align:null},"10000"),(0,i.kt)("td",{parentName:"tr",align:"right"},"4,560.5 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"67.24 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"3.69 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"VectorizedUpdate"),(0,i.kt)("td",{parentName:"tr",align:null},"10000"),(0,i.kt)("td",{parentName:"tr",align:"right"},"558.9 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"6.42 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"0.35 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"-")))),(0,i.kt)("p",{parentName:"admonition"},"There is delegate overhead when compared to writing everything inline, but processing can be faster than using for-loops. However, this varies case by case, so please take measurements in advance based on your data volume and method content. Of course, if you're seeking the best possible performance, you should write code inline."),(0,i.kt)("h3",{parentName:"admonition",id:"vectorizable-methods"},"Vectorizable Methods"),(0,i.kt)("p",{parentName:"admonition"},"You can convert from ",(0,i.kt)("inlineCode",{parentName:"p"},"T[]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Span<T>")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadOnlySpan<T>")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Vectorizable<T>")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"AsVectorizable()"),", which allows you to use ",(0,i.kt)("inlineCode",{parentName:"p"},"Aggregate"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"All"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Any"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Count"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Select"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Zip")," methods that accept a ",(0,i.kt)("inlineCode",{parentName:"p"},"Func")," as an argument."),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Aggregate"))),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"source.AsVectorizable().Aggregate((x, y) => Vector.Min(x, y), (x, y) => Math.Min(x, y))\n")),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"All"))),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"source.AsVectorizable().All(x => Vector.GreaterThanAll(x, new(5000)), x => x > 5000);\n")),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Any"))),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"source.AsVectorizable().Any(x => Vector.LessThanAll(x, new(5000)), x => x < 5000);\n")),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Count"))),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"source.AsVectorizable().Count(x => Vector.GreaterThan(x, new(5000)), x => x > 5000);\n")),(0,i.kt)("table",{parentName:"admonition"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Method"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Mean"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Error"),(0,i.kt)("th",{parentName:"tr",align:"right"},"StdDev"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Allocated"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"VectorizableCount"),(0,i.kt)("td",{parentName:"tr",align:"right"},"1,048.4 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"39.39 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"2.16 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"LinqCount"),(0,i.kt)("td",{parentName:"tr",align:"right"},"10,909.3 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"54.79 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"3.00 ns"),(0,i.kt)("td",{parentName:"tr",align:"right"},"-")))),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Select")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"ToArray")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"CopyTo"))),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"source.AsVectorizable().Select(x => x * 3, x => x * 3).ToArray();\nsource.AsVectorizable().Select(x => x * 3, x => x * 3).CopyTo(destination);\n")),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Zip")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"ToArray")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"CopyTo"))),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// Zip2\narray1.AsVectorizable().Zip(array2, (x, y) => x + y, (x, y) => x + y).CopyTo(destination);\narray1.AsVectorizable().Zip(array2, (x, y) => x + y, (x, y) => x + y).ToArray();\n\n// Zip3\narray1.AsVectorizable().Zip(array2, array3, (x, y, z) => x + y + z, (x, y, z) => x + y + z).CopyTo(destination);\narray1.AsVectorizable().Zip(array2, array3, (x, y, z) => x + y + z, (x, y, z) => x + y + z).ToArray();\n")),(0,i.kt)("table",{parentName:"admonition"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Method"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Mean"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZLinqVectorizableZipCopyTo"),(0,i.kt)("td",{parentName:"tr",align:"right"},"24.17 \u03bcs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZLinqVectorizableZip3CopyTo"),(0,i.kt)("td",{parentName:"tr",align:"right"},"29.26 \u03bcs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZLinqZipCopyTo"),(0,i.kt)("td",{parentName:"tr",align:"right"},"329.43 \u03bcs")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZLinqZip3CopyTo"),(0,i.kt)("td",{parentName:"tr",align:"right"},"584.69 \u03bcs")))),(0,i.kt)("h2",{parentName:"admonition",id:"unity"},"Unity"),(0,i.kt)("p",{parentName:"admonition"},"There are two installation steps required to use it in Unity."),(0,i.kt)("ol",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Install ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinq")," from NuGet using ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/GlitchEnzo/NuGetForUnity"},"NuGetForUnity"),'\nOpen Window from NuGet -> Manage NuGet Packages, Search "ZLinq" and Press Install.')),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Install the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinq.Unity")," package by referencing the git URL"))),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"https://github.com/Cysharp/ZLinq.git?path=src/ZLinq.Unity/Assets/ZLinq.Unity\n")),(0,i.kt)("p",{parentName:"admonition"},"With the help of the Unity package, in addition to the standard ZLinq, LINQ to GameObject functionality becomes available for exploring GameObject/Transform."),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("img",{parentName:"p",src:"https://github.com/Cysharp/ZLinq/img/axis.jpg",alt:null})),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using ZLinq;\n\npublic class SampleScript : MonoBehaviour\n{\n    public Transform Origin;\n\n    void Start()\n    {\n        Debug.Log("Ancestors--------------");  // Container, Root\n        foreach (var item in Origin.Ancestors()) Debug.Log(item.name);\n\n        Debug.Log("Children--------------"); // Sphere_A, Sphere_B, Group, Sphere_A, Sphere_B\n        foreach (var item in Origin.Children()) Debug.Log(item.name);\n\n        Debug.Log("Descendants--------------"); // Sphere_A, Sphere_B, Group, P1, Group, Sphere_B, P2, Sphere_A, Sphere_B\n        foreach (var item in Origin.Descendants()) Debug.Log(item.name);\n\n        Debug.Log("BeforeSelf--------------"); // C1, C2\n        foreach (var item in Origin.BeforeSelf()) Debug.Log(item.name);\n\n        Debug.Log("AfterSelf--------------");  // C3, C4\n        foreach (var item in Origin.AfterSelf()) Debug.Log(item.name);\n    }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"You can chain query(LINQ to Objects). Also, you can filter by component using the ",(0,i.kt)("inlineCode",{parentName:"p"},"OfComponent<T>")," helper."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'// all filtered(tag == "foobar") objects\nvar foobars = root.Descendants().Where(x => x.tag == "foobar");\n\n// get FooScript under self childer objects and self\nvar fooScripts = root.ChildrenAndSelf().OfComponent<FooScript>();\n')),(0,i.kt)("p",{parentName:"admonition"},"UI Toolkit VisualElements are also supported allowing more advanced queries"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class SampleScript : MonoBehaviour\n{\n    private UIDocument Document;\n\n    private void Start()\n    {\n        var noTextButtons = Document\n            .rootVisualElement\n            .Descendants()\n            .OfType<Button>()\n            .Where(btn => string.IsNullOrEmpty(btn.text));\n\n        foreach (var btn in noTextButtons) Debug.Log(btn.name);\n    }\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"NOTE: In Unity, since .NET Standard 2.1 is referenced, SIMD is not utilized."),(0,i.kt)("p",{parentName:"admonition"},"In .NET 9, ",(0,i.kt)("inlineCode",{parentName:"p"},"ValueEnumerable")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"ref struct"),", so it cannot be converted to ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),". However, in Unity it's a regular ",(0,i.kt)("inlineCode",{parentName:"p"},"struct"),", making it possible to convert to ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),". You can improve interoperability by preparing an extension method like this:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public static class ZLinqExtensions\n{\n    public static IEnumerable<T> AsEnumerable<TEnumerator, T>(this ValueEnumerable<TEnumerator, T> valueEnumerable)\n        where TEnumerator : struct, IValueEnumerator<T>\n    {\n        using (var e = valueEnumerable.Enumerator)\n        {\n            while (e.TryGetNext(out var current))\n            {\n                yield return current;\n            }\n        }\n    }\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"In Unity, you can convert ",(0,i.kt)("inlineCode",{parentName:"p"},"NativeArray"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"NativeSlice")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"AsEnumerable()")," to write queries with ZLinq. If Unity Collections(",(0,i.kt)("inlineCode",{parentName:"p"},"com.unity.collections"),") package version is ",(0,i.kt)("inlineCode",{parentName:"p"},"2.1.1")," or above,  ",(0,i.kt)("inlineCode",{parentName:"p"},"NativeQueue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"NativeHashSet"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"NativeText"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedList32Bytes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedList64Bytes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedList128Bytes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedList512Bytes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedList4096Bytes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedString32Bytes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedString64Bytes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedString128Bytes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedString512Bytes"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedString4096Bytes")," support ",(0,i.kt)("inlineCode",{parentName:"p"},"AsValueEnumerable()"),"."),(0,i.kt)("p",{parentName:"admonition"},"You can also use drop-in replacement. Add ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinq.DropInGenerator")," from NuGetForUnity. If you want to use DropInGenerator, the minimum supported Unity version will be ",(0,i.kt)("inlineCode",{parentName:"p"},"2022.3.12f1"),", as it is necessary to support C# Incremental Source Generator(Compiler Version, 4.3.0)."),(0,i.kt)("p",{parentName:"admonition"},"Assembly attributes need to be set for each asmdef. For example, place a ",(0,i.kt)("inlineCode",{parentName:"p"},".cs")," file like the following in each asmdef. The DropInGenerator is defined in the assembly attributes."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'// AssemblyAttributes.cs\nusing ZLinq;\n[assembly: ZLinqDropIn("MyApp", DropInGenerateTypes.Array | DropInGenerateTypes.List)]\n')),(0,i.kt)("p",{parentName:"admonition"},"For more details about DropInGenerator, please refer to the ",(0,i.kt)("a",{parentName:"p",href:"#drop-in-replacement"},"Drop-in replacement")," section."),(0,i.kt)("p",{parentName:"admonition"},"To support Native Collections in addition to regular DropIn types, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"ZLinqDropInExternalExtension")," as follows:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[assembly: ZLinqDropInExternalExtension("ZLinq", "Unity.Collections.NativeArray`1", "ZLinq.Linq.FromNativeArray`1")]\n[assembly: ZLinqDropInExternalExtension("ZLinq", "Unity.Collections.NativeArray`1+ReadOnly", "ZLinq.Linq.FromNativeArray`1")]\n[assembly: ZLinqDropInExternalExtension("ZLinq", "Unity.Collections.NativeSlice`1", "ZLinq.Linq.FromNativeSlice`1")]\n[assembly: ZLinqDropInExternalExtension("ZLinq", "Unity.Collections.NativeList`1", "ZLinq.Linq.FromNativeList`1")]\n')),(0,i.kt)("p",{parentName:"admonition"},"This is not just about Unity, but using ",(0,i.kt)("inlineCode",{parentName:"p"},"AsValueEnumerable()")," even if only for foreach on ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," can sometimes reduce allocations. If the actual implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"T[]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>"),", ZLinq will process it appropriately without allocations."),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("img",{parentName:"p",src:"https://github.com/Cysharp/ZLinq/img/unityforeach.png",alt:null})),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"void IterateNormal(IEnumerable<int> source)\n{\n    // Normally there's an allocation when getting IEnumerator<T>.\n    foreach (var item in source)\n    {\n\n    }\n}\n\nvoid IterateZLinq(IEnumerable<int> source)\n{\n    // Adding AsValueEnumerable results in 0 allocation.\n    // However, zero alloc only works when the actual implementation of IEnumerable<T> is an array [] or List<T>\n    foreach (var item in source.AsValueEnumerable())\n    {\n\n    }\n}\n")),(0,i.kt)("h2",{parentName:"admonition",id:"godot"},"Godot"),(0,i.kt)("p",{parentName:"admonition"},"The minimum supported Godot version will be ",(0,i.kt)("inlineCode",{parentName:"p"},"4.0.0"),".\nYou can install ZLinq.Godot package via NuGet."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet add package ZLinq.Godot\n")),(0,i.kt)("p",{parentName:"admonition"},"In addition to the standard ZLinq, LINQ to Node functionality is available."),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("img",{parentName:"p",src:"https://github.com/Cysharp/ZLinq/img/godot.jpg",alt:null})),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using Godot;\nusing ZLinq;\n\npublic partial class SampleScript : Node2D\n{\n    public override void _Ready()\n    {\n        var origin = GetNode<Node2D>("Container/Origin");\n\n        GD.Print("Ancestors--------------"); // Container, Root, root (Root Window)\n        foreach (var item in origin.Ancestors()) GD.Print(item.Name);\n\n        GD.Print("Children--------------"); // Sphere_A, Sphere_B, Group, Sphere_A, Sphere_B\n        foreach (var item in origin.Children()) GD.Print(item.Name);\n\n        GD.Print("Descendants--------------"); // Sphere_A, Sphere_B, Group, P1, Group, Sphere_B, P2, Sphere_A, Sphere_B\n        foreach (var item in origin.Descendants()) GD.Print(item.Name);\n\n        GD.Print("BeforeSelf--------------"); // C1, C2\n        foreach (var item in origin.BeforeSelf()) GD.Print(item.Name);\n\n        GD.Print("AfterSelf--------------"); // C3, C4\n        foreach (var item in origin.AfterSelf()) GD.Print(item.Name);\n    }\n}\n\n')),(0,i.kt)("p",{parentName:"admonition"},"You can chain query(LINQ to Objects). Also, you can filter by node type using the ",(0,i.kt)("inlineCode",{parentName:"p"},"OfType()"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// get ancestors under a Window\nvar ancestors = root.Ancestors().TakeWhile(x => x is not Window);\n// get FooScript under self childer objects and self\nvar fooScripts = root.ChildrenAndSelf().OfType<FooScript>();\n")),(0,i.kt)("h2",{parentName:"admonition",id:"custom-extensions"},"Custom Extensions"),(0,i.kt)("p",{parentName:"admonition"},"Implementing extension methods for ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," is common. There are two types of operators: consuming operators like ",(0,i.kt)("inlineCode",{parentName:"p"},"Count")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Sum"),", and chainable operators like ",(0,i.kt)("inlineCode",{parentName:"p"},"Select")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Where"),". This section explains how to implement them."),(0,i.kt)("h4",{parentName:"admonition",id:"consume-operator"},"Consume Operator"),(0,i.kt)("p",{parentName:"admonition"},"The method signature is slightly more complex compared to ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),", requiring constraints on ",(0,i.kt)("inlineCode",{parentName:"p"},"TEnumerator"),". For .NET 9 or later, ",(0,i.kt)("inlineCode",{parentName:"p"},"allows ref struct")," is also needed."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public static class MyExtensions\n{\n    public static void Consume<TEnumerator, TSource>(this ValueEnumerable<TEnumerator, TSource> source)\n        where TEnumerator : struct, IValueEnumerator<TSource>\n#if NET9_0_OR_GREATER\n        , allows ref struct\n#endif\n    {\n        using var e = source.Enumerator; // using Enumerator\n\n        while (e.TryGetNext(out var current)) // MoveNext + Current\n        {\n        }\n    }\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"Instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"GetEnumerator()"),", use ",(0,i.kt)("inlineCode",{parentName:"p"},"Enumerator"),", and instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"MoveNext + Current"),", use ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetNext(out)")," to consume the iterator. The Enumerator must be used with ",(0,i.kt)("inlineCode",{parentName:"p"},"using"),"."),(0,i.kt)("p",{parentName:"admonition"},"Consumers can call the Enumerator's optimization methods: ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetNonEnumeratedCount"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetSpan"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCopyTo"),". For example, getting a Span like this is faster than normal iteration with TryGetNext:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public static class MyExtensions\n{\n    public static void ForEach<TEnumerator, TSource>(this ValueEnumerable<TEnumerator, TSource> source, Action<TSource> action)\n        where TEnumerator : struct, IValueEnumerator<TSource>\n#if NET9_0_OR_GREATER\n        , allows ref struct\n#endif\n    {\n        using var e = source.Enumerator;\n\n        if (e.TryGetSpan(out var span))\n        {\n            // faster iteration\n            foreach (var item in span)\n            {\n                action(item);\n            }\n        }\n        else\n        {\n            while (e.TryGetNext(out var item))\n            {\n                action(item);\n            }\n        }\n    }\n\n    public static ImmutableArray<T> ToImmutableArray<TEnumerator, T>(this ValueEnumerable<TEnumerator, T> source)\n        where TEnumerator : struct, IValueEnumerator<T>\n#if NET9_0_OR_GREATER\n        , allows ref struct\n#endif\n    {\n        using var e = source.Enumerator;\n\n        if (e.TryGetSpan(out var span))\n        {\n            return ImmutableArray.Create(span);\n        }\n        else\n        {\n            if (e.TryGetNonEnumeratedCount(out var count))\n            {\n                var array = GC.AllocateUninitializedArray<TSource>(count);\n\n                if (e.TryCopyTo(array, offset: 0))\n                {\n                    return ImmutableCollectionsMarshal.AsImmutableArray(array);\n                }\n                else\n                {\n                    var i = 0;\n                    while (e.TryGetNext(out var current))\n                    {\n                        array[i] = current;\n                        i++;\n                    }\n                    return ImmutableCollectionsMarshal.AsImmutableArray(array);\n                }\n            }\n            else\n            {\n                var builder = ImmutableArray.CreateBuilder<TSource>();\n                while (e.TryGetNext(out var current))\n                {\n                    builder.Add(current);\n                }\n                return builder.ToImmutable();\n            }\n        }\n    }\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"Since the enumerator's state changes, you cannot call other methods after calling ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetNext"),". Also, you cannot call ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetNext")," after ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCopyTo")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetSpan")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)("h4",{parentName:"admonition",id:"custom-operator"},"Custom Operator"),(0,i.kt)("p",{parentName:"admonition"},"Unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),", you can't use ",(0,i.kt)("inlineCode",{parentName:"p"},"yield return"),", so everything must be implemented by hand, making it more difficult than Consume operators. A simple ",(0,i.kt)("inlineCode",{parentName:"p"},"Select")," implementation looks like this. For .NET 9 or later, ",(0,i.kt)("inlineCode",{parentName:"p"},"IValueEnumerator<T>")," must be implemented as a ",(0,i.kt)("inlineCode",{parentName:"p"},"ref struct"),". Also, the accessibility must be ",(0,i.kt)("inlineCode",{parentName:"p"},"public")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"internal"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public static class MyExtensions\n{\n    public static ValueEnumerable<SimpleSelect<TEnumerator, TSource, TResult>, TResult> SimpleSelect<TEnumerator, TSource, TResult>(this ValueEnumerable<TEnumerator, TSource> source, Func<TSource, TResult> selector)\n        where TEnumerator : struct, IValueEnumerator<TSource>\n#if NET9_0_OR_GREATER\n        , allows ref struct\n#endif\n    {\n        // ValueEnumerable is only a wrapper so unwrapping to enumerator immediately is ok.\n        // `new(new())` is `new ValueEnumerable(new SimpleSelect())`, wrap enumerator to ValueEnumerable.\n        return new(new(source.Enumerator, selector));\n    }\n}\n\n#if NET9_0_OR_GREATER\npublic ref struct\n#else\npublic struct\n#endif\n    SimpleSelect<TEnumerator, TSource, TResult>(TEnumerator source, Func<TSource, TResult> selector) : IValueEnumerator<TResult>\n        where TEnumerator : struct, IValueEnumerator<TSource>\n#if NET9_0_OR_GREATER\n        , allows ref struct\n#endif\n{\n    TEnumerator source = source; // need to store source enumerator in field explicitly (ref struct limitation)\n\n    // Having fields is allowed, but reference types must be null during initialization.\n    // For example, if you hold a reference type in the constructor, it will be shared with other Enumerators and will not work correctly.\n\n    public bool TryGetNonEnumeratedCount(out int count)\n    {\n        // If source count is not changed, return count.\n        // Select count is same as source.\n        return source.TryGetNonEnumeratedCount(out count);\n    }\n\n    public bool TryGetSpan(out ReadOnlySpan<TResult> span)\n    {\n        // For example, Take or Skip could return a Slice\n        span = default;\n        return false;\n    }\n\n    public bool TryCopyTo(scoped Span<TResult> destination, Index offset)\n    {\n        // TryCopyTo implementation needs to consider Index calculations, so it's quite complex.\n        // Also, destination can be smaller than the source size.\n        // Helper methods for calculations are available in ZLinq.Internal.EnumeratorHelper,\n        // such as TryGetSliceRange, TryGetSlice, TryGetSliceRange, TryConsumeGetAt, etc.\n        return false;\n    }\n\n    // This is the main body of the normal processing\n    public bool TryGetNext(out TResult current)\n    {\n        while (source.TryGetNext(out var value))\n        {\n            current = selector(value);\n            return true;\n        }\n\n        current = default!;\n        return false;\n    }\n\n    public void Dispose()\n    {\n        // Always dispose the source\n        source.Dispose();\n    }\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"For ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetNonEnumeratedCount"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetSpan"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"TryCopyTo"),", it's fine to return ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," if implementation is difficult. If state is needed (for example, Take needs to keep track of the number of calls), place it in a field, but note that you should not initialize reference types or structs containing reference types in the constructor. This is because in method chains, Enumerators are passed by copy, so reference types would share references. If you need to hold reference types, they must be initialized when ",(0,i.kt)("inlineCode",{parentName:"p"},"TryGetNext")," is first called."),(0,i.kt)("h2",{parentName:"admonition",id:"acknowledgement"},"Acknowledgement"),(0,i.kt)("p",{parentName:"admonition"},"Since the preview version release, we have received multiple ideas for fundamental interface revisions leading to performance improvements from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Akeit0"},"@Akeit0"),", and test and benchmark infrastructure from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/filzrev"},"@filzrev"),". We are grateful for their many contributions."),(0,i.kt)("h2",{parentName:"admonition",id:"license"},"License"),(0,i.kt)("p",{parentName:"admonition"},"This library is under MIT License.")),(0,i.kt)("h3",{id:"about"},"About"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"}," zero allocations for LINQ operations, high performance, functional programming")),(0,i.kt)("h2",{id:"how-to-use"},"How to use"),(0,i.kt)("h3",{id:"example-source-csproj-source-files"},"Example (source csproj, source files)"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,i.kt)("p",null,"This is the CSharp Project that references ",(0,i.kt)("strong",{parentName:"p"},"zlinq")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {12}",showLineNumbers:!0,"{12}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net9.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n<ItemGroup>\n    \n    <PackageReference Include="ZLinq" Version="1.4.8" />\n    <PackageReference Include="ZLinq.DropInGenerator" Version="1.4.8">\n      <PrivateAssets>all</PrivateAssets>\n      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n    </PackageReference>\n  </ItemGroup>\n  <PropertyGroup>\n    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n    <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n  </PropertyGroup>\n\n</Project>\n\n'))),(0,i.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\zlinq\\src\\zlinqDemo\\zlinqDemo\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,i.kt)("p",null,"  This is the use of ",(0,i.kt)("strong",{parentName:"p"},"zlinq")," in ",(0,i.kt)("em",{parentName:"p"},"Program.cs")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using ZLinq;\n// https://github.com/Cysharp/ZLinq\nConsole.WriteLine("Hello, World!");\nvar x = Enumerable.Range(1, 10)\n    .Select(x => x * 2)\n    ;\n\n\nvar y = x.ToArray();\nforeach (var item in x)\n{\n    Console.WriteLine(item);\n}\n')))),(0,i.kt)("h3",{id:"generated-files"},"Generated Files"),(0,i.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,i.kt)("h2",{id:"useful"},"Useful"),(0,i.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{target:"_blank",href:t(12010).Z},"Download Example project zlinq "))),(0,i.kt)("h3",{id:"share-zlinq"},"Share zlinq"),(0,i.kt)("ul",null,(0,i.kt)("li",null,(0,i.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2Fzlinq&quote=zlinq",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,i.kt)("li",null,(0,i.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2Fzlinq&text=zlinq:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2Fzlinq",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,i.kt)("li",null,(0,i.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2Fzlinq&title=zlinq",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,i.kt)("li",null,(0,i.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2Fzlinq&title=zlinq&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2Fzlinq",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/zlinq"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/zlinq")),(0,i.kt)("h3",{id:"in-the-same-category-linq---0-other-generators"},"In the same category (Linq) - 0 other generators"))}N.isMDXComponent=!0},12010:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/zlinq-e8f8db06e81b6856140c0cbd4f0c416c.zip"}}]);