"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[6715],{18329:(e,t,n)=>{n.d(t,{Ay:()=>l,RM:()=>a});var r=n(74848),s=n(28453);const a=[{value:"Category &quot;Database&quot; has the following generators:",id:"category-database-has-the-following-generators",level:3},{value:"See category",id:"see-category",level:3}];function i(e){const t={a:"a",h3:"h3",p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h3,{id:"category-database-has-the-following-generators",children:'Category "Database" has the following generators:'}),"\n",(0,r.jsxs)(t.p,{children:["1 ",(0,r.jsx)(t.a,{href:"/docs/Breezy",children:"Breezy"})]}),"\n",(0,r.jsxs)(t.p,{children:["2 ",(0,r.jsx)(t.a,{href:"/docs/Dapper.AOT",children:"Dapper.AOT"})]}),"\n",(0,r.jsxs)(t.p,{children:["3 ",(0,r.jsx)(t.a,{href:"/docs/EntityLengths.Generator",children:"EntityLengths.Generator"})]}),"\n",(0,r.jsxs)(t.p,{children:["4 ",(0,r.jsx)(t.a,{href:"/docs/Finch.Generators",children:"Finch.Generators"})]}),"\n",(0,r.jsxs)(t.p,{children:["5 ",(0,r.jsx)(t.a,{href:"/docs/Gedaq",children:"Gedaq"})]}),"\n",(0,r.jsxs)(t.p,{children:["6 ",(0,r.jsx)(t.a,{href:"/docs/TableStorage",children:"TableStorage"})]}),"\n",(0,r.jsxs)(t.p,{children:["7 ",(0,r.jsx)(t.a,{href:"/docs/Unflat",children:"Unflat"})]}),"\n",(0,r.jsx)(t.h3,{id:"see-category",children:"See category"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"/docs/Categories/Database",children:"Database"})})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}},20682:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>h,default:()=>m,frontMatter:()=>c,metadata:()=>r,toc:()=>p});const r=JSON.parse('{"id":"RSCG-Examples/Unflat","title":"230 - Unflat","description":"DataReader to Object Model","source":"@site/docs/RSCG-Examples/Unflat.md","sourceDirName":"RSCG-Examples","slug":"/Unflat","permalink":"/RSCG_Examples/v2/docs/Unflat","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2300,"frontMatter":{"sidebar_position":2300,"title":"230 - Unflat","description":"DataReader to Object Model","slug":"/Unflat"},"sidebar":"tutorialSidebar","previous":{"title":"229 - Facet","permalink":"/RSCG_Examples/v2/docs/Facet"},"next":{"title":"231 - kli.Localize","permalink":"/RSCG_Examples/v2/docs/kli.Localize"}}');var s=n(74848),a=n(28453),i=n(11470),l=n(19365),d=n(14252),o=n(18329);const c={sidebar_position:2300,title:"230 - Unflat",description:"DataReader to Object Model",slug:"/Unflat"},h="Unflat  by pstlnce",u={},p=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Author",id:"author",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"How To Use",id:"how-to-use",level:2},{value:"Generating Parser",id:"generating-parser",level:3},{value:"Custom Converters",id:"custom-converters",level:3},{value:"Per Property/Field converter",id:"per-propertyfield-converter",level:3},{value:"SplitOn, Column Prefix",id:"spliton-column-prefix",level:3},{value:"Per Property/Field Field Source",id:"per-propertyfield-field-source",level:3},{value:"Planned Features / Limitations",id:"planned-features--limitations",level:2},{value:"Perfomane",id:"perfomane",level:2},{value:"Raw test against Dapper",id:"raw-test-against-dapper",level:4},{value:"What&#39;s the purpose?",id:"whats-the-purpose",level:2},{value:"What About Other Libraries?",id:"what-about-other-libraries",level:2},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use-1",level:2},{value:"Example (source csproj, source files)",id:"example-source-csproj-source-files",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C#)",id:"download-example-net--c",level:3},{value:"Share Unflat",id:"share-unflat",level:3},...o.RM];function g(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"unflat--by-pstlnce",children:"Unflat  by pstlnce"})}),"\n",(0,s.jsx)(d.A,{toc:p}),"\n",(0,s.jsx)(t.h2,{id:"nuget--site-data",children:"NuGet / site data"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/Unflat/",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/Unflat?label=Unflat",alt:"Nuget"})}),"\n",(0,s.jsx)(t.a,{href:"https://github.com/pstlnce/unflat",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/github/last-commit/pstlnce/unflat?label=updated",alt:"GitHub last commit"})}),"\n",(0,s.jsx)(t.img,{src:"https://img.shields.io/github/stars/pstlnce/unflat?style=social",alt:"GitHub Repo stars"})]}),"\n",(0,s.jsx)(t.h2,{id:"details",children:"Details"}),"\n",(0,s.jsx)(t.h3,{id:"info",children:"Info"}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsxs)(t.p,{children:["Name: ",(0,s.jsx)(t.strong,{children:"Unflat"})]}),(0,s.jsx)(t.p,{children:"AOT ORM \u0421ode generator for fast parsing DataReader into complex classes/structs with zero allocations"}),(0,s.jsx)(t.p,{children:"Author: pstlnce"}),(0,s.jsxs)(t.p,{children:["NuGet:\n",(0,s.jsx)(t.em,{children:(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/Unflat/",children:"https://www.nuget.org/packages/Unflat/"})})]}),(0,s.jsxs)(t.p,{children:["You can find more details at ",(0,s.jsx)(t.a,{href:"https://github.com/pstlnce/unflat",children:"https://github.com/pstlnce/unflat"})]}),(0,s.jsxs)(t.p,{children:["Source: ",(0,s.jsx)(t.a,{href:"https://github.com/pstlnce/unflat",children:"https://github.com/pstlnce/unflat"})]})]}),"\n",(0,s.jsx)(t.h3,{id:"author",children:"Author"}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["pstlnce\n",(0,s.jsx)(t.img,{src:"https://github.com/pstlnce.png",alt:"Alt text"})]})}),"\n",(0,s.jsx)(t.h3,{id:"original-readme",children:"Original Readme"}),"\n",(0,s.jsxs)(t.admonition,{type:"note",children:[(0,s.jsx)(t.h1,{id:"unflat",children:"Unflat"}),(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/Unflat/",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/v/Unflat?style=flat-square",alt:"Unflat"})})}),(0,s.jsx)(t.p,{children:"Unflat is an AOT ORM \u0421ode generator for fast parsing DataReader into complex classes/structs with zero allocations"}),(0,s.jsx)(t.h2,{id:"how-to-use",children:"How To Use"}),(0,s.jsx)(t.h3,{id:"generating-parser",children:"Generating Parser"}),(0,s.jsx)(t.p,{children:"Unflat generates parsers for classes or structs that have the UnflatMarkerAttribute applied to them. Target types can contain any number of nested complex fields or properties, with no depth limit. Circular references are resolved using default values."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:"[UnflatMarker(Case = MatchCase.IgnoreCase)]\npublic sealed class TestClass\n{\n   ...\n}\n"})}),(0,s.jsx)(t.h3,{id:"custom-converters",children:"Custom Converters"}),(0,s.jsx)(t.p,{children:"Unflat supports custom converters by applying the UnflatParserAttribute to a method that should be called during parsing. Unflat searches for converters by matching the property types with the return types of marked methods, and selects the method that is closest in namespace to the target type.\nFor example, if there are two converters\u2014one in Namespace1 and the other in Namespace1.Namespace2:"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"If the target type is in Namespace1.Namespace2.Namespace3, the second converter will be chosen."}),"\n",(0,s.jsx)(t.li,{children:"If the target is in Namespace1.Namespace4, the first converter will be chosen."}),"\n",(0,s.jsx)(t.li,{children:"If the target is in Namespace5, the one marked with IsDefault = true will be selected."}),"\n"]}),(0,s.jsx)(t.p,{children:"There are several options to control how converters are called and matched:"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["CallFormat: Specifies how the converter should be invoked. It is used as the format string for string.Format(...), where ",0," is replaced with reader.GetValue(<column_index>) and ",1," with <column_index>."]}),"\n",(0,s.jsx)(t.li,{children:"IsDefault: Indicates that this converter is the default and should be used when no closer match is found by namespace."}),"\n",(0,s.jsx)(t.li,{children:"NamespaceScope: Tells Unflat to treat the converter as if it resides in the specified namespace, regardless of its actual location."}),"\n"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'[UnflatParser(CallFormat = "Example.ExampleClass.Parse({0}, {1}, reader)", IsDefault = false, NamespaceScope = "Example2")]\npublic static int Parse(object v, int index, IDataReader reader)\n{\n    return Convert.ToInt32(v);\n}\n'})}),(0,s.jsx)(t.h3,{id:"per-propertyfield-converter",children:"Per Property/Field converter"}),(0,s.jsxs)(t.p,{children:["For different parsing behavior on specific properties or fields, use the SettableParserAttribute. It takes a single argument\u2014the format string for string.Format(...), where ",0," is replaced with reader.GetValue(<column_index>) and ",1," with <column_index>."]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'[SettableParser("Convert.ToString({0})")]\npublic string Description \\{ get; set; }\n'})}),(0,s.jsx)(t.h3,{id:"spliton-column-prefix",children:"SplitOn, Column Prefix"}),(0,s.jsx)(t.p,{children:"Unflat does not currently support split_on like Dapper."}),(0,s.jsx)(t.p,{children:"Instead, you can use the UnflatPrefixAttribute to differentiate properties or fields of complex types that share the same names as properties or fields of primitive types."}),(0,s.jsx)(t.p,{children:"If all names are unique (or if a field source is explicitly specified to resolve naming conflicts), no additional configuration is needed\u2014nested complex types will be automatically assigned to their corresponding properties, unlike in Dapper."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'public sealed class Example\n{\n    [UnflatPrefix("nested_class_")]\n    public required NestedClassExample NestedClass \\{ get; set; }\n\n    [UnflatPrefix("nested_class_2_")]\n    public required NestedClassExample NestedClass \\{ get; set; }\n}\n'})}),(0,s.jsx)(t.h3,{id:"per-propertyfield-field-source",children:"Per Property/Field Field Source"}),(0,s.jsx)(t.p,{children:"Unflat allows you to specify a field source using the UnflatSourceAttribute. It can be a concrete column name, a column ordinal, or multiple column names."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'[UnflatSource("column_1")]\npublic required strign Field1 \\{ get; set; }\n\n[UnflatSource(1)]\npublic required strign Field2 \\{ get; set; }\n\n[UnflatSource(["column_1", "column_2", "column_3"])]\npublic required strign Field3 \\{ get; set; }\n'})}),(0,s.jsx)(t.h2,{id:"planned-features--limitations",children:"Planned Features / Limitations"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Parameterless constructor requirement: Unflat currently only works if the target type has a parameterless constructor. I plan to add support for constructor argument matching (similar to Dapper) and the ability to call methods where parameters correspond to fields in the reader."}),"\n",(0,s.jsx)(t.li,{children:"Method argument support: The ability to pass arguments to parsing methods, including injecting custom code into generated parsing logic."}),"\n",(0,s.jsx)(t.li,{children:"Code templating: Support for templated code generation\u2014such as automatically generating method extensions\u2014to reduce boilerplate. For example, generating helper methods that use Dapper to fetch data and parse it with Unflat."}),"\n",(0,s.jsx)(t.li,{children:"Alternative error handling: Currently, errors result in exceptions. Future support may include returning a Result<TTarget> type (if the user chooses), which could provide detailed error information\u2014such as missing columns for required fields, invalid casts, etc."}),"\n",(0,s.jsx)(t.li,{children:"Generic converters: Support for generic converter types (e.g., Converter<T>), which are not currently supported."}),"\n",(0,s.jsx)(t.li,{children:"Multi-column converters: Converters that require values from multiple columns. (I haven\u2019t yet determined how to design the API for this without conflicting with class or struct field declarations.)"}),"\n",(0,s.jsx)(t.li,{children:'"Split On" support: Potential future support for a split_on-like feature, if there is a clear need.'}),"\n",(0,s.jsx)(t.li,{children:"Tuple parsing: Currently, Unflat cannot parse tuples. This limitation may be addressed in a future update."}),"\n"]}),(0,s.jsx)(t.h2,{id:"perfomane",children:"Perfomane"}),(0,s.jsx)(t.h4,{id:"raw-test-against-dapper",children:"Raw test against Dapper"}),(0,s.jsx)(t.p,{children:"Parsing an in-memory DataTable using a DataTableReader into a model with 18 properties."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:"[UnflatMarker]\npublic class TestClass\n{\n    public string String1 \\{ get; set; }\n    public string String2 \\{ get; set; }\n    public string String3 \\{ get; set; }\n    public string Int \\{ get; set; }\n    public string Int2 \\{ get; set; }\n    public int IntNullable \\{ get; set; }\n\n    public string String1_1 \\{ get; set; }\n    public string String2_1 \\{ get; set; }\n    public string String3_1 \\{ get; set; }\n    public string Int_1 \\{ get; set; }\n    public string Int2_1 \\{ get; set; }\n    public int IntNullable_1 \\{ get; set; }\n\n    public string String1_2 \\{ get; set; }\n    public string String2_2 \\{ get; set; }\n    public string String3_2 \\{ get; set; }\n    public string Int_2 \\{ get; set; }\n    public string Int2_2 \\{ get; set; }\n    public int IntNullable_2 \\{ get; set; }\n}\n"})}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"BenchmarkDotNet v0.14.0, Windows 11 (10.0.26100.4652)\n11th Gen Intel Core i5-1135G7 2.40GHz, 1 CPU, 8 logical and 4 physical cores\n.NET SDK 10.0.100-preview.5.25277.114\n  [Host]     : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX-512F+CD+BW+DQ+VL+VBMI\n  DefaultJob : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX-512F+CD+BW+DQ+VL+VBMI\n"})}),(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Method"}),(0,s.jsx)(t.th,{children:"count"}),(0,s.jsx)(t.th,{style:{textAlign:"right"},children:"Mean"}),(0,s.jsx)(t.th,{style:{textAlign:"right"},children:"Error"}),(0,s.jsx)(t.th,{style:{textAlign:"right"},children:"StdDev"}),(0,s.jsx)(t.th,{style:{textAlign:"right"},children:"Median"}),(0,s.jsx)(t.th,{style:{textAlign:"right"},children:"Gen0"}),(0,s.jsx)(t.th,{style:{textAlign:"right"},children:"Gen1"}),(0,s.jsx)(t.th,{style:{textAlign:"right"},children:"Gen2"}),(0,s.jsx)(t.th,{style:{textAlign:"right"},children:"Allocated"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Unflat"}),(0,s.jsx)(t.td,{children:"100"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"22.68 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"0.259 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"0.242 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"22.61 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"7.2021"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"-"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"-"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"29.49 KB"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Dapper"}),(0,s.jsx)(t.td,{children:"100"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"27.61 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"0.549 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"0.933 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"27.44 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"7.9956"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"-"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"-"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"32.69 KB"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Unflat"}),(0,s.jsx)(t.td,{children:"1000"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"260.84 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"5.161 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"5.069 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"258.15 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"68.8477"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"18.5547"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"-"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"282.63 KB"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Dapper"}),(0,s.jsx)(t.td,{children:"1000"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"297.94 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"4.265 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"4.380 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"296.87 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"76.1719"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"8.7891"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"-"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"313.95 KB"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Unflat"}),(0,s.jsx)(t.td,{children:"10000"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"5,680.10 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"113.556 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"308.937 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"5,555.69 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"546.8750"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"343.7500"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"93.7500"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"2913.38 KB"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Dapper"}),(0,s.jsx)(t.td,{children:"10000"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"7,420.81 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"146.523 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"271.590 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"7,444.71 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"609.3750"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"375.0000"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"109.3750"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"3226 KB"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Unflat"}),(0,s.jsx)(t.td,{children:"50000"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"33,989.82 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"352.901 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"330.104 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"33,963.35 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"2600.0000"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"1600.0000"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"466.6667"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"14306.6 KB"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Dapper"}),(0,s.jsx)(t.td,{children:"50000"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"41,203.97 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"815.625 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"1,551.811 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"41,597.04 us"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"2833.3333"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"1666.6667"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"416.6667"}),(0,s.jsx)(t.td,{style:{textAlign:"right"},children:"15869.31 KB"})]})]})]}),(0,s.jsx)(t.h2,{id:"whats-the-purpose",children:"What's the purpose?"}),(0,s.jsx)(t.p,{children:"Unflat allows you to debug the parsing process and see exactly which converters or parsers are used\u2014at compile time. In contrast, debugging the parsing logic in Dapper is difficult and often requires tools like WinDbg. With Dapper, you must manually verify whether a type parser is registered, and since only one parser can be registered per type, you may end up writing general-purpose converters that perform unnecessary checks, hurting performance."}),(0,s.jsx)(t.p,{children:"Additionally, Unflat does not allocate any memory beyond what is required to create the target object\u2014which is unavoidable, as object creation is the core purpose of any ORM."}),(0,s.jsx)(t.h2,{id:"what-about-other-libraries",children:"What About Other Libraries?"}),(0,s.jsx)(t.p,{children:"I couldn't find any source generators that address the most frustrating aspects of Dapper \u2014 specifically, the inability to debug the parsing process and the need to manually register type parsers."}),(0,s.jsx)(t.p,{children:"Some similar libraries only support flat types, while others lack support for custom type parsers altogether."})]}),"\n",(0,s.jsx)(t.h3,{id:"about",children:"About"}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"DataReader to Object Model"})}),"\n",(0,s.jsx)(t.h2,{id:"how-to-use-1",children:"How to use"}),"\n",(0,s.jsx)(t.h3,{id:"example-source-csproj-source-files",children:"Example (source csproj, source files)"}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsxs)(l.A,{value:"csproj",label:"CSharp Project",children:[(0,s.jsxs)(t.p,{children:["This is the CSharp Project that references ",(0,s.jsx)(t.strong,{children:"Unflat"})]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-xml",metastring:"showLineNumbers {4}",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n  <ItemGroup>\n    <PackageReference Include="Unflat" Version="0.0.1" OutputItemType="Analyzer" ReferenceOutputAssembly="false"  />\n  </ItemGroup>\n\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net9.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\t<PropertyGroup>\n\t\t<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n\t\t<CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n\t</PropertyGroup>\n\n</Project>\n\n'})})]}),(0,s.jsxs)(l.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Unflat\\src\\UnflatDemo\\Program.cs",label:"Program.cs",children:[(0,s.jsxs)(t.p,{children:["This is the use of ",(0,s.jsx)(t.strong,{children:"Unflat"})," in ",(0,s.jsx)(t.em,{children:"Program.cs"})]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'using System;\nusing System.Data;\nusing Unflat;\n\nnamespace UnflatDemo\n{\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Create a DataTable and fill with sample data\n            var table = new DataTable();\n            table.Columns.Add("Id", typeof(int));\n            table.Columns.Add("Name", typeof(string));\n            table.Columns.Add("Age", typeof(int));\n\n            table.Rows.Add(1, "Andrei", 30);\n            table.Rows.Add(2, "Ignat", 55);\n\n            using var reader = table.CreateDataReader();\n\n            var persons = PersonParser.ReadList(reader);\n            foreach (var person in persons)\n            {\n                Console.WriteLine($"Id: {person.Id}, Name: {person.Name}, Age: {person.Age}");\n            }\n        }\n    }\n}\n\n'})})]}),(0,s.jsxs)(l.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Unflat\\src\\UnflatDemo\\Person.cs",label:"Person.cs",children:[(0,s.jsxs)(t.p,{children:["This is the use of ",(0,s.jsx)(t.strong,{children:"Unflat"})," in ",(0,s.jsx)(t.em,{children:"Person.cs"})]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"namespace UnflatDemo\n{\n    [Unflat.UnflatMarker]\n    public partial class Person\n    {\n        public int Id \\{ get; set; }\n        public string Name \\{ get; set; \\} = string.Empty;\n        public int Age \\{ get; set; }\n    }\n}\n\n"})})]})]}),"\n",(0,s.jsx)(t.h3,{id:"generated-files",children:"Generated Files"}),"\n",(0,s.jsx)(t.p,{children:"Those are taken from $(BaseIntermediateOutputPath)\\GX"}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(l.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Unflat\\src\\UnflatDemo\\obj\\GX\\Unflat\\Unflat.SourceGen\\Unflat.UnflatMarkerAttribute.g.cs",label:"Unflat.UnflatMarkerAttribute.g.cs",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'using System;\n\nnamespace Unflat\n{\n    [AttributeUsage(AttributeTargets.Class)]\n    internal sealed class UnflatMarkerAttribute : Attribute\n    {\n        public string? ClassName \\{ get; set; }\n        public MatchCase Case \\{ get; set; \\} = MatchCase.All;\n    }\n\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false)]\n    internal sealed class SettableParserAttribute : Attribute\n    {\n        /// <summary>\n        /// <list type="bullet">\n        /// <item> {0} - reader[i] </item>\n        /// <item> {1} - i </item>\n        /// <item> i - related column index </item>\n        /// <item> reader - reader... </item>\n        /// </list>\n        /// </summary>\n        /// <param name="callFormat"> an argument for string.Format(callFormat, "reader[i]", i) </param>\n        public SettableParserAttribute(string callFormat) {}\n    }\n\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false)]\n    internal sealed class UnflatPrefixAttribute : Attribute\n    {\n        public UnflatPrefixAttribute(string prefix) \\{ }\n    }\n\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]\n    internal sealed class UnflatSourceAttribute : Attribute\n    {\n        public UnflatSourceAttribute(params string[] fields) {}\n        public UnflatSourceAttribute(int fieldOrder) {}\n    }\n\n    [Flags]\n    public enum MatchCase : int\n    {\n        None                 = 0,\n        IgnoreCase           = 1,\n        MatchOriginal        = 1 << 1,\n        SnakeCase            = 1 << 2,\n        CamalCase            = 1 << 3,\n        PascalCase           = 1 << 4,\n        ApplyOnOverritenName = 1 << 5,\n        All = IgnoreCase | MatchOriginal | SnakeCase | CamalCase | PascalCase | ApplyOnOverritenName\n    }\n\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    internal sealed class UnflatParserAttribute : Attribute\n    {\n        /// <summary>\n        /// <list type="bullet">\n        /// <item> {0} - reader[i] </item>\n        /// <item> {1} - i </item>\n        /// <item> i - related column index </item>\n        /// <item> reader - reader... </item>\n        /// </list>\n        /// </summary>\n        /// <param name="callFormat"> an argument for string.Format(callFormat, "reader[i]", i) </param>\n        public string CallFormat \\{ get; set; }\n\n        /// <summary>\n        /// If true than this would be a fallback way\n        /// for parsing reader\'s column value to returning type\n        /// if not found parsers in closest namespaces\n        /// </summary>\n        public bool IsDefault \\{ get; set; }\n\n        /// <summary>\n        /// If set this value will replace the namespace that contains this parser.\n        /// Parser searcher will look to closest parser available to the model.\n        /// Parser in Test namespace, the target in Test.Test1 => matched.\n        /// Parser in Test.Test1.Test2, the target in Test.Test1 => not matched.\n        /// Parser in Test.Test1, the target in Test.Test2 => not matched, etc...\n        /// </summary>\n        public string NamespaceScope \\{ get; set; }\n    }\n\n    [Serializable]\n    internal sealed class NotEnoughFieldsForRequiredException : Exception\n    {\n        public NotEnoughFieldsForRequiredException(int expected, int actual)\n            : base($"Required field/properties count: {expected}, actual reader\'s fields count: {actual}")\n        {\n            Expected = expected;\n            Actual = actual;\n        }\n        \n        public int Expected \\{ get; init; }\n        public int Actual \\{ get; init; }\n    }\n\n    [Serializable]\n    public class MissingRequiredFieldOrPropertyException : System.Exception\n    {\n        public MissingRequiredFieldOrPropertyException(string[] propertiesOrFields)\n            : base("There is no matched data for required properties or fields")\n        {\n            PropertiesOrFields = propertiesOrFields;\n        }\n\n        public string[] PropertiesOrFields \\{ get; init; }\n    }\n}\n'})})}),(0,s.jsx)(l.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Unflat\\src\\UnflatDemo\\obj\\GX\\Unflat\\Unflat.SourceGen\\UnflatDemo.PersonParser.g.cs",label:"UnflatDemo.PersonParser.g.cs",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'using System;\nusing System.Data;\nusing System.Data.Common;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Runtime.CompilerServices;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace UnflatDemo\n{\n    internal sealed partial class PersonParser\n    {\n        internal static List<UnflatDemo.Person> ReadList<TReader>(TReader reader)\n            where TReader : IDataReader\n        {\n            var result = new List<UnflatDemo.Person>();\n        \n            if(!reader.Read())\n            {\n                return result;\n            }\n        \n            ReadSchemaIndexes(reader, out int col_Age, out int col_Name, out int col_Id);\n        \n            do\n            {\n                UnflatDemo.Person parsed = new UnflatDemo.Person();\n                \n                if(col_Age != -1)\n                {\n                \tparsed.Age = reader[col_Age] is int pcol_Age ? pcol_Age : default;\n                }\n                \n                if(col_Name != -1)\n                {\n                \tparsed.Name = reader[col_Name] is string pcol_Name ? pcol_Name : default;\n                }\n                \n                if(col_Id != -1)\n                {\n                \tparsed.Id = reader[col_Id] is int pcol_Id ? pcol_Id : default;\n                }\n        \n                result.Add(parsed);\n            \\} while(reader.Read());\n        \n            return result;\n        }\n    \n        internal static IEnumerable<UnflatDemo.Person> ReadUnbuffered<TReader>(TReader reader)\n            where TReader : IDataReader\n        {\n            if(!reader.Read())\n            {\n                yield break;\n            }\n        \n            ReadSchemaIndexes(reader, out int col_Age, out int col_Name, out int col_Id);\n        \n            do\n            {\n                UnflatDemo.Person parsed = new UnflatDemo.Person();\n                \n                if(col_Age != -1)\n                {\n                \tparsed.Age = reader[col_Age] is int pcol_Age ? pcol_Age : default;\n                }\n                \n                if(col_Name != -1)\n                {\n                \tparsed.Name = reader[col_Name] is string pcol_Name ? pcol_Name : default;\n                }\n                \n                if(col_Id != -1)\n                {\n                \tparsed.Id = reader[col_Id] is int pcol_Id ? pcol_Id : default;\n                }\n        \n                yield return parsed;\n            \\} while(reader.Read());\n        }\n    \n        internal static async Task<List<UnflatDemo.Person>> ReadListAsync<TReader>(TReader reader, CancellationToken token = default)\n            where TReader : DbDataReader\n        {\n            var result = new List<UnflatDemo.Person>();\n        \n            if(!(await reader.ReadAsync(token).ConfigureAwait(false)))\n            {\n                return result;\n            }\n        \n            ReadSchemaIndexes(reader, out int col_Age, out int col_Name, out int col_Id);\n        \n            Task<bool> reading;\n        \n            while(true)\n            {\n                UnflatDemo.Person parsed = new UnflatDemo.Person();\n                \n                if(col_Age != -1)\n                {\n                \tparsed.Age = reader[col_Age] is int pcol_Age ? pcol_Age : default;\n                }\n                \n                if(col_Name != -1)\n                {\n                \tparsed.Name = reader[col_Name] is string pcol_Name ? pcol_Name : default;\n                }\n                \n                if(col_Id != -1)\n                {\n                \tparsed.Id = reader[col_Id] is int pcol_Id ? pcol_Id : default;\n                }\n        \n                reading = reader.ReadAsync(token);\n        \n                result.Add(parsed);\n        \n                if(!(await reading.ConfigureAwait(false)))\n                {\n                    break;\n                }\n            }\n        \n            return result;\n        }\n    \n        internal static async ValueTask<List<UnflatDemo.Person>> ReadListAsyncValue<TReader>(TReader reader, CancellationToken token = default)\n            where TReader : DbDataReader\n        {\n            var result = new List<UnflatDemo.Person>();\n        \n            if(!(await reader.ReadAsync(token).ConfigureAwait(false)))\n            {\n                return result;\n            }\n        \n            ReadSchemaIndexes(reader, out int col_Age, out int col_Name, out int col_Id);\n        \n            Task<bool> reading;\n        \n            while(true)\n            {\n                UnflatDemo.Person parsed = new UnflatDemo.Person();\n                \n                if(col_Age != -1)\n                {\n                \tparsed.Age = reader[col_Age] is int pcol_Age ? pcol_Age : default;\n                }\n                \n                if(col_Name != -1)\n                {\n                \tparsed.Name = reader[col_Name] is string pcol_Name ? pcol_Name : default;\n                }\n                \n                if(col_Id != -1)\n                {\n                \tparsed.Id = reader[col_Id] is int pcol_Id ? pcol_Id : default;\n                }\n        \n                reading = reader.ReadAsync(token);\n        \n                result.Add(parsed);\n        \n                if(!(await reading.ConfigureAwait(false)))\n                {\n                    break;\n                }\n            }\n        \n            return result;\n        }\n    \n        internal static async IAsyncEnumerable<UnflatDemo.Person> ReadUnbufferedAsync<TReader>(TReader reader, [EnumeratorCancellationAttribute] CancellationToken token = default)\n            where TReader : DbDataReader\n        {\n            if(!(await reader.ReadAsync(token).ConfigureAwait(false)))\n            {\n                yield break;\n            }\n        \n            ReadSchemaIndexes(reader, out int col_Age, out int col_Name, out int col_Id);\n        \n            Task<bool> reading;\n        \n            while(true)\n            {\n                UnflatDemo.Person parsed = new UnflatDemo.Person();\n                \n                if(col_Age != -1)\n                {\n                \tparsed.Age = reader[col_Age] is int pcol_Age ? pcol_Age : default;\n                }\n                \n                if(col_Name != -1)\n                {\n                \tparsed.Name = reader[col_Name] is string pcol_Name ? pcol_Name : default;\n                }\n                \n                if(col_Id != -1)\n                {\n                \tparsed.Id = reader[col_Id] is int pcol_Id ? pcol_Id : default;\n                }\n        \n                reading = reader.ReadAsync(token);\n        \n                yield return parsed;\n        \n                if(!(await reading.ConfigureAwait(false)))\n                {\n                    break;\n                }\n            }\n        }\n    \n        public static void ReadSchemaIndexes<TReader>(TReader reader, out int col_Age, out int col_Name, out int col_Id)\n            where TReader : IDataReader\n        {\n        \tcol_Age = -1;\n        \tcol_Name = -1;\n        \tcol_Id = -1;\n        \n        \tvar fieldCount = reader.FieldCount;\n        \n        \tfor(int i = 0; i < fieldCount; i++)\n        \t{\n        \t\tReadSchemaIndex(reader.GetName(i), i, ref col_Age, ref col_Name, ref col_Id);\n        \t}\n        }\n    \n        public static void ReadSchemaIndex(string name, int i, ref int col_Age, ref int col_Name, ref int col_Id)\n        {\n        \tswitch(name.Length)\n        \t{\n        \t\tcase 2:\n        \t\t\tif(col_Id == -1 && string.Equals("Id", name, StringComparison.OrdinalIgnoreCase))\n        \t\t\t{\n        \t\t\t\tcol_Id = i;\n        \t\t\t}\n        \n        \t\t\tbreak;\n        \n        \t\tcase 3:\n        \t\t\tif(col_Age == -1 && string.Equals("Age", name, StringComparison.OrdinalIgnoreCase))\n        \t\t\t{\n        \t\t\t\tcol_Age = i;\n        \t\t\t}\n        \n        \t\t\tbreak;\n        \n        \t\tcase 4:\n        \t\t\tif(col_Name == -1 && string.Equals("Name", name, StringComparison.OrdinalIgnoreCase))\n        \t\t\t{\n        \t\t\t\tcol_Name = i;\n        \t\t\t}\n        \n        \t\t\tbreak;\n        \n        \t\tdefault:\n        \t\t\tbreak;\n        \t}\n        }\n    }\n}\n'})})})]}),"\n",(0,s.jsx)(t.h2,{id:"useful",children:"Useful"}),"\n",(0,s.jsx)(t.h3,{id:"download-example-net--c",children:"Download Example (.NET  C#)"}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(83216).A+"",children:"Download Example project Unflat "})})}),"\n",(0,s.jsx)(t.h3,{id:"share-unflat",children:"Share Unflat"}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsx)("li",{children:(0,s.jsx)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnflat&quote=Unflat",title:"Share on Facebook",target:"_blank",children:"Share on Facebook"})}),(0,s.jsx)("li",{children:(0,s.jsx)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnflat&text=Unflat:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnflat",target:"_blank",title:"Tweet",children:"Share in Twitter"})}),(0,s.jsx)("li",{children:(0,s.jsx)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnflat&title=Unflat",target:"_blank",title:"Submit to Reddit",children:"Share on Reddit"})}),(0,s.jsx)("li",{children:(0,s.jsx)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnflat&title=Unflat&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnflat",target:"_blank",title:"Share on LinkedIn",children:"Share on Linkedin"})})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/Unflat",children:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/Unflat"})}),"\n",(0,s.jsx)(o.Ay,{})]})}function m(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}},83216:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/files/Unflat-eed037967809dbcf480342495305f1a6.zip"}}]);