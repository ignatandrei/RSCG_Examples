"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[7401],{43790:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>u,default:()=>g,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var a=n(87462),r=(n(67294),n(3905)),i=n(73992),s=n(18679),o=n(68839);const l={sidebar_position:1090,title:"109 - FunicularSwitch",description:"Generating discriminated unions for C# 9.0 and above.",slug:"/FunicularSwitch"},u="FunicularSwitch  by bluehands",c={unversionedId:"RSCG-Examples/FunicularSwitch",id:"RSCG-Examples/FunicularSwitch",title:"109 - FunicularSwitch",description:"Generating discriminated unions for C# 9.0 and above.",source:"@site/docs/RSCG-Examples/FunicularSwitch.md",sourceDirName:"RSCG-Examples",slug:"/FunicularSwitch",permalink:"/RSCG_Examples/v2/docs/FunicularSwitch",draft:!1,tags:[],version:"current",sidebarPosition:1090,frontMatter:{sidebar_position:1090,title:"109 - FunicularSwitch",description:"Generating discriminated unions for C# 9.0 and above.",slug:"/FunicularSwitch"},sidebar:"tutorialSidebar",previous:{title:"108 - CommandLine",permalink:"/RSCG_Examples/v2/docs/CommandLine"},next:{title:"110 - jab",permalink:"/RSCG_Examples/v2/docs/jab"}},p={},d=[{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share FunicularSwitch",id:"share-funicularswitch",level:3},{value:"In the same category (FunctionalProgramming)",id:"in-the-same-category-functionalprogramming",level:2},{value:"cachesourcegenerator",id:"cachesourcegenerator",level:3},{value:"dunet",id:"dunet",level:3},{value:"Funcky.DiscriminatedUnion",id:"funckydiscriminatedunion",level:3},{value:"N.SourceGenerators.UnionTypes",id:"nsourcegeneratorsuniontypes",level:3},{value:"OneOf",id:"oneof",level:3},{value:"PartiallyApplied",id:"partiallyapplied",level:3},{value:"RSCG_Utils_Memo",id:"rscg_utils_memo",level:3}],m={toc:d},h="wrapper";function g(e){let{components:t,...l}=e;return(0,r.kt)(h,(0,a.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"funicularswitch--by-bluehands"},"FunicularSwitch  by bluehands"),(0,r.kt)(o.Z,{toc:d,mdxType:"TOCInline"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/FunicularSwitch.Generators/"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/FunicularSwitch.Generators?label=FunicularSwitch.Generators",alt:"Nuget"})),(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/FunicularSwitch"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/FunicularSwitch?label=FunicularSwitch",alt:"Nuget"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bluehands/Funicular-Switch"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/bluehands/Funicular-Switch?label=updated",alt:"GitHub last commit"})),"\n",(0,r.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/bluehands/Funicular-Switch?style=social",alt:"GitHub Repo stars"})),(0,r.kt)("h2",{id:"details"},"Details"),(0,r.kt)("h3",{id:"info"},"Info"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Name: ",(0,r.kt)("strong",{parentName:"p"},"FunicularSwitch")),(0,r.kt)("p",{parentName:"admonition"},"Source generator package to have result types like in F# with your custom error type"),(0,r.kt)("p",{parentName:"admonition"},"Author: bluehands"),(0,r.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/FunicularSwitch.Generators/"},"https://www.nuget.org/packages/FunicularSwitch.Generators/")),"   "),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/FunicularSwitch"},"https://www.nuget.org/packages/FunicularSwitch")),"   "),(0,r.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bluehands/Funicular-Switch"},"https://github.com/bluehands/Funicular-Switch")),(0,r.kt)("p",{parentName:"admonition"},"Source : ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bluehands/Funicular-Switch"},"https://github.com/bluehands/Funicular-Switch"))),(0,r.kt)("h3",{id:"original-readme"},"Original Readme"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("h1",{parentName:"admonition",id:"funicularswitch"},"FunicularSwitch"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("img",{parentName:"p",src:"https://bluehands.visualstudio.com/bluehands%20Funicular%20Switch/_apis/build/status/bluehandsFunicularSwitch-CI?branchName=develop",alt:"BuildStatus"}),"\n",(0,r.kt)("img",{parentName:"p",src:"https://img.shields.io/badge/Try_.NET-Enabled-501078.svg",alt:"Try_.NET Enabled"})),(0,r.kt)("p",{parentName:"admonition"},"FunicularSwitch is a lightweight C# port of F# result and option types."),(0,r.kt)("p",{parentName:"admonition"},"FunicularSwitch helps you to:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Focus on the 'happy path', but collect all error information."),(0,r.kt)("li",{parentName:"ul"},"Be more explicit in what our methods return."),(0,r.kt)("li",{parentName:"ul"},"Avoid deep nesting."),(0,r.kt)("li",{parentName:"ul"},"Avoid null checks and eventual properties (properties only relevant for a certain state of an object), use Result or Option instead."),(0,r.kt)("li",{parentName:"ul"},"Comfortably write async code pipelines."),(0,r.kt)("li",{parentName:"ul"},"Wrap third party library exceptions / return values into results at the code level were we really understand what is happening.")),(0,r.kt)("h1",{parentName:"admonition",id:"getting-started"},"Getting Started"),(0,r.kt)("h3",{parentName:"admonition",id:"packages"},"Packages"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.nuget.org/packages/FunicularSwitch/"},"NuGet: FunicularSwitch")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.nuget.org/packages/FunicularSwitch.Generators/"},"NuGet: FunicularSwitch.Generators"))),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/bluehands/Funicular-Switch#funicularswitch-usage"},(0,r.kt)("strong",{parentName:"a"},"FunicularSwitch"))," is a library containing the Result and Option type. Usage and the general idea is described in the following sections. The 'Error' type is always string, which allows natural concatenation and is sufficient in many cases."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/bluehands/Funicular-Switch#funicularswitchgenerators-usage"},(0,r.kt)("strong",{parentName:"a"},"FunicularSwitch.Generators"))," is a C# source generator package (projects consuming it, will have no runtime dependency to any FunicularSwitch dll). With this source generator you can have a result type with the very same behaviour as FunicularSwitch.Result but a custom error type (instead of string) by just annotating a class with the ",(0,r.kt)("inlineCode",{parentName:"p"},"ResultType")," attribute. That means you are free to represent failures in a way suitable for your needs. A second thing coming with this package are generated F#-like Match methods. They allow for compiler safe switches handling all concrete subtypes of a base class (very useful for union type implementations). As a third thing the same Match methods are also generated for enum types annotated with the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExtendedEnum")," attribute."),(0,r.kt)("h1",{parentName:"admonition",id:"funicularswitch-usage"},(0,r.kt)("a",{name:"funicular_usage"}),"FunicularSwitch Usage"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"This document is created using ",(0,r.kt)("a",{parentName:"em",href:"https://github.com/dotnet/try/blob/main/DotNetTryLocal.md"},"dotnet try"),". If you have dotnet try global tool installed, just clone the repo, type ",(0,r.kt)("inlineCode",{parentName:"em"},"dotnet try")," on top level and play around with all code samples in your browser while reading.")),(0,r.kt)("p",{parentName:"admonition"},"This following section mainly focuses on ",(0,r.kt)("inlineCode",{parentName:"p"},"Result"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," is a union type representing either Ok or the Error case just like F#s Result type. For FunicularSwitch the error type is ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," for sake of simplicity (Using types with multiple generic arguments is quite verbose in C#)."),(0,r.kt)("p",{parentName:"admonition"},"Result should be used in all places, were something can go wrong. Doing so it replaces exceptions and null/default return values."),(0,r.kt)("p",{parentName:"admonition"},"Creating a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," is easy:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:"--region resultCreation --source-file Source/DocSamples/ReadmeSamples.cs --project Source/DocSamples/DocSamples.csproj","--region":!0,resultCreation:!0,"--source-file":!0,"Source/DocSamples/ReadmeSamples.cs":!0,"--project":!0,"Source/DocSamples/DocSamples.csproj":!0},'//Ok result:\nvar fortyTwo = Result.Ok(42);\n//or using implicit cast operator\nResult<string> ok = "Ok";\n\n//Error result:\nvar error = Result.Error<int>("Could not find the answer");\n')),(0,r.kt)("p",{parentName:"admonition"},"Now lets follow the happy path, do something, if everything was ok. ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),":"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:"--region map --source-file Source/DocSamples/ReadmeSamples.cs --project Source/DocSamples/DocSamples.csproj --session map","--region":!0,map:!0,"--source-file":!0,"Source/DocSamples/ReadmeSamples.cs":!0,"--project":!0,"Source/DocSamples/DocSamples.csproj":!0,"--session":!0},"static Result<int> Ask() => 42;\n\nResult<int> answerTransformed = Ask()\n    .Map(answer => answer * 2);\n\nConsole.WriteLine(answerTransformed);\n")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-console",metastring:"--session map","--session":!0,map:!0},"Ok 84\n\n")),(0,r.kt)("p",{parentName:"admonition"},"or do something that might fail, if everything was ok. ",(0,r.kt)("inlineCode",{parentName:"p"},"Bind"),":"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:"--region bind --source-file Source/DocSamples/ReadmeSamples.cs --project Source/DocSamples/DocSamples.csproj --session bind","--region":!0,bind:!0,"--source-file":!0,"Source/DocSamples/ReadmeSamples.cs":!0,"--project":!0,"Source/DocSamples/DocSamples.csproj":!0,"--session":!0},'static Result<int> Ask() => 42;\n\nResult<int> answerTransformed = Ask()\n    .Bind(answer => answer == 0 ? Result.Error<int>("Division by zero") : 42 / answer);\n\nConsole.WriteLine(answerTransformed);\n')),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-console",metastring:"--session bind","--session":!0,bind:!0},"Ok 1\n\n")),(0,r.kt)("p",{parentName:"admonition"},"The lambdas passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Bind")," are only invoked if everything went well so far, otherwise you are on the error track were error information is passed on 'invisibly':\nb"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:"--region errorPropagation --source-file Source/DocSamples/ReadmeSamples.cs --project Source/DocSamples/DocSamples.csproj --session errorPropagation","--region":!0,errorPropagation:!0,"--source-file":!0,"Source/DocSamples/ReadmeSamples.cs":!0,"--project":!0,"Source/DocSamples/DocSamples.csproj":!0,"--session":!0},'static Result<int> Transform(Result<int> result) =>\n                result\n                    .Bind(answer => answer == 0 ? Result.Error<int>("Division by zero") : 42 / answer)\n                    .Map(transformed => transformed * 2);\n\nResult<int> firstLevelError = Transform(Result.Error<int>("I don\'t know"));\nConsole.WriteLine($"First level: {firstLevelError}");\n\nResult<int> secondLevelError = Transform(Result.Ok(0));\nConsole.WriteLine($"Second level: {secondLevelError}");\n')),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-console",metastring:"--session errorPropagation","--session":!0,errorPropagation:!0},"First level: Error I don't know\nSecond level: Error Division by zero\n\n")),(0,r.kt)("p",{parentName:"admonition"},"Finally you might want to leave the ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," world, so you have to take care of the error case as well (that's a good thing!). ",(0,r.kt)("inlineCode",{parentName:"p"},"Match"),":"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:"--region match --source-file Source/DocSamples/ReadmeSamples.cs --project Source/DocSamples/DocSamples.csproj --session match","--region":!0,match:!0,"--source-file":!0,"Source/DocSamples/ReadmeSamples.cs":!0,"--project":!0,"Source/DocSamples/DocSamples.csproj":!0,"--session":!0},'static Result<int> Ask() => 42;\n\nstring whatIsIt =\n    Ask().Match(\n        answer => $"The answer is: {answer}",\n        error => $"Ups: {error}"\n    );\n\nConsole.WriteLine(whatIsIt);\n')),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-console",metastring:"--session match","--session":!0,match:!0},"The answer is: 42\n\n")),(0,r.kt)("p",{parentName:"admonition"},"Those are basically the four (actually three) main operations on ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," - ",(0,r.kt)("inlineCode",{parentName:"p"},"Create"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Bind"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Match"),". There are a lot of overloads and other helpers in FunicularSwitch to avoid repetition of ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," specific patterns like:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"'Combine results to Ok if everything is Ok otherwise collect errors' - ",(0,r.kt)("inlineCode",{parentName:"li"},"Aggregate"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Map")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Bind")," overloads on collections"),(0,r.kt)("li",{parentName:"ul"},"'Ok if at least one item passes certain validations, otherwise collect info why no one matched' - ",(0,r.kt)("inlineCode",{parentName:"li"},"FirstOk")),(0,r.kt)("li",{parentName:"ul"},"'Ok if item from a dictionary was found, otherwise (nice) error' - ",(0,r.kt)("inlineCode",{parentName:"li"},"TryGetValue")," extension on Dictionary"),(0,r.kt)("li",{parentName:"ul"},"'Ok if type T is ",(0,r.kt)("inlineCode",{parentName:"li"},"as")," convertible to T1, error otherwise' - 'As' extension returning Result"),(0,r.kt)("li",{parentName:"ul"},"'Ok if item is valid regarding custom validations, error otherwise' - ",(0,r.kt)("inlineCode",{parentName:"li"},"Validate")),(0,r.kt)("li",{parentName:"ul"},"'Async support' - ",(0,r.kt)("inlineCode",{parentName:"li"},"Map")," ",(0,r.kt)("inlineCode",{parentName:"li"},"Bind")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Aggregate")," overloads with async lambdas and extensions defined on Task<...>"),(0,r.kt)("li",{parentName:"ul"},"...")),(0,r.kt)("p",{parentName:"admonition"},"If you miss functionality it can be added easily by writing your own extension methods. If it is useful for us all don't hesitate to make pull request. Finally a little example demonstrating some of the functionality mentioned above (validation, aggregation, async pipeline). Lets cook:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:"--region fruitSalad --source-file Source/DocSamples/ReadmeSamples.cs --project Source/DocSamples/DocSamples.csproj --session fruitSalad","--region":!0,fruitSalad:!0,"--source-file":!0,"Source/DocSamples/ReadmeSamples.cs":!0,"--project":!0,"Source/DocSamples/DocSamples.csproj":!0,"--session":!0},'public static async Task FruitSalad()\n{\n    var stock = ImmutableList.Create(\n        new Fruit("Orange", 155),\n        new Fruit("Orange", 12),\n        new Fruit("Apple", 132),\n        new Fruit("Stink fruit", 1));\n\n    var ingredients = ImmutableList.Create("Apple", "Banana", "Pear", "Stink fruit");\n\n    const int cookSkillLevel = 3;\n\n    static IEnumerable<string> CheckFruit(Fruit fruit)\n    {\n        if (fruit.AgeInDays > 20)\n            yield return $"{fruit.Name} is not fresh";\n\n        if (fruit.Name == "Stink fruit")\n            yield return "Stink fruit, I do not serve that";\n    }\n\n    var salad =\n        await ingredients\n            .Select(ingredient =>\n                stock\n                    .Where(fruit => fruit.Name == ingredient)\n                    .FirstOk(CheckFruit, onEmpty: () => $"No {ingredient} in stock")\n                )\n            .Bind(fruits => CutIntoPieces(fruits, cookSkillLevel))\n            .Map(Serve);\n\n    Console.WriteLine(salad.Match(ok => "Salad served successfully!", error => $"No salad today:{Environment.NewLine}{error}"));\n}\n\nstatic Result<Salad> CutIntoPieces(IEnumerable<Fruit> fruits, int skillLevel = 5)\n{\n    try\n    {\n        return CutFruits(fruits, skillLevel);\n    }\n    catch (Exception e)\n    {\n        return Result.Error<Salad>($"Ouch: {e.Message}");\n    }\n}\n\nstatic Salad CutFruits(IEnumerable<Fruit> fruits, int skillLevel) => skillLevel > 5 ? new Salad(fruits) : throw new Exception("Cut my fingers");\nstatic Task<Salad> Serve(Salad salad) => Task.FromResult(new Salad(salad.Fruits, true));\n\nclass Salad\n{\n    public IReadOnlyCollection<Fruit> Fruits { get; }\n    public bool Served { get; }\n\n    public Salad(IEnumerable<Fruit> fruits, bool served = false)\n    {\n        Fruits = fruits.ToList();\n        Served = served;\n    }\n}\n\nclass Fruit\n{\n    public string Name { get; }\n    public int AgeInDays { get; }\n\n    public Fruit(string name, int ageInDays)\n    {\n        Name = name;\n        AgeInDays = ageInDays;\n    }\n}\n')),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-console",metastring:"--session fruitSalad","--session":!0,fruitSalad:!0},"No salad today:\nApple is not fresh\nNo Banana in stock\nNo Pear in stock\nStink fruit, I do not serve that\n")),(0,r.kt)("p",{parentName:"admonition"},"As you can see, all errors are collected as far as possible. Feel free to play around with the cooks skill level, fruits in stock and the ingredients list to finally get your fruit salad."),(0,r.kt)("h1",{parentName:"admonition",id:"funicularswitchgenerators-usage"},(0,r.kt)("a",{name:"generators_usage"}),"FunicularSwitch.Generators Usage"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"DISCLAIMER"),": Right now source generator support in Visual Studio is quite a new feature. Often, especially after adding or updating the generator package intellisense will show errors, even though the code actually compiles. In this cases Visual Studio needs a restart right now (Visual Studio 2022 17.0.5)."),(0,r.kt)("h2",{parentName:"admonition",id:"resulttype-attribute"},"ResultType attribute"),(0,r.kt)("p",{parentName:"admonition"},"After adding the FunicularSwitch.Generators package you can mark a class as result type using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ResultType")," attribute. The class has to be abstract and partial with a single generic argument. Ok and Error cases, Map, Bind, Match and some other methods will be generated so you can use your Result just like the one from the FunicularSwitch package. We recommend using a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bluehands/Funicular-Switch#uniontype"},"UnionType")," as error type but you are free to use any type you want to represent failures."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"  [FunicularSwitch.Generators.ResultType(ErrorType = typeof(MyCustomError))]\n  public abstract partial class Result<T> {}\n")),(0,r.kt)("h3",{parentName:"admonition",id:"exceptions"},"Exceptions"),(0,r.kt)("p",{parentName:"admonition"},"To turn all exceptions that might happen during your map, bind, validate, etc. calls into error results, write a static conversion method and mark it with the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExceptionToError")," attribute:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"public static class MyCustomErrorExtension\n{\n  [FunicularSwitch.Generators.ExceptionToError]\n  public static MyCustomError ToGenericError(Exception ex) => ...\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"Having the ExceptionToError method, a call like ",(0,r.kt)("inlineCode",{parentName:"p"},"Ok(42).Map(i => 42 / 0)")," will return an error result with an error produced by your custom method instead of throwing a DivisionByZero exception.  "),(0,r.kt)("h5",{parentName:"admonition",id:"considerations"},"Considerations:"),(0,r.kt)("p",{parentName:"admonition"},"Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExceptionToError")," attribute is actually a decision that points into a direction that is different from the way Result is implemented in F#, were Result and the correspondind Error type are meant to model expected domain errors (see ",(0,r.kt)("a",{parentName:"p",href:"https://fsharpforfunandprofit.com/posts/against-railway-oriented-programming/"},"fsharpforfunandprofit blog post"),"). You will still have to handle exceptions on the highest parts of your system and there is no 'fail fast' because early exceptions always travel through your hole Result chain."),(0,r.kt)("h3",{parentName:"admonition",id:"combine-results"},"Combine results"),(0,r.kt)("p",{parentName:"admonition"},"If your errors can be combined, write an attributed extension method or a member method on your error type that combines two errors into one"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"public static class MyCustomErrorExtension\n{\n  [FunicularSwitch.Generators.MergeError]\n  public static MyCustomError Merge(this MyCustomError error, MyCustomError other) => ...\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"and a bunch of methods like ",(0,r.kt)("inlineCode",{parentName:"p"},"Aggregate"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Validate"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"AllOk"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"FirstOk")," and more will appear that make use of the fact that errors can be merged."),(0,r.kt)("h2",{parentName:"admonition",id:"uniontype-attribute"},"UnionType attribute"),(0,r.kt)("p",{parentName:"admonition"},"There is another useful generator coming with the package. Adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"UnionType")," attribute to a base record / class or interface makes ",(0,r.kt)("inlineCode",{parentName:"p"},"Match")," extension methods appear for this type. They are also inspired by F# where a match expression has to cover all cases and the compiler helps you with that. Assuming you implemented an error type as a base type and one derived type for every kind of error:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"[FunicularSwitch.Generators.UnionType]\npublic abstract class Error{...}\n\npublic sealed class NotFound : Error {...}\npublic sealed class Failure : Error {...}\npublic sealed class InvalidInput : Error {...}\n")),(0,r.kt)("p",{parentName:"admonition"},"the generator detecting the ",(0,r.kt)("inlineCode",{parentName:"p"},"[UnionType]")," adds Match methods so you can write:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'static string PrintError(Error error) =>\n        error.Match(\n                notFound => $"Not found: {notFound.Message}",\n                failure => $"Ups, something went wrong: {failure.Message} - {failure.Exception}",\n                invalidInput => $"Name was invalid: {invalidInput.Message}"                \n            );\n')),(0,r.kt)("p",{parentName:"admonition"},"If you decide to add a case to your Error union all consuming switches break and you never miss a case at runtime!"),(0,r.kt)("p",{parentName:"admonition"},"Match methods are also provided for async case handlers and as extensions on ",(0,r.kt)("inlineCode",{parentName:"p"},"Task<Error>"),"."),(0,r.kt)("p",{parentName:"admonition"},"There are also ",(0,r.kt)("inlineCode",{parentName:"p"},"Switch")," extension methods generated which are the 'void' versions of ",(0,r.kt)("inlineCode",{parentName:"p"},"Match"),", although this is not recommended from a functional point of view :)."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'static void PrintIfNotFound(Error error) =>\n        error.Switch(\n                notFound => Console.WriteLine($"Not found: {notFound.Message}"),\n                failure => { /*ignore*/ },\n                invalidInput => { /*ignore*/ }\n            );\n')),(0,r.kt)("p",{parentName:"admonition"},"To avoid bad surprises a well defined order of parameters of Match methods is crucial. By default parameters are generated in alphabetical order. This behaviour can be adapted using the ",(0,r.kt)("inlineCode",{parentName:"p"},"CaseOrder")," argument on ",(0,r.kt)("inlineCode",{parentName:"p"},"UnionType")," attribute (FunicularSwitch.Generators namespace omitted):"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"//default\n[UnionType(CaseOrder = CaseOrder.Alphabetical)]\npublic abstract class Error{...}\n\n//useful for union types the define their cases as nested subclasses in a well defined order\n[UnionType(CaseOrder = CaseOrder.AsDeclared)]\npublic abstract class Error{...}\n\n//order defined explicitly. Case sort index with [UnionCase] attribute on derived types is expected (generator warning if missing or ambigous)\n[UnionType(CaseOrder = CaseOrder.Explicit)]\npublic abstract class Error{...}\n\n[UnionCase(index: 0)]\npublic sealed class NotFound : Error {...}\n[UnionCase(index: 20)]\npublic sealed class Failure : Error {...}\n[UnionCase(index: 10)]\npublic sealed class InvalidInput : Error {...}\n")),(0,r.kt)("h4",{parentName:"admonition",id:"static-factory-methods"},"Static factory methods"),(0,r.kt)("p",{parentName:"admonition"},"If your base type is a partial record or class, static factory methods for your derived cases are added: "),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'[UnionType]\npublic abstract partial record Error;\n\npublic record NotFound(int Id, string? Message = "Not found") : Error;\npublic record InvalidInput(string Message) : Error;\n\nclass ExampleConsumer\n{\n    public static void UseGeneratedFactoryMethods()\n    {\n        var notFound = Error.NotFound(42); //default value is pulled up to factory methods.\n        var invalid = Error.InvalidInput("I don\'t like it");\n    }\n}\n')),(0,r.kt)("p",{parentName:"admonition"},"Those factory methods are not generated if they would conflict with an existing field, property or method on the base type.\nSo you can always decide to implement them by yourself. Generation of factory methods on a partial base type can be suppressed\nby setting StaticFactoryMethods argument to false: ",(0,r.kt)("inlineCode",{parentName:"p"},"[UnionType(StaticFactoryMethods=false)]"),". Currently default values in\nconstructor parameters from namespaces other than System need full qualification."),(0,r.kt)("p",{parentName:"admonition"},"If you like union types but don't like excessive typing in C# try the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bluehands/Switchyard"},"Switchyard")," Visual Studio extension, which generates the boilerplate code for you. It plays nicely with the FunicularSwitch.Generators package."),(0,r.kt)("h2",{parentName:"admonition",id:"extendedenum-attribute"},"ExtendedEnum attribute"),(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ExtendedEnum")," attribute works like ",(0,r.kt)("inlineCode",{parentName:"p"},"UnionType")," but for enums:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"[FunicularSwitch.Generators.ExtendedEnum]\npublic enum PlatformIdentifier\n{\n    LinuxDevice,\n    DeveloperMachine,\n    WindowsDevice\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"the generator detecting the ",(0,r.kt)("inlineCode",{parentName:"p"},"[ExtendedEnum]")," adds Match methods so you can write:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"var isGraphicalLinux = PlatformIdentifier.LinuxDevice\n    .Match(\n        developerMachine: () => false,\n        linuxDevice: () => true,\n        windowsDevice: () => true\n    );\n")),(0,r.kt)("p",{parentName:"admonition"},"The default case order for ",(0,r.kt)("inlineCode",{parentName:"p"},"ExtendedEnum")," is AsDeclared. To avoid problems with changing case orders, one should always use named parameters in Match and Switch calls!"),(0,r.kt)("p",{parentName:"admonition"},"To generate Match extensions for all types in an assembly use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExtendEnums")," attribute. Flags enums an enums with duplicate values are omitted:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"//generate internal Match extension methods for all enums in System (Containing assembly of System.DateTime). \n[assembly: ExtendEnums(typeof(System.DateTime), Accessibility = ExtensionAccessibility.Internal)]\n\n//shortcut to generate Match extension methods for all enums in current assembly\n[assembly: ExtendEnums]\n")),(0,r.kt)("p",{parentName:"admonition"},"To generate Match extensions for a specific type in an assembly write:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre"},"[assembly: ExtendEnum(typeof(DateTimeKind), CaseOrder = EnumCaseOrder.Alphabetic)]\n")),(0,r.kt)("h3",{parentName:"admonition",id:"additional-documentation"},"Additional documentation"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/bluehands/Funicular-Switch/blob/main/TUTORIAL.md"},"Tutorial markdown")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/bluehands/Funicular-Switch/tree/main/Source/Tutorial"},"Tutorial source")),(0,r.kt)("h1",{parentName:"admonition",id:"contributing"},"Contributing"),(0,r.kt)("p",{parentName:"admonition"},"We're looking forward to pull requests."),(0,r.kt)("h1",{parentName:"admonition",id:"versioning"},"Versioning"),(0,r.kt)("p",{parentName:"admonition"},"We use ",(0,r.kt)("a",{parentName:"p",href:"http://semver.org/"},"SemVer")," for versioning."),(0,r.kt)("h1",{parentName:"admonition",id:"authors"},"Authors"),(0,r.kt)("p",{parentName:"admonition"},"bluehands.de"),(0,r.kt)("h1",{parentName:"admonition",id:"license"},"License"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/bluehands/Funicular-Switch/blob/main/LICENSE"},"MIT License")),(0,r.kt)("h1",{parentName:"admonition",id:"acknowledgments"},"Acknowledgments"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://fsharpforfunandprofit.com/rop/"},"F# for fun and profit: Railway Oriented Programming")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://fsharpforfunandprofit.com/series/map-and-bind-and-apply-oh-my.html"},"F# for fun and profit: Map and Bind and Apply, Oh my!"))),(0,r.kt)("h3",{id:"about"},"About"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Generating discriminated unions for C# 9.0 and above.")),(0,r.kt)("h2",{id:"how-to-use"},"How to use"),(0,r.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,r.kt)("p",null,"This is the CSharp Project that references ",(0,r.kt)("strong",{parentName:"p"},"FunicularSwitch")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {19}",showLineNumbers:!0,"{19}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n \n    <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n\n \n    <ItemGroup>\n      <PackageReference Include="FunicularSwitch" Version="5.0.1" />\n      <PackageReference Include="FunicularSwitch.Generators" Version="3.2.0">\n        <PrivateAssets>all</PrivateAssets>\n        <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n      </PackageReference>\n    </ItemGroup>\n</Project>\n\n'))),(0,r.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\FunicularSwitch\\src\\Union\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"FunicularSwitch")," in ",(0,r.kt)("em",{parentName:"p"},"Program.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using Union;\n\nConsole.WriteLine("Save or not");\nvar data = SaveToDatabase.Save(0);\n\nConsole.WriteLine(data.Match(\n    ok => true,\n    error => false));\ndata = SaveToDatabase.Save(1);\nConsole.WriteLine(data.Match(ok => true, error => false));\n\n'))),(0,r.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\FunicularSwitch\\src\\Union\\ResultSave.cs",label:"ResultSave.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"FunicularSwitch")," in ",(0,r.kt)("em",{parentName:"p"},"ResultSave.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"namespace Union;\n\n[FunicularSwitch.Generators.ResultType(ErrorType = typeof(ErrorDetails))]\npublic abstract partial class ResultSave<T> { };\n\npublic class ErrorDetails\n{\n    \n}\n\n\n\n    //[FunicularSwitch.Generators.UnionType]\n    //public abstract partial class ResultSave { };\n\n    //public sealed partial record Success(int Value): ResultSave;\n    //public sealed partial record ValidationError(string Message):ResultSave;\n\n    ////public sealed partial record Ok(T Value) : ResultSave<T>;\n\n    ////public sealed partial record Error(Exception Exception) : ResultSave<T>;\n\n"))),(0,r.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\FunicularSwitch\\src\\Union\\SaveToDatabase.cs",label:"SaveToDatabase.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"FunicularSwitch")," in ",(0,r.kt)("em",{parentName:"p"},"SaveToDatabase.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Union;\ninternal class SaveToDatabase\n{\n    public static ResultSave<int> Save(int i)\n    {\n        if (i == 0)\n        {\n            return new ResultSave<int>.Error_(new ErrorDetails());\n        }\n        return new ResultSave<int>.Ok_(i);\n    }\n}\n\n")))),(0,r.kt)("h3",{id:"generated-files"},"Generated Files"),(0,r.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\FunicularSwitch\\src\\Union\\obj\\GX\\FunicularSwitch.Generators\\FunicularSwitch.Generators.EnumTypeGenerator\\Attributes.g.cs",label:"Attributes.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\n\n// ReSharper disable once CheckNamespace\nnamespace FunicularSwitch.Generators\n{\n    [AttributeUsage(AttributeTargets.Enum)]\n    sealed class ExtendedEnumAttribute : Attribute\n    {\n        public EnumCaseOrder CaseOrder { get; set; } = EnumCaseOrder.AsDeclared;\n        public ExtensionAccessibility Accessibility { get; set; } = ExtensionAccessibility.Public;\n    }\n    \n    enum EnumCaseOrder\n    {\n        Alphabetic,\n        AsDeclared\n    }\n\n    /// <summary>\n    /// Generate match methods for all enums defined in assembly that contains AssemblySpecifier.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]\n    class ExtendEnumsAttribute : Attribute\n    {\n        public Type AssemblySpecifier { get; }\n        public EnumCaseOrder CaseOrder { get; set; } = EnumCaseOrder.AsDeclared;\n        public ExtensionAccessibility Accessibility { get; set; } = ExtensionAccessibility.Public;\n\n        public ExtendEnumsAttribute() => AssemblySpecifier = typeof(ExtendEnumsAttribute);\n\n        public ExtendEnumsAttribute(Type assemblySpecifier)\n        {\n            AssemblySpecifier = assemblySpecifier;\n        }\n    }\n\n    /// <summary>\n    /// Generate match methods for Type. Must be enum.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]\n    class ExtendEnumAttribute : Attribute\n    {\n        public Type Type { get; }\n\n        public EnumCaseOrder CaseOrder { get; set; } = EnumCaseOrder.AsDeclared;\n\n        public ExtensionAccessibility Accessibility { get; set; } = ExtensionAccessibility.Public;\n\n        public ExtendEnumAttribute(Type type)\n        {\n            Type = type;\n        }\n    }\n\n    enum ExtensionAccessibility\n    {\n        Internal,\n        Public\n    }\n}\n"))),(0,r.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\FunicularSwitch\\src\\Union\\obj\\GX\\FunicularSwitch.Generators\\FunicularSwitch.Generators.ResultTypeGenerator\\Attributes.g.cs",label:"Attributes.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\n\n// ReSharper disable once CheckNamespace\nnamespace FunicularSwitch.Generators\n{\n    /// <summary>\n    /// Mark an abstract partial type with a single generic argument with the ResultType attribute.\n    /// This type from now on has Ok | Error semantics with map and bind operations.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Class, Inherited = false)]\n    sealed class ResultTypeAttribute : Attribute\n    {\n        public ResultTypeAttribute() => ErrorType = typeof(string);\n        public ResultTypeAttribute(Type errorType) => ErrorType = errorType;\n\n        public Type ErrorType { get; set; }\n    }\n\n    /// <summary>\n    /// Mark a static method or a member method or you error type with the MergeErrorAttribute attribute.\n    /// Static signature: TError -> TError -> TError. Member signature: TError -> TError\n    /// We are now able to collect errors and methods like Validate, Aggregate, FirstOk that are useful to combine results are generated.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Method, Inherited = false)]\n    sealed class MergeErrorAttribute : Attribute\n    {\n    }\n\n    /// <summary>\n    /// Mark a static method with the ExceptionToError attribute.\n    /// Signature: Exception -> TError\n    /// This method is always called, when an exception happens in a bind operation.\n    /// So a call like result.Map(i => i/0) will return an Error produced by the factory method instead of throwing the DivisionByZero exception.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Method, Inherited = false)]\n    sealed class ExceptionToError : Attribute\n    {\n    }\n}\n"))),(0,r.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\FunicularSwitch\\src\\Union\\obj\\GX\\FunicularSwitch.Generators\\FunicularSwitch.Generators.ResultTypeGenerator\\Union.ResultSave.g.cs",label:"Union.ResultSave.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'#nullable enable\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing FunicularSwitch;\n\nnamespace Union\n{\n#pragma warning disable 1591\n    public abstract partial class ResultSave\n    {\n        public static ResultSave<T> Error<T>(ErrorDetails details) => new ResultSave<T>.Error_(details);\n        public static ResultSave<T> Ok<T>(T value) => new ResultSave<T>.Ok_(value);\n        public bool IsError => GetType().GetGenericTypeDefinition() == typeof(ResultSave<>.Error_);\n        public bool IsOk => !IsError;\n        public abstract ErrorDetails? GetErrorOrDefault();\n\n        public static ResultSave<T> Try<T>(Func<T> action, Func<Exception, ErrorDetails> formatError)\n        {\n            try\n            {\n                return action();\n            }\n            catch (Exception e)\n            {\n                return Error<T>(formatError(e));\n            }\n        }\n\n        public static async Task<ResultSave<T>> Try<T>(Func<Task<T>> action, Func<Exception, ErrorDetails> formatError)\n        {\n            try\n            {\n                return await action();\n            }\n            catch (Exception e)\n            {\n                return Error<T>(formatError(e));\n            }\n        }\n    }\n\n    public abstract partial class ResultSave<T> : ResultSave, IEnumerable<T>\n    {\n        public static ResultSave<T> Error(ErrorDetails message) => Error<T>(message);\n        public static ResultSave<T> Ok(T value) => Ok<T>(value);\n\n        public static implicit operator ResultSave<T>(T value) => ResultSave.Ok(value);\n\n        public static bool operator true(ResultSave<T> result) => result.IsOk;\n        public static bool operator false(ResultSave<T> result) => result.IsError;\n\n        public static bool operator !(ResultSave<T> result) => result.IsError;\n\n        //just here to suppress warning, never called because all subtypes (Ok_, Error_) implement Equals and GetHashCode\n        bool Equals(ResultSave<T> other) => this switch\n        {\n            Ok_ ok => ok.Equals((object)other),\n            Error_ error => error.Equals((object)other),\n            _ => throw new InvalidOperationException($"Unexpected type derived from {nameof(ResultSave<T>)}")\n        };\n\n        public override int GetHashCode() => this switch\n        {\n            Ok_ ok => ok.GetHashCode(),\n            Error_ error => error.GetHashCode(),\n            _ => throw new InvalidOperationException($"Unexpected type derived from {nameof(ResultSave<T>)}")\n        };\n\n        public override bool Equals(object? obj)\n        {\n            if (ReferenceEquals(null, obj)) return false;\n            if (ReferenceEquals(this, obj)) return true;\n            if (obj.GetType() != this.GetType()) return false;\n            return Equals((ResultSave<T>)obj);\n        }\n\n        public static bool operator ==(ResultSave<T>? left, ResultSave<T>? right) => Equals(left, right);\n\n        public static bool operator !=(ResultSave<T>? left, ResultSave<T>? right) => !Equals(left, right);\n\n        public void Match(Action<T> ok, Action<ErrorDetails>? error = null) => Match(\n            v =>\n            {\n                ok.Invoke(v);\n                return 42;\n            },\n            err =>\n            {\n                error?.Invoke(err);\n                return 42;\n            });\n\n        public T1 Match<T1>(Func<T, T1> ok, Func<ErrorDetails, T1> error)\n        {\n            return this switch\n            {\n                Ok_ okResultSave => ok(okResultSave.Value),\n                Error_ errorResultSave => error(errorResultSave.Details),\n                _ => throw new InvalidOperationException($"Unexpected derived result type: {GetType()}")\n            };\n        }\n\n        public async Task<T1> Match<T1>(Func<T, Task<T1>> ok, Func<ErrorDetails, Task<T1>> error)\n        {\n            return this switch\n            {\n                Ok_ okResultSave => await ok(okResultSave.Value).ConfigureAwait(false),\n                Error_ errorResultSave => await error(errorResultSave.Details).ConfigureAwait(false),\n                _ => throw new InvalidOperationException($"Unexpected derived result type: {GetType()}")\n            };\n        }\n\n        public Task<T1> Match<T1>(Func<T, Task<T1>> ok, Func<ErrorDetails, T1> error) =>\n            Match(ok, e => Task.FromResult(error(e)));\n\n        public async Task Match(Func<T, Task> ok)\n        {\n            if (this is Ok_ okResultSave) await ok(okResultSave.Value).ConfigureAwait(false);\n        }\n\n        public T Match(Func<ErrorDetails, T> error) => Match(v => v, error);\n\n        public ResultSave<T1> Bind<T1>(Func<T, ResultSave<T1>> bind)\n        {\n            switch (this)\n            {\n                case Ok_ ok:\n                    try\n                    {\n                        return bind(ok.Value);\n                    }\n                    // ReSharper disable once RedundantCatchClause\n#pragma warning disable CS0168 // Variable is declared but never used\n                    catch (Exception e)\n#pragma warning restore CS0168 // Variable is declared but never used\n                    {\n                        throw; //createGenericErrorResult\n                    }\n                case Error_ error:\n                    return error.Convert<T1>();\n                default:\n                    throw new InvalidOperationException($"Unexpected derived result type: {GetType()}");\n            }\n        }\n\n        public async Task<ResultSave<T1>> Bind<T1>(Func<T, Task<ResultSave<T1>>> bind)\n        {\n            switch (this)\n            {\n                case Ok_ ok:\n                    try\n                    {\n                        return await bind(ok.Value).ConfigureAwait(false);\n                    }\n                    // ReSharper disable once RedundantCatchClause\n#pragma warning disable CS0168 // Variable is declared but never used\n                    catch (Exception e)\n#pragma warning restore CS0168 // Variable is declared but never used\n                    {\n                        throw; //createGenericErrorResult\n                    }\n                case Error_ error:\n                    return error.Convert<T1>();\n                default:\n                    throw new InvalidOperationException($"Unexpected derived result type: {GetType()}");\n            }\n        }\n\n        public ResultSave<T1> Map<T1>(Func<T, T1> map)\n            => Bind(value => Ok(map(value)));\n\n        public Task<ResultSave<T1>> Map<T1>(Func<T, Task<T1>> map)\n            => Bind(async value => Ok(await map(value).ConfigureAwait(false)));\n\n        public T? GetValueOrDefault()\n            => Match(\n                v => (T?)v,\n                _ => default\n            );\n\n        public T GetValueOrDefault(Func<T> defaultValue)\n            => Match(\n                v => v,\n                _ => defaultValue()\n            );\n\n        public T GetValueOrDefault(T defaultValue)\n            => Match(\n                v => v,\n                _ => defaultValue\n            );\n\n        public T GetValueOrThrow()\n            => Match(\n                v => v,\n                details => throw new InvalidOperationException($"Cannot access error result value. Error: {details}"));\n\n        public IEnumerator<T> GetEnumerator() => Match(ok => new[] { ok }, _ => Enumerable.Empty<T>()).GetEnumerator();\n\n        public override string ToString() => Match(ok => $"Ok {ok?.ToString()}", error => $"Error {error}");\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\n        public sealed partial class Ok_ : ResultSave<T>\n        {\n            public T Value { get; }\n\n            public Ok_(T value) => Value = value;\n\n            public override ErrorDetails? GetErrorOrDefault() => null;\n\n            public bool Equals(Ok_? other)\n            {\n                if (ReferenceEquals(null, other)) return false;\n                if (ReferenceEquals(this, other)) return true;\n                return EqualityComparer<T>.Default.Equals(Value, other.Value);\n            }\n\n            public override bool Equals(object? obj)\n            {\n                if (ReferenceEquals(null, obj)) return false;\n                if (ReferenceEquals(this, obj)) return true;\n                return obj is Ok_ other && Equals(other);\n            }\n\n            public override int GetHashCode() => Value == null ? 0 : EqualityComparer<T>.Default.GetHashCode(Value);\n\n            public static bool operator ==(Ok_ left, Ok_ right) => Equals(left, right);\n\n            public static bool operator !=(Ok_ left, Ok_ right) => !Equals(left, right);\n        }\n\n        public sealed partial class Error_ : ResultSave<T>\n        {\n            public ErrorDetails Details { get; }\n\n            public Error_(ErrorDetails details) => Details = details;\n\n            public ResultSave<T1>.Error_ Convert<T1>() => new ResultSave<T1>.Error_(Details);\n\n            public override ErrorDetails? GetErrorOrDefault() => Details;\n\n            public bool Equals(Error_? other)\n            {\n                if (ReferenceEquals(null, other)) return false;\n                if (ReferenceEquals(this, other)) return true;\n                return Equals(Details, other.Details);\n            }\n\n            public override bool Equals(object? obj)\n            {\n                if (ReferenceEquals(null, obj)) return false;\n                if (ReferenceEquals(this, obj)) return true;\n                return obj is Error_ other && Equals(other);\n            }\n\n            public override int GetHashCode() => Details.GetHashCode();\n\n            public static bool operator ==(Error_ left, Error_ right) => Equals(left, right);\n\n            public static bool operator !=(Error_ left, Error_ right) => !Equals(left, right);\n        }\n\n    }\n\n    public static partial class ResultSaveExtension\n    {\n        #region bind\n\n        public static async Task<ResultSave<T1>> Bind<T, T1>(\n            this Task<ResultSave<T>> result,\n            Func<T, ResultSave<T1>> bind)\n            => (await result.ConfigureAwait(false)).Bind(bind);\n\n        public static async Task<ResultSave<T1>> Bind<T, T1>(\n            this Task<ResultSave<T>> result,\n            Func<T, Task<ResultSave<T1>>> bind)\n            => await (await result.ConfigureAwait(false)).Bind(bind).ConfigureAwait(false);\n\n        #endregion\n\n        #region map\n\n        public static async Task<ResultSave<T1>> Map<T, T1>(\n            this Task<ResultSave<T>> result,\n            Func<T, T1> map)\n            => (await result.ConfigureAwait(false)).Map(map);\n\n        public static Task<ResultSave<T1>> Map<T, T1>(\n            this Task<ResultSave<T>> result,\n            Func<T, Task<T1>> bind)\n            => Bind(result, async v => ResultSave.Ok(await bind(v).ConfigureAwait(false)));\n\n        public static ResultSave<T> MapError<T>(this ResultSave<T> result, Func<ErrorDetails, ErrorDetails> mapError) =>\n            result.Match(ok => ok, error => ResultSave.Error<T>(mapError(error)));\n\n        #endregion\n\n        #region match\n\n        public static async Task<T1> Match<T, T1>(\n            this Task<ResultSave<T>> result,\n            Func<T, Task<T1>> ok,\n            Func<ErrorDetails, Task<T1>> error)\n            => await (await result.ConfigureAwait(false)).Match(ok, error).ConfigureAwait(false);\n\n        public static async Task<T1> Match<T, T1>(\n            this Task<ResultSave<T>> result,\n            Func<T, Task<T1>> ok,\n            Func<ErrorDetails, T1> error)\n            => await (await result.ConfigureAwait(false)).Match(ok, error).ConfigureAwait(false);\n\n        public static async Task<T1> Match<T, T1>(\n            this Task<ResultSave<T>> result,\n            Func<T, T1> ok,\n            Func<ErrorDetails, T1> error)\n            => (await result.ConfigureAwait(false)).Match(ok, error);\n\n        #endregion\n\n        public static ResultSave<T> Flatten<T>(this ResultSave<ResultSave<T>> result) => result.Bind(r => r);\n\n        public static ResultSave<T1> As<T, T1>(this ResultSave<T> result, Func<ErrorDetails> errorTIsNotT1) =>\n            result.Bind(r =>\n            {\n                if (r is T1 converted)\n                    return converted;\n                return ResultSave.Error<T1>(errorTIsNotT1());\n            });\n\n        public static ResultSave<T1> As<T1>(this ResultSave<object> result, Func<ErrorDetails> errorIsNotT1) =>\n            result.As<object, T1>(errorIsNotT1);\n        \n        #region query-expression pattern\n        \n        public static ResultSave<T1> Select<T, T1>(this ResultSave<T> result, Func<T, T1> selector) => result.Map(selector);\n        public static Task<ResultSave<T1>> Select<T, T1>(this Task<ResultSave<T>> result, Func<T, T1> selector) => result.Map(selector);\n        \n        public static ResultSave<T2> SelectMany<T, T1, T2>(this ResultSave<T> result, Func<T, ResultSave<T1>> selector, Func<T, T1, T2> resultSelector) => result.Bind(t => selector(t).Map(t1 => resultSelector(t, t1)));\n        public static Task<ResultSave<T2>> SelectMany<T, T1, T2>(this Task<ResultSave<T>> result, Func<T, Task<ResultSave<T1>>> selector, Func<T, T1, T2> resultSelector) => result.Bind(t => selector(t).Map(t1 => resultSelector(t, t1)));\n        public static Task<ResultSave<T2>> SelectMany<T, T1, T2>(this Task<ResultSave<T>> result, Func<T, ResultSave<T1>> selector, Func<T, T1, T2> resultSelector) => result.Bind(t => selector(t).Map(t1 => resultSelector(t, t1)));\n        public static Task<ResultSave<T2>> SelectMany<T, T1, T2>(this ResultSave<T> result, Func<T, Task<ResultSave<T1>>> selector, Func<T, T1, T2> resultSelector) => result.Bind(t => selector(t).Map(t1 => resultSelector(t, t1)));\n\n        #endregion\n    }\n}\n\nnamespace Union.Extensions\n{\n    public static partial class ResultSaveExtension\n    {\n        public static IEnumerable<T1> Choose<T, T1>(\n            this IEnumerable<T> items,\n            Func<T, ResultSave<T1>> choose,\n            Action<ErrorDetails> onError)\n            => items\n                .Select(i => choose(i))\n                .Choose(onError);\n\n        public static IEnumerable<T> Choose<T>(\n            this IEnumerable<ResultSave<T>> results,\n            Action<ErrorDetails> onError)\n            => results\n                .Where(r =>\n                    r.Match(_ => true, error =>\n                    {\n                        onError(error);\n                        return false;\n                    }))\n                .Select(r => r.GetValueOrThrow());\n\n        public static ResultSave<T> As<T>(this object item, Func<ErrorDetails> error) =>\n            !(item is T t) ? ResultSave.Error<T>(error()) : t;\n\n        public static ResultSave<T> NotNull<T>(this T? item, Func<ErrorDetails> error) =>\n            item ?? ResultSave.Error<T>(error());\n\n        public static ResultSave<string> NotNullOrEmpty(this string? s, Func<ErrorDetails> error)\n            => string.IsNullOrEmpty(s) ? ResultSave.Error<string>(error()) : s!;\n\n        public static ResultSave<string> NotNullOrWhiteSpace(this string? s, Func<ErrorDetails> error)\n            => string.IsNullOrWhiteSpace(s) ? ResultSave.Error<string>(error()) : s!;\n\n        public static ResultSave<T> First<T>(this IEnumerable<T> candidates, Func<T, bool> predicate, Func<ErrorDetails> noMatch) =>\n            candidates\n                .FirstOrDefault(i => predicate(i))\n                .NotNull(noMatch);\n    }\n#pragma warning restore 1591\n}\n\n'))),(0,r.kt)(s.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\FunicularSwitch\\src\\Union\\obj\\GX\\FunicularSwitch.Generators\\FunicularSwitch.Generators.UnionTypeGenerator\\Attributes.g.cs",label:"Attributes.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using System;\n\n// ReSharper disable once CheckNamespace\nnamespace FunicularSwitch.Generators\n{\n    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, Inherited = false)]\n    sealed class UnionTypeAttribute : Attribute\n    {\n        public CaseOrder CaseOrder { get; set; } = CaseOrder.Alphabetic;\n        public bool StaticFactoryMethods { get; set; } = true;\n    }\n\n    enum CaseOrder\n    {\n        Alphabetic,\n        AsDeclared,\n        Explicit\n    }\n\n    [AttributeUsage(AttributeTargets.Class, Inherited = false)]\n    sealed class UnionCaseAttribute : Attribute\n    {\n        public UnionCaseAttribute(int index) => Index = index;\n\n        public int Index { get; }\n    }\n}\n")))),(0,r.kt)("h2",{id:"usefull"},"Usefull"),(0,r.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{target:"_blank",href:n(93909).Z},"Download Example project FunicularSwitch "))),(0,r.kt)("h3",{id:"share-funicularswitch"},"Share FunicularSwitch"),(0,r.kt)("ul",null,(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FFunicularSwitch&quote=FunicularSwitch",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FFunicularSwitch&text=FunicularSwitch:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FFunicularSwitch",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FFunicularSwitch&title=FunicularSwitch",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FFunicularSwitch&title=FunicularSwitch&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FFunicularSwitch",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/FunicularSwitch"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/FunicularSwitch")),(0,r.kt)("h2",{id:"in-the-same-category-functionalprogramming"},"In the same category (FunctionalProgramming)"),(0,r.kt)("h3",{id:"cachesourcegenerator"},(0,r.kt)("a",{parentName:"h3",href:"/docs/cachesourcegenerator"},"cachesourcegenerator")),(0,r.kt)("h3",{id:"dunet"},(0,r.kt)("a",{parentName:"h3",href:"/docs/dunet"},"dunet")),(0,r.kt)("h3",{id:"funckydiscriminatedunion"},(0,r.kt)("a",{parentName:"h3",href:"/docs/Funcky.DiscriminatedUnion"},"Funcky.DiscriminatedUnion")),(0,r.kt)("h3",{id:"nsourcegeneratorsuniontypes"},(0,r.kt)("a",{parentName:"h3",href:"/docs/N.SourceGenerators.UnionTypes"},"N.SourceGenerators.UnionTypes")),(0,r.kt)("h3",{id:"oneof"},(0,r.kt)("a",{parentName:"h3",href:"/docs/OneOf"},"OneOf")),(0,r.kt)("h3",{id:"partiallyapplied"},(0,r.kt)("a",{parentName:"h3",href:"/docs/PartiallyApplied"},"PartiallyApplied")),(0,r.kt)("h3",{id:"rscg_utils_memo"},(0,r.kt)("a",{parentName:"h3",href:"/docs/RSCG_Utils_Memo"},"RSCG_Utils_Memo")))}g.isMDXComponent=!0},93909:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/FunicularSwitch-d69bd89c59127e8bb0b6a1901d06beda.zip"}}]);