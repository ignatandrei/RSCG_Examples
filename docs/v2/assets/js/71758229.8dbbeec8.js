"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[4620],{4137:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),p=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(c.Provider,{value:n},e.children)},l="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),l=p(t),g=a,d=l["".concat(c,".").concat(g)]||l[g]||m[g]||s;return t?r.createElement(d,o(o({ref:n},u),{},{components:t})):r.createElement(d,o({ref:n},u))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,o=new Array(s);o[0]=g;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[l]="string"==typeof e?e:a,o[1]=i;for(var p=2;p<s;p++)o[p]=t[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},3353:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var r=t(7462),a=(t(7294),t(4137));const s={sidebar_position:9679,title:"9679 - System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",description:"System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",slug:"/Microsoft/System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator"},o="System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",i={unversionedId:"Microsoft/System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",id:"Microsoft/System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",title:"9679 - System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",description:"System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",source:"@site/docs/Microsoft/System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator.md",sourceDirName:"Microsoft",slug:"/Microsoft/System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",permalink:"/RSCG_Examples/v2/docs/Microsoft/System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",draft:!1,tags:[],version:"current",sidebarPosition:9679,frontMatter:{sidebar_position:9679,title:"9679 - System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",description:"System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator",slug:"/Microsoft/System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator"},sidebar:"tutorialSidebar",previous:{title:"9236 - Microsoft.Interop.JavaScript.JSImportGenerator_Microsoft.Interop.JavaScript.JSExportGenerator",permalink:"/RSCG_Examples/v2/docs/Microsoft/Microsoft.Interop.JavaScript.JSImportGenerator_Microsoft.Interop.JavaScript.JSExportGenerator"},next:{title:"9939 - Microsoft.NET.Sdk.Razor.SourceGenerators_Microsoft.NET.Sdk.Razor.SourceGenerators.RazorSourceGenerator",permalink:"/RSCG_Examples/v2/docs/Microsoft/Microsoft.NET.Sdk.Razor.SourceGenerators_Microsoft.NET.Sdk.Razor.SourceGenerators.RazorSourceGenerator"}},c={},p=[{value:"Original Code",id:"original-code",level:2},{value:"Generated Code",id:"generated-code",level:2},{value:"More details",id:"more-details",level:2}],u={toc:p},l="wrapper";function m(e){let{components:n,...s}=e;return(0,a.kt)(l,(0,r.Z)({},u,s,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"systemtextregularexpressionsgenerator_systemtextregularexpressionsgeneratorregexgenerator"},"System.Text.RegularExpressions.Generator_System.Text.RegularExpressions.Generator.RegexGenerator"),(0,a.kt)("h2",{id:"original-code"},"Original Code"),(0,a.kt)("p",null,"The code that will be improved by generation is :"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using System.Text.RegularExpressions;\n\nnamespace Demo;\n\npublic partial class DemoRegex\n{\n    //Generator:RegexGenerator.g.cs\n    [GeneratedRegex("abc|def", RegexOptions.IgnoreCase, "en-US")]\n    private static partial Regex AbcOrDefGeneratedRegex();\n\n    public static bool EvaluateText(string text)\n    {\n        return (AbcOrDefGeneratedRegex().IsMatch(text));\n        \n    }\n}\n\n')),(0,a.kt)("h2",{id:"generated-code"},"Generated Code"),(0,a.kt)("p",null,"The code that is written is"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated/>\n#nullable enable\n#pragma warning disable CS0162 // Unreachable code\n#pragma warning disable CS0164 // Unreferenced label\n#pragma warning disable CS0219 // Variable assigned but never used\n\nnamespace Demo\n{\n    partial class DemoRegex\n    {\n        /// <remarks>\n        /// Pattern explanation:<br/>\n        /// <code>\n        /// \u25cb Match with 2 alternative expressions, atomically.<br/>\n        ///     \u25cb Match a sequence of expressions.<br/>\n        ///         \u25cb Match a character in the set [Aa].<br/>\n        ///         \u25cb Match a character in the set [Bb].<br/>\n        ///         \u25cb Match a character in the set [Cc].<br/>\n        ///     \u25cb Match a sequence of expressions.<br/>\n        ///         \u25cb Match a character in the set [Dd].<br/>\n        ///         \u25cb Match a character in the set [Ee].<br/>\n        ///         \u25cb Match a character in the set [Ff].<br/>\n        /// </code>\n        /// </remarks>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "7.0.8.32018")]\n        private static partial global::System.Text.RegularExpressions.Regex AbcOrDefGeneratedRegex() => global::System.Text.RegularExpressions.Generated.AbcOrDefGeneratedRegex_0.Instance;\n    }\n}\n\nnamespace System.Text.RegularExpressions.Generated\n{\n    using System;\n    using System.CodeDom.Compiler;\n    using System.Collections;\n    using System.ComponentModel;\n    using System.Globalization;\n    using System.Runtime.CompilerServices;\n    using System.Text.RegularExpressions;\n    using System.Threading;\n\n    /// <summary>Custom <see cref="Regex"/>-derived type for the AbcOrDefGeneratedRegex method.</summary>\n    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "7.0.8.32018")]\n    file sealed class AbcOrDefGeneratedRegex_0 : Regex\n    {\n        /// <summary>Cached, thread-safe singleton instance.</summary>\n        internal static readonly AbcOrDefGeneratedRegex_0 Instance = new();\n    \n        /// <summary>Initializes the instance.</summary>\n        private AbcOrDefGeneratedRegex_0()\n        {\n            base.pattern = "abc|def";\n            base.roptions = RegexOptions.IgnoreCase;\n            ValidateMatchTimeout(Utilities.s_defaultTimeout);\n            base.internalMatchTimeout = Utilities.s_defaultTimeout;\n            base.factory = new RunnerFactory();\n            base.capsize = 1;\n        }\n    \n        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>\n        private sealed class RunnerFactory : RegexRunnerFactory\n        {\n            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>\n            protected override RegexRunner CreateInstance() => new Runner();\n        \n            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>\n            private sealed class Runner : RegexRunner\n            {\n                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>\n                /// <param name="inputSpan">The text being scanned by the regular expression.</param>\n                protected override void Scan(ReadOnlySpan<char> inputSpan)\n                {\n                    // Search until we can\'t find a valid starting position, we find a match, or we reach the end of the input.\n                    while (TryFindNextPossibleStartingPosition(inputSpan) &&\n                           !TryMatchAtCurrentPosition(inputSpan) &&\n                           base.runtextpos != inputSpan.Length)\n                    {\n                        base.runtextpos++;\n                        if (Utilities.s_hasTimeout)\n                        {\n                            base.CheckTimeout();\n                        }\n                    }\n                }\n        \n                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>\n                /// <param name="inputSpan">The text being scanned by the regular expression.</param>\n                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>\n                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)\n                {\n                    int pos = base.runtextpos;\n                    ulong charMinusLow;\n                    \n                    // Any possible match is at least 3 characters.\n                    if (pos <= inputSpan.Length - 3)\n                    {\n                        // The pattern matches a character in the set [CFcf] at index 2.\n                        // Find the next occurrence. If it can\'t be found, there\'s no match.\n                        ReadOnlySpan<char> span = inputSpan.Slice(pos);\n                        for (int i = 0; i < span.Length - 2; i++)\n                        {\n                            int indexOfPos = span.Slice(i + 2).IndexOfAny("CFcf");\n                            if (indexOfPos < 0)\n                            {\n                                goto NoMatchFound;\n                            }\n                            i += indexOfPos;\n                            \n                            if (((long)((0x9000000090000000UL << (int)(charMinusLow = (uint)span[i] - \'A\')) & (charMinusLow - 64)) < 0) &&\n                                ((long)((0x9000000090000000UL << (int)(charMinusLow = (uint)span[i + 1] - \'B\')) & (charMinusLow - 64)) < 0))\n                            {\n                                base.runtextpos = pos + i;\n                                return true;\n                            }\n                        }\n                    }\n                    \n                    // No match found.\n                    NoMatchFound:\n                    base.runtextpos = inputSpan.Length;\n                    return false;\n                }\n        \n                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>\n                /// <param name="inputSpan">The text being scanned by the regular expression.</param>\n                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>\n                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)\n                {\n                    int pos = base.runtextpos;\n                    int matchStart = pos;\n                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);\n                    \n                    // Match with 2 alternative expressions, atomically.\n                    {\n                        if (slice.IsEmpty)\n                        {\n                            return false; // The input didn\'t match.\n                        }\n                        \n                        switch (slice[0])\n                        {\n                            case \'A\' or \'a\':\n                                if ((uint)slice.Length < 3 ||\n                                    !slice.Slice(1).StartsWith("bc", StringComparison.OrdinalIgnoreCase)) // Match the string "bc" (ordinal case-insensitive)\n                                {\n                                    return false; // The input didn\'t match.\n                                }\n                                \n                                pos += 3;\n                                slice = inputSpan.Slice(pos);\n                                break;\n                                \n                            case \'D\' or \'d\':\n                                if ((uint)slice.Length < 3 ||\n                                    !slice.Slice(1).StartsWith("ef", StringComparison.OrdinalIgnoreCase)) // Match the string "ef" (ordinal case-insensitive)\n                                {\n                                    return false; // The input didn\'t match.\n                                }\n                                \n                                pos += 3;\n                                slice = inputSpan.Slice(pos);\n                                break;\n                                \n                            default:\n                                return false; // The input didn\'t match.\n                        }\n                    }\n                    \n                    // The input matched.\n                    base.runtextpos = pos;\n                    base.Capture(0, matchStart, pos);\n                    return true;\n                }\n            }\n        }\n\n    }\n    \n    /// <summary>Helper methods used by generated <see cref="Regex"/>-derived implementations.</summary>\n    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "7.0.8.32018")]\n    file static class Utilities\n    {\n        /// <summary>Default timeout value set in <see cref="AppContext"/>, or <see cref="Regex.InfiniteMatchTimeout"/> if none was set.</summary>\n        internal static readonly TimeSpan s_defaultTimeout = AppContext.GetData("REGEX_DEFAULT_MATCH_TIMEOUT") is TimeSpan timeout ? timeout : Regex.InfiniteMatchTimeout;\n        \n        /// <summary>Whether <see cref="s_defaultTimeout"/> is non-infinite.</summary>\n        internal static readonly bool s_hasTimeout = s_defaultTimeout != Timeout.InfiniteTimeSpan;\n    }\n}\n\n')),(0,a.kt)("h2",{id:"more-details"},"More details"),(0,a.kt)("p",null,"Csharp Project: See DemoRegex.csproj from ",(0,a.kt)("a",{target:"_blank",href:t(2096).Z},"/sources/Microsoft.zip")),(0,a.kt)("p",null,"You can see the whole list at",(0,a.kt)("a",{target:"_blank",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/List-of-RSCG"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/List-of-RSCG")))}m.isMDXComponent=!0},2096:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/files/Microsoft-54b23668527b40e1c8c124d6241922af.zip"}}]);