"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[2629],{90008:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>m,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),o=n(73992),i=n(18679),s=n(68839);const d={sidebar_position:1450,title:"145 - DotnetYang",description:"Generating source code from YANG models",slug:"/DotnetYang"},l="DotnetYang  by Westermo Network Technologies",m={unversionedId:"RSCG-Examples/DotnetYang",id:"RSCG-Examples/DotnetYang",title:"145 - DotnetYang",description:"Generating source code from YANG models",source:"@site/docs/RSCG-Examples/DotnetYang.md",sourceDirName:"RSCG-Examples",slug:"/DotnetYang",permalink:"/RSCG_Examples/v2/docs/DotnetYang",draft:!1,tags:[],version:"current",sidebarPosition:1450,frontMatter:{sidebar_position:1450,title:"145 - DotnetYang",description:"Generating source code from YANG models",slug:"/DotnetYang"},sidebar:"tutorialSidebar",previous:{title:"144 - depso",permalink:"/RSCG_Examples/v2/docs/depso"},next:{title:"146 - RSCG_IFormattable",permalink:"/RSCG_Examples/v2/docs/RSCG_IFormattable"}},p={},c=[{value:"Nuget / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share DotnetYang",id:"share-dotnetyang",level:3},{value:"In the same category (FilesToCode) - 13 other generators",id:"in-the-same-category-filestocode---13-other-generators",level:3},{value:"Chorn.EmbeddedResourceAccessGenerator",id:"chornembeddedresourceaccessgenerator",level:4},{value:"corecraft",id:"corecraft",level:4},{value:"Datacute.EmbeddedResourcePropertyGenerator",id:"datacuteembeddedresourcepropertygenerator",level:4},{value:"EmbedResourceCSharp",id:"embedresourcecsharp",level:4},{value:"LingoGen",id:"lingogen",level:4},{value:"NotNotAppSettings",id:"notnotappsettings",level:4},{value:"Podimo.ConstEmbed",id:"podimoconstembed",level:4},{value:"ResXGenerator",id:"resxgenerator",level:4},{value:"RSCG_JSON2Class",id:"rscg_json2class",level:4},{value:"RSCG_Utils",id:"rscg_utils",level:4},{value:"ThisAssembly_Resources",id:"thisassembly_resources",level:4},{value:"ThisAssembly.Strings",id:"thisassemblystrings",level:4},{value:"Weave",id:"weave",level:4}],u={toc:c},g="wrapper";function h(e){let{components:t,...d}=e;return(0,r.kt)(g,(0,a.Z)({},u,d,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"dotnetyang--by-westermo-network-technologies"},"DotnetYang  by Westermo Network Technologies"),(0,r.kt)(s.Z,{toc:c,mdxType:"TOCInline"}),(0,r.kt)("h2",{id:"nuget--site-data"},"Nuget / site data"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/DotnetYang/"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/DotnetYang?label=DotnetYang",alt:"Nuget"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/westermo/DotnetYang"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/westermo/DotnetYang?label=updated",alt:"GitHub last commit"})),"\n",(0,r.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/westermo/DotnetYang?style=social",alt:"GitHub Repo stars"})),(0,r.kt)("h2",{id:"details"},"Details"),(0,r.kt)("h3",{id:"info"},"Info"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Name: ",(0,r.kt)("strong",{parentName:"p"},"DotnetYang")),(0,r.kt)("p",{parentName:"admonition"},"Package Description"),(0,r.kt)("p",{parentName:"admonition"},"Author: Westermo Network Technologies"),(0,r.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/DotnetYang/"},"https://www.nuget.org/packages/DotnetYang/")),"   "),(0,r.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/westermo/DotnetYang"},"https://github.com/westermo/DotnetYang")),(0,r.kt)("p",{parentName:"admonition"},"Source : ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/westermo/DotnetYang"},"https://github.com/westermo/DotnetYang"))),(0,r.kt)("h3",{id:"original-readme"},"Original Readme"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/dotnetYang/"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/v/dotnetYang?style=flat-square",alt:"Nuget (Generator)"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/westermo/dotnetYang/actions"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/actions/workflow/status/westermo/dotnetYang/build.yml?branch=main&style=flat-square",alt:"Build"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/westermo/dotnetYang/blob/develop/LICENSE"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/license/westermo/dotnetYang?style=flat-square",alt:"License"}))),(0,r.kt)("p",{parentName:"admonition"},"dotnetYang is a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/dotnet/roslyn"},"Roslyn")," source generator for using the .yang language to generate C# code, providing access to data models, ease-of-use asynchronous RPC, Action & Notification calls directly from code and generated server interfaces."),(0,r.kt)("h2",{parentName:"admonition",id:"features"},"Features"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Drop-and-go:")," Add your .yang files to a C# project as additional files that references this generator, that is it, your .yang defined RPC's and more are now available directly in  that C# projects code"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Server-interface:")," Want to implement a server that responds to NETCONF calls? Look no further than the generated interface ",(0,r.kt)("inlineCode",{parentName:"li"},"IYangServer")," and it's extension method ",(0,r.kt)("inlineCode",{parentName:"li"},"async Task Recieve(this IYangServer server, Stream input, Stream output);")," which provides a framework for implementing your own server without having to worry about serializing and parsing NETCONF directly, but instead work with well defined C# Datatypes.")),(0,r.kt)("h2",{parentName:"admonition",id:"documentation"},"Documentation"),(0,r.kt)("h3",{parentName:"admonition",id:"getting-started"},"Getting Started"),(0,r.kt)("p",{parentName:"admonition"},"In order to start using ",(0,r.kt)("inlineCode",{parentName:"p"},"dotnetYang")," on a new .csproj project, start by adding the nuget packages by, for example, using the dotnet CLI in your project directory:\n",(0,r.kt)("inlineCode",{parentName:"p"},"dotnet add package dotnetYang")),(0,r.kt)("p",{parentName:"admonition"},"Afterwards, create or add a .yang file to said project:\n",(0,r.kt)("inlineCode",{parentName:"p"},"some-module.yang")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-yang"},'module some-module {\n    yang-version 1.1;\n    namespace "urn:dotnet:yang:some:module";\n    prefix sm;\n    identity someIdentity;\n    identity someOtherIdentity\n    {\n        base someIdentity;\n    }\n    rpc doSomething {\n        input {\n            leaf the-big-leaf\n            {\n                type uint32;\n                default "4";\n                description "The value that is the input of the doSomething rpc";\n            }\n        }\n        output {\n            leaf response\n            {\n                type identityref\n                {\n                    base someIdentity;\n                }\n                default "someOtherIdentity";\n                description "The identity that is the output of the doSomething rpc";\n            }\n        }\n    }\n}\n')),(0,r.kt)("p",{parentName:"admonition"},"And then add it as an additional file to your .csproj file"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<Project Sdk="Microsoft.NET.Sdk">\n    \x3c!--Other parts of the .csproj file --\x3e\n    <ItemGroup>\n        <AdditionalFiles Include="some-module.yang" />\n    </ItemGroup>\n    \x3c!--Other parts of the .csproj file --\x3e\n</Project>\n')),(0,r.kt)("p",{parentName:"admonition"},"Now the generated C# code from ",(0,r.kt)("inlineCode",{parentName:"p"},"some-module.yang")," will be available, with it's naming conventions adjusted to be C# compliant"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'namespace MyProject;\npublic class Program\n{\n  public static async Task Main()\n  {\n      IChannel channel = //...Code for setting up whatever channel you want to send the rpc over\n      int messageID = //...Code for getting message id;\n      //Set up the rpc input, not the slight name changes\n      Some.Module.YangNode.DoSomethingInput input = new Some.Module.YangNode.DoSomethingInput\n      {\n          TheBigLeaf = 123\n      };\n      //Call the rpc function, note the slight name changes and the asynchronous nature of the call\n      Some.Module.YangNode.DoSomethingOutput output = await Some.Module.YangNode.DoSomething(channel, messageID, input);\n      //Write the "response" leaf of the output to console.\n      Console.WriteLine(output.Response);\n  }\n}\n')),(0,r.kt)("h3",{parentName:"admonition",id:"server-creation"},"Server creation"),(0,r.kt)("p",{parentName:"admonition"},"Say that you want to create a server that can response to calls defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"some-module.yang"),", then you would create a class that implementes the generated ",(0,r.kt)("inlineCode",{parentName:"p"},"IYangServer")," interface, which might look something like this:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'using Some.Module;\nnamespace MyProject;\npublic class Server : IYangServer\n{\n    public async Task<YangNode.DoSomethingOutput> OnDoSomething(YangNode.DoSomethingInput input)\n    {\n        //Do whatever it is the server is expected to do when told to "doSomething"...\n        //Await something, do something else, the options are endless...\n        \n        //Create the output, not nessecarily like this..\n        YangNode.DoSomethingOutput output = new YangNode.DoSomethingOutput(); \n        return output;\n    }\n}\n')),(0,r.kt)("p",{parentName:"admonition"},"Of course, if there are a lot of yang modules in a project, ",(0,r.kt)("inlineCode",{parentName:"p"},"IYangServer")," runs the risk of becoming rather big. In such a case, it is recommended to split it's implementation into several ",(0,r.kt)("inlineCode",{parentName:"p"},"partial")," server classes in order to maintain readability.  ")),(0,r.kt)("h3",{id:"about"},"About"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Generating source code from YANG models")),(0,r.kt)("h2",{id:"how-to-use"},"How to use"),(0,r.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,r.kt)("p",null,"This is the CSharp Project that references ",(0,r.kt)("strong",{parentName:"p"},"DotnetYang")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {20}",showLineNumbers:!0,"{20}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  \n  <ItemGroup>\n    <AdditionalFiles Include="demo.yang" />\n  </ItemGroup>\n\n     <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>    \n  <ItemGroup>\n    <PackageReference Include="dotnetYang" Version="0.3.0" />\n  </ItemGroup>\n\n</Project>\n\n'))),(0,r.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DotnetYang\\src\\yangDemo\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"DotnetYang")," in ",(0,r.kt)("em",{parentName:"p"},"Program.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'Console.WriteLine("Yang file from https://info.support.huawei.com/info-finder/encyclopedia/en/YANG.html#content4!");\nSome.Module.YangNode.DoSomethingInput input = new Some.Module.YangNode.DoSomethingInput\n{\n    TheBigLeaf = 123\n};\n'))),(0,r.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DotnetYang\\src\\yangDemo\\demo.yang",label:"demo.yang",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"DotnetYang")," in ",(0,r.kt)("em",{parentName:"p"},"demo.yang")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'module some-module {\n    yang-version 1.1;\n    namespace "urn:dotnet:yang:andrei";\n    prefix sm;\n    identity someIdentity;\n    identity someOtherIdentity\n    {\n        base someIdentity;\n    }\n    rpc doSomething {\n        input {\n            leaf the-big-leaf\n            {\n                type uint32;\n                default "4";\n                description "The value that is the input of the doSomething rpc";\n            }\n        }\n        output {\n            leaf response\n            {\n                type identityref\n                {\n                    base someIdentity;\n                }\n                default "someOtherIdentity";\n                description "The identity that is the output of the doSomething rpc";\n            }\n        }\n    }\n}\n')))),(0,r.kt)("h3",{id:"generated-files"},"Generated Files"),(0,r.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DotnetYang\\src\\yangDemo\\obj\\GX\\dotnetYang\\YangParser.Generator.YangGenerator\\Configuration.cs",label:"Configuration.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using System;\nusing System.Xml;\nusing YangSupport;\nnamespace yangDemo;\n///<summary>\n///Configuration root object for yangDemo based on provided .yang modules\n///</summary>\n\npublic class Configuration\n{\n    public Some.Module.YangNode? SomeModule { get; set; }\n    public async Task WriteXMLAsync(XmlWriter writer)\n    {\n        await writer.WriteStartElementAsync(null,"root",null);\n        \n        if(SomeModule is not null) await SomeModule.WriteXMLAsync(writer);\n        await writer.WriteEndElementAsync();\n    }\n    public static async Task<Configuration> ParseAsync(XmlReader reader)\n    {\n        Some.Module.YangNode? _SomeModule = default!;\n        while(await reader.ReadAsync())\n        {\n           switch(reader.NodeType)\n           {\n               case XmlNodeType.Element:\n                   switch(reader.Name)\n                   {\n                        case "some-module":\n                            _SomeModule = await Some.Module.YangNode.ParseAsync(reader);\n                            continue;\n                        case "rpc-error": throw await RpcException.ParseAsync(reader);\n                        default: throw new Exception($"Unexpected element \'{reader.Name}\' under \'root\'");\n                   }\n               case XmlNodeType.EndElement when reader.Name == "root":\n                   return new Configuration{\n                       SomeModule = _SomeModule,\n                   };\n               case XmlNodeType.Whitespace: break;\n               default: throw new Exception($"Unexpected node type \'{reader.NodeType}\' : \'{reader.Name}\' under \'root\'");\n           }\n        }\n        throw new Exception("Reached end-of-readability without ever returning from Configuration.ParseAsync");\n    }\n}\npublic static class IYangServerExtensions\n{\n   public static async Task Receive(this IYangServer server, global::System.IO.Stream input, global::System.IO.Stream output)\n   {\n       var initialPosition = output.Position;\n       var initialLength = output.Length;\n       string? id = null;\n       using XmlReader reader = XmlReader.Create(input, SerializationHelper.GetStandardReaderSettings());\n       using XmlWriter writer = XmlWriter.Create(output, SerializationHelper.GetStandardWriterSettings());\n       try\n       {\n           await reader.ReadAsync();\n           switch(reader.Name)\n           {\n               case "rpc":\n                   id = reader.ParseMessageId();\n                   await writer.WriteStartElementAsync(null, "rpc-reply", "urn:ietf:params:xml:ns:netconf:base:1.0");\n                   await writer.WriteAttributeStringAsync(null, "message-id", null, id);\n                   await reader.ReadAsync();\n                   switch(reader.Name)\n                   {\n                       case "action":\n                           await server.ReceiveAction(reader, writer);\n                           break;\n                       default:\n                           await server.ReceiveRPC(reader, writer);\n                           break;\n                   }\n                   await writer.WriteEndElementAsync();\n                   await writer.FlushAsync();\n                   break;\n               case "notification":\n                   var eventTime = await reader.ParseEventTime();\n                   await reader.ReadAsync();\n                   await server.ReceiveNotification(reader, eventTime);\n                   break;\n           }\n       }\n       catch(RpcException ex)\n       {\n           await writer.FlushAsync();\n           output.Position = initialPosition;\n           output.SetLength(initialLength);\n           await ex.SerializeAsync(output,id);\n       }\n       catch(Exception ex)\n       {\n           await writer.FlushAsync();\n           output.Position = initialPosition;\n           output.SetLength(initialLength);\n           await output.SerializeRegularExceptionAsync(ex,id);\n       }\n   }\n   public static async Task ReceiveRPC(this IYangServer server, XmlReader reader, XmlWriter writer)\n   {\n       switch(reader.Name)\n       {\n           case "doSomething" when reader.NamespaceURI is "urn:dotnet:yang:andrei":\n            {\n                var input = await Some.Module.YangNode.DoSomethingInput.ParseAsync(reader);\n                var task = server.OnDoSomething(input);\n                var response = await task;\n                await response.WriteXMLAsync(writer);\n            }\n            break;\n       }\n   }\n   public static async Task ReceiveAction(this IYangServer server, XmlReader reader, XmlWriter writer)\n   {\n       await reader.ReadAsync();\n       switch(reader.Name)\n       {\n           \n       }\n   }\n   public static async Task ReceiveNotification(this IYangServer server, XmlReader reader, DateTime eventTime)\n   {\n       switch(reader.Name)\n       {\n           \n           \n       }\n   }\n}\n'))),(0,r.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DotnetYang\\src\\yangDemo\\obj\\GX\\dotnetYang\\YangParser.Generator.YangGenerator\\YangModules\\some\\some-module.cs",label:"some-module.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using System;\nusing System.Xml;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\nusing System.Xml.Linq;\nusing System.Text.RegularExpressions;\nusing YangSupport;\nnamespace yangDemo\n{\n    public partial interface IYangServer\n    {\n        Task<Some.Module.YangNode.DoSomethingOutput> OnDoSomething(Some.Module.YangNode.DoSomethingInput input);\n    }\n}\nnamespace Some.Module{\npublic class YangNode\n{\n    public const string ModuleName = "some-module";\n    public const string Revision = "";\n    public static string[] Features = [];\n    //Yang Version 1.1\n    public const string Namespace = "urn:dotnet:yang:andrei";\n    public static string GetEncodedValue(SomeIdentityIdentity value)\n    {\n        switch(value)\n        {\n            case SomeIdentityIdentity.SomeIdentity: return "someIdentity";\n            case SomeIdentityIdentity.SomeOtherIdentity: return "someOtherIdentity";\n            default: return value.ToString();\n        }\n    }\n    public static string GetEncodedValue(SomeIdentityIdentity? value) => GetEncodedValue(value!.Value!);\n    public static SomeIdentityIdentity GetSomeIdentityIdentityValue(string value)\n    {\n        switch(value)\n        {\n            case "someIdentity": return SomeIdentityIdentity.SomeIdentity;\n            case "someOtherIdentity": return SomeIdentityIdentity.SomeOtherIdentity;\n            default: throw new Exception($"{value} is not a valid value for SomeIdentityIdentity");\n        }\n    }\n    public enum SomeIdentityIdentity\n    {\n        SomeIdentity,\n        SomeOtherIdentity\n    }\n    public static string GetEncodedValue(SomeOtherIdentityIdentity value)\n    {\n        switch(value)\n        {\n            case SomeOtherIdentityIdentity.SomeOtherIdentity: return "someOtherIdentity";\n            default: return value.ToString();\n        }\n    }\n    public static string GetEncodedValue(SomeOtherIdentityIdentity? value) => GetEncodedValue(value!.Value!);\n    public static SomeOtherIdentityIdentity GetSomeOtherIdentityIdentityValue(string value)\n    {\n        switch(value)\n        {\n            case "someOtherIdentity": return SomeOtherIdentityIdentity.SomeOtherIdentity;\n            default: throw new Exception($"{value} is not a valid value for SomeOtherIdentityIdentity");\n        }\n    }\n    public enum SomeOtherIdentityIdentity\n    {\n        SomeOtherIdentity\n    }\n    public static async Task<Some.Module.YangNode.DoSomethingOutput> DoSomething(IChannel channel, int messageID, Some.Module.YangNode.DoSomethingInput input)\n    {\n        using XmlWriter writer = XmlWriter.Create(channel.WriteStream, SerializationHelper.GetStandardWriterSettings());\n        await writer.WriteStartElementAsync(null,"rpc","urn:ietf:params:xml:ns:netconf:base:1.0");\n        await writer.WriteAttributeStringAsync(null,"message-id",null,messageID.ToString());\n        await writer.WriteStartElementAsync("","doSomething","urn:dotnet:yang:andrei");\n        await input.WriteXMLAsync(writer);\n        await writer.WriteEndElementAsync();\n        await writer.WriteEndElementAsync();\n        await writer.FlushAsync();\n        await channel.Send();\n        using XmlReader reader = XmlReader.Create(channel.ReadStream, SerializationHelper.GetStandardReaderSettings());\n        await reader.ReadAsync();\n        if(reader.NodeType != XmlNodeType.Element || reader.Name != "rpc-reply" || reader.NamespaceURI != "urn:ietf:params:xml:ns:netconf:base:1.0" || reader["message-id"] != messageID.ToString())\n        {\n            throw new Exception($"Expected stream to start with a <rpc-reply> element with message id {messageID} & \\"urn:ietf:params:xml:ns:netconf:base:1.0\\" but got {reader.NodeType}: {reader.Name} in {reader.NamespaceURI}");\n        }\n        var value = await DoSomethingOutput.ParseAsync(reader);\n        return value;\n    }\n    public class DoSomethingOutput\n    {\n        ///<summary>\n        ///The identity that is the output of the doSomething rpc\n        ///</summary>\n        public SomeIdentityIdentity? Response { get; set; } = SomeIdentityIdentity.SomeOtherIdentity;\n        public static async Task<DoSomethingOutput> ParseAsync(XmlReader reader)\n    {\n        SomeIdentityIdentity? _Response = default!;\n        while(await reader.ReadAsync())\n        {\n           switch(reader.NodeType)\n           {\n               case XmlNodeType.Element:\n                   switch(reader.Name)\n                   {\n                        case "response":\n                            await reader.ReadAsync();\n                            if(reader.NodeType != XmlNodeType.Text)\n                            {\n                                throw new Exception($"Expected token in ParseCall for \'response\' to be text, but was \'{reader.NodeType}\'");\n                            }\n                            _Response = GetSomeIdentityIdentityValue(await reader.GetValueAsync());\n                            if(!reader.IsEmptyElement)\n                            {\n                                await reader.ReadAsync();\n                                if(reader.NodeType != XmlNodeType.EndElement)\n                                {\n                                    throw new Exception($"Expected token in ParseCall for \'response\' to be an element closure, but was \'{reader.NodeType}\'");\n                                }\n                            }\n                            continue;\n                        case "rpc-error": throw await RpcException.ParseAsync(reader);\n                        default: throw new Exception($"Unexpected element \'{reader.Name}\' under \'rpc-reply\'");\n                   }\n               case XmlNodeType.EndElement when reader.Name == "rpc-reply":\n                   return new DoSomethingOutput{\n                       Response = _Response,\n                   };\n               case XmlNodeType.Whitespace: break;\n               default: throw new Exception($"Unexpected node type \'{reader.NodeType}\' : \'{reader.Name}\' under \'rpc-reply\'");\n           }\n        }\n        throw new Exception("Reached end-of-readability without ever returning from DoSomethingOutput.ParseAsync");\n    }\n        public async Task WriteXMLAsync(XmlWriter writer)\n    {\n        if(Response != default)\n        {\n            await writer.WriteStartElementAsync(null,"response","urn:dotnet:yang:andrei");\n            await writer.WriteStringAsync(YangNode.GetEncodedValue(Response!));\n            await writer.WriteEndElementAsync();\n        }\n    }\n    }\n    public class DoSomethingInput\n    {\n        ///<summary>\n        ///The value that is the input of the doSomething rpc\n        ///</summary>\n        public uint? TheBigLeaf { get; set; } = 4;\n        public async Task WriteXMLAsync(XmlWriter writer)\n        {\n            if(TheBigLeaf != default)\n            {\n                await writer.WriteStartElementAsync(null,"the-big-leaf","urn:dotnet:yang:andrei");\n                await writer.WriteStringAsync(TheBigLeaf!.ToString());\n                await writer.WriteEndElementAsync();\n            }\n        }\n        public static async Task<DoSomethingInput> ParseAsync(XmlReader reader)\n        {\n            uint? _TheBigLeaf = default!;\n            while(await reader.ReadAsync())\n            {\n               switch(reader.NodeType)\n               {\n                   case XmlNodeType.Element:\n                       switch(reader.Name)\n                       {\n                            case "the-big-leaf":\n                                await reader.ReadAsync();\n                                if(reader.NodeType != XmlNodeType.Text)\n                                {\n                                    throw new Exception($"Expected token in ParseCall for \'the-big-leaf\' to be text, but was \'{reader.NodeType}\'");\n                                }\n                                _TheBigLeaf = uint.Parse(await reader.GetValueAsync());\n                                if(!reader.IsEmptyElement)\n                                {\n                                    await reader.ReadAsync();\n                                    if(reader.NodeType != XmlNodeType.EndElement)\n                                    {\n                                        throw new Exception($"Expected token in ParseCall for \'the-big-leaf\' to be an element closure, but was \'{reader.NodeType}\'");\n                                    }\n                                }\n                                continue;\n                            case "rpc-error": throw await RpcException.ParseAsync(reader);\n                            default: throw new Exception($"Unexpected element \'{reader.Name}\' under \'doSomething\'");\n                       }\n                   case XmlNodeType.EndElement when reader.Name == "doSomething":\n                       return new DoSomethingInput{\n                           TheBigLeaf = _TheBigLeaf,\n                       };\n                   case XmlNodeType.Whitespace: break;\n                   default: throw new Exception($"Unexpected node type \'{reader.NodeType}\' : \'{reader.Name}\' under \'doSomething\'");\n               }\n            }\n            throw new Exception("Reached end-of-readability without ever returning from DoSomethingInput.ParseAsync");\n        }\n    }\n    public static async Task<Some.Module.YangNode> ParseAsync(XmlReader reader)\n    {\n        while(await reader.ReadAsync())\n        {\n           switch(reader.NodeType)\n           {\n               case XmlNodeType.Element:\n                   switch(reader.Name)\n                   {\n                        case "rpc-error": throw await RpcException.ParseAsync(reader);\n                        default: throw new Exception($"Unexpected element \'{reader.Name}\' under \'some-module\'");\n                   }\n               case XmlNodeType.EndElement when reader.Name == "some-module":\n                   return new Some.Module.YangNode{\n                   };\n               case XmlNodeType.Whitespace: break;\n               default: throw new Exception($"Unexpected node type \'{reader.NodeType}\' : \'{reader.Name}\' under \'some-module\'");\n           }\n        }\n        throw new Exception("Reached end-of-readability without ever returning from Some.Module.YangNode.ParseAsync");\n    }\n    public async Task WriteXMLAsync(XmlWriter writer)\n    {\n        await writer.WriteStartElementAsync(null,"some-module","urn:dotnet:yang:andrei");\n        await writer.WriteEndElementAsync();\n    }\n}\n}\n')))),(0,r.kt)("h2",{id:"usefull"},"Usefull"),(0,r.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{target:"_blank",href:n(43339).Z},"Download Example project DotnetYang "))),(0,r.kt)("h3",{id:"share-dotnetyang"},"Share DotnetYang"),(0,r.kt)("ul",null,(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDotnetYang&quote=DotnetYang",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDotnetYang&text=DotnetYang:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDotnetYang",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDotnetYang&title=DotnetYang",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDotnetYang&title=DotnetYang&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDotnetYang",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/DotnetYang"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/DotnetYang")),(0,r.kt)("h3",{id:"in-the-same-category-filestocode---13-other-generators"},"In the same category (FilesToCode) - 13 other generators"),(0,r.kt)("h4",{id:"chornembeddedresourceaccessgenerator"},(0,r.kt)("a",{parentName:"h4",href:"/docs/Chorn.EmbeddedResourceAccessGenerator"},"Chorn.EmbeddedResourceAccessGenerator")),(0,r.kt)("h4",{id:"corecraft"},(0,r.kt)("a",{parentName:"h4",href:"/docs/corecraft"},"corecraft")),(0,r.kt)("h4",{id:"datacuteembeddedresourcepropertygenerator"},(0,r.kt)("a",{parentName:"h4",href:"/docs/Datacute.EmbeddedResourcePropertyGenerator"},"Datacute.EmbeddedResourcePropertyGenerator")),(0,r.kt)("h4",{id:"embedresourcecsharp"},(0,r.kt)("a",{parentName:"h4",href:"/docs/EmbedResourceCSharp"},"EmbedResourceCSharp")),(0,r.kt)("h4",{id:"lingogen"},(0,r.kt)("a",{parentName:"h4",href:"/docs/LingoGen"},"LingoGen")),(0,r.kt)("h4",{id:"notnotappsettings"},(0,r.kt)("a",{parentName:"h4",href:"/docs/NotNotAppSettings"},"NotNotAppSettings")),(0,r.kt)("h4",{id:"podimoconstembed"},(0,r.kt)("a",{parentName:"h4",href:"/docs/Podimo.ConstEmbed"},"Podimo.ConstEmbed")),(0,r.kt)("h4",{id:"resxgenerator"},(0,r.kt)("a",{parentName:"h4",href:"/docs/ResXGenerator"},"ResXGenerator")),(0,r.kt)("h4",{id:"rscg_json2class"},(0,r.kt)("a",{parentName:"h4",href:"/docs/RSCG_JSON2Class"},"RSCG_JSON2Class")),(0,r.kt)("h4",{id:"rscg_utils"},(0,r.kt)("a",{parentName:"h4",href:"/docs/RSCG_Utils"},"RSCG_Utils")),(0,r.kt)("h4",{id:"thisassembly_resources"},(0,r.kt)("a",{parentName:"h4",href:"/docs/ThisAssembly_Resources"},"ThisAssembly_Resources")),(0,r.kt)("h4",{id:"thisassemblystrings"},(0,r.kt)("a",{parentName:"h4",href:"/docs/ThisAssembly.Strings"},"ThisAssembly.Strings")),(0,r.kt)("h4",{id:"weave"},(0,r.kt)("a",{parentName:"h4",href:"/docs/Weave"},"Weave")))}h.isMDXComponent=!0},43339:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/DotnetYang-18f8cd14669e868ae879f934d3dd2fb5.zip"}}]);