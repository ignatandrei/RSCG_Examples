"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[1524],{5537:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>p,default:()=>g,frontMatter:()=>l,metadata:()=>u,toc:()=>c});var a=n(7462),s=(n(7294),n(4137)),r=n(3992),i=n(425),o=n(8839);const l={sidebar_position:4,title:"RSCG - System.Text.RegularExpressions",description:"Regex compiled",slug:"/System.Text.RegularExpressions"},p="System.Text.RegularExpressions  by Microsoft",u={unversionedId:"RSCG-Examples/004System.Text.RegularExpressions",id:"RSCG-Examples/004System.Text.RegularExpressions",title:"RSCG - System.Text.RegularExpressions",description:"Regex compiled",source:"@site/docs/RSCG-Examples/004System.Text.RegularExpressions.md",sourceDirName:"RSCG-Examples",slug:"/System.Text.RegularExpressions",permalink:"/RSCG_Examples/v2/docs/System.Text.RegularExpressions",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"RSCG - System.Text.RegularExpressions",description:"Regex compiled",slug:"/System.Text.RegularExpressions"},sidebar:"tutorialSidebar",previous:{title:"RSCG - System.Text.Json",permalink:"/RSCG_Examples/v2/docs/System.Text.Json"},next:{title:"RSCG - Microsoft.Extensions.Logging",permalink:"/RSCG_Examples/v2/docs/Microsoft.Extensions.Logging"}},m={},c=[{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example",id:"download-example",level:3},{value:"Download PDF",id:"download-pdf",level:3},{value:"Share this page",id:"share-this-page",level:3}],d={toc:c},h="wrapper";function g(e){let{components:t,...l}=e;return(0,s.kt)(h,(0,a.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"systemtextregularexpressions--by-microsoft"},"System.Text.RegularExpressions  by Microsoft"),(0,s.kt)(o.Z,{toc:c,mdxType:"TOCInline"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/System.Text.RegularExpressions/"},(0,s.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/System.Text.RegularExpressions?label=System.Text.RegularExpressions",alt:"Nuget"})),"\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/dotnet/runtime"},(0,s.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/dotnet/runtime?label=updated",alt:"GitHub last commit"})),"\n",(0,s.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/dotnet/runtime?style=social",alt:"GitHub Repo stars"})),(0,s.kt)("h2",{id:"details"},"Details"),(0,s.kt)("h3",{id:"info"},"Info"),(0,s.kt)("admonition",{type:"info"},(0,s.kt)("p",{parentName:"admonition"},"Author: Microsoft"),(0,s.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,s.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/System.Text.RegularExpressions/"},"https://www.nuget.org/packages/System.Text.RegularExpressions/")),(0,s.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,s.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-source-generators/"},"https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-source-generators/")),(0,s.kt)("p",{parentName:"admonition"},"Source : ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/dotnet/runtime"},"https://github.com/dotnet/runtime"))),(0,s.kt)("h3",{id:"about"},"About"),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"Regex compiled")),(0,s.kt)("h2",{id:"how-to-use"},"How to use"),(0,s.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,s.kt)(r.Z,{mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,s.kt)("p",null,"This is the CSharp Project that references System.Text.RegularExpressions "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-xml"},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net7.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n    <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GeneratedX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n\n</Project>\n\n'))),(0,s.kt)(i.Z,{value:"Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,s.kt)("p",null,"  This is the use of System.Text.RegularExpressions in Program.cs"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},'using Demo;\n//https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-source-generators\n//https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7/\nvar x = "Abc";\nConsole.WriteLine(DemoRegex.EvaluateText(x));\n'))),(0,s.kt)(i.Z,{value:"WeatherForecast.cs",label:"WeatherForecast.cs",mdxType:"TabItem"},(0,s.kt)("p",null,"  This is the use of System.Text.RegularExpressions in WeatherForecast.cs"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},'using System.Text.RegularExpressions;\n\nnamespace Demo;\n\npublic partial class DemoRegex\n{\n    [GeneratedRegex("abc|def", RegexOptions.IgnoreCase, "en-US")]\n    private static partial Regex AbcOrDefGeneratedRegex();\n\n    public static bool EvaluateText(string text)\n    {\n        return (AbcOrDefGeneratedRegex().IsMatch(text));\n        \n    }\n}\n\n')))),(0,s.kt)("h3",{id:"generated-files"},"Generated Files"),(0,s.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GeneratedX"),(0,s.kt)(r.Z,{mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"RegexGenerator.g.cs",label:"RegexGenerator.g.cs",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp"},'// <auto-generated/>\n#nullable enable\n#pragma warning disable CS0162 // Unreachable code\n#pragma warning disable CS0164 // Unreferenced label\n#pragma warning disable CS0219 // Variable assigned but never used\n\nnamespace Demo\n{\n    partial class DemoRegex\n    {\n        /// <remarks>\n        /// Pattern explanation:<br/>\n        /// <code>\n        /// \u25cb Match with 2 alternative expressions, atomically.<br/>\n        ///     \u25cb Match a sequence of expressions.<br/>\n        ///         \u25cb Match a character in the set [Aa].<br/>\n        ///         \u25cb Match a character in the set [Bb].<br/>\n        ///         \u25cb Match a character in the set [Cc].<br/>\n        ///     \u25cb Match a sequence of expressions.<br/>\n        ///         \u25cb Match a character in the set [Dd].<br/>\n        ///         \u25cb Match a character in the set [Ee].<br/>\n        ///         \u25cb Match a character in the set [Ff].<br/>\n        /// </code>\n        /// </remarks>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "7.0.8.17405")]\n        private static partial global::System.Text.RegularExpressions.Regex AbcOrDefGeneratedRegex() => global::System.Text.RegularExpressions.Generated.AbcOrDefGeneratedRegex_0.Instance;\n    }\n}\n\nnamespace System.Text.RegularExpressions.Generated\n{\n    using System;\n    using System.CodeDom.Compiler;\n    using System.Collections;\n    using System.ComponentModel;\n    using System.Globalization;\n    using System.Runtime.CompilerServices;\n    using System.Text.RegularExpressions;\n    using System.Threading;\n\n    /// <summary>Custom <see cref="Regex"/>-derived type for the AbcOrDefGeneratedRegex method.</summary>\n    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "7.0.8.17405")]\n    file sealed class AbcOrDefGeneratedRegex_0 : Regex\n    {\n        /// <summary>Cached, thread-safe singleton instance.</summary>\n        internal static readonly AbcOrDefGeneratedRegex_0 Instance = new();\n    \n        /// <summary>Initializes the instance.</summary>\n        private AbcOrDefGeneratedRegex_0()\n        {\n            base.pattern = "abc|def";\n            base.roptions = RegexOptions.IgnoreCase;\n            ValidateMatchTimeout(Utilities.s_defaultTimeout);\n            base.internalMatchTimeout = Utilities.s_defaultTimeout;\n            base.factory = new RunnerFactory();\n            base.capsize = 1;\n        }\n    \n        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>\n        private sealed class RunnerFactory : RegexRunnerFactory\n        {\n            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>\n            protected override RegexRunner CreateInstance() => new Runner();\n        \n            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>\n            private sealed class Runner : RegexRunner\n            {\n                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>\n                /// <param name="inputSpan">The text being scanned by the regular expression.</param>\n                protected override void Scan(ReadOnlySpan<char> inputSpan)\n                {\n                    // Search until we can\'t find a valid starting position, we find a match, or we reach the end of the input.\n                    while (TryFindNextPossibleStartingPosition(inputSpan) &&\n                           !TryMatchAtCurrentPosition(inputSpan) &&\n                           base.runtextpos != inputSpan.Length)\n                    {\n                        base.runtextpos++;\n                        if (Utilities.s_hasTimeout)\n                        {\n                            base.CheckTimeout();\n                        }\n                    }\n                }\n        \n                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>\n                /// <param name="inputSpan">The text being scanned by the regular expression.</param>\n                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>\n                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)\n                {\n                    int pos = base.runtextpos;\n                    ulong charMinusLow;\n                    \n                    // Any possible match is at least 3 characters.\n                    if (pos <= inputSpan.Length - 3)\n                    {\n                        // The pattern matches a character in the set [CFcf] at index 2.\n                        // Find the next occurrence. If it can\'t be found, there\'s no match.\n                        ReadOnlySpan<char> span = inputSpan.Slice(pos);\n                        for (int i = 0; i < span.Length - 2; i++)\n                        {\n                            int indexOfPos = span.Slice(i + 2).IndexOfAny("CFcf");\n                            if (indexOfPos < 0)\n                            {\n                                goto NoMatchFound;\n                            }\n                            i += indexOfPos;\n                            \n                            if (((long)((0x9000000090000000UL << (int)(charMinusLow = (uint)span[i] - \'A\')) & (charMinusLow - 64)) < 0) &&\n                                ((long)((0x9000000090000000UL << (int)(charMinusLow = (uint)span[i + 1] - \'B\')) & (charMinusLow - 64)) < 0))\n                            {\n                                base.runtextpos = pos + i;\n                                return true;\n                            }\n                        }\n                    }\n                    \n                    // No match found.\n                    NoMatchFound:\n                    base.runtextpos = inputSpan.Length;\n                    return false;\n                }\n        \n                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>\n                /// <param name="inputSpan">The text being scanned by the regular expression.</param>\n                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>\n                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)\n                {\n                    int pos = base.runtextpos;\n                    int matchStart = pos;\n                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);\n                    \n                    // Match with 2 alternative expressions, atomically.\n                    {\n                        if (slice.IsEmpty)\n                        {\n                            return false; // The input didn\'t match.\n                        }\n                        \n                        switch (slice[0])\n                        {\n                            case \'A\' or \'a\':\n                                if ((uint)slice.Length < 3 ||\n                                    !slice.Slice(1).StartsWith("bc", StringComparison.OrdinalIgnoreCase)) // Match the string "bc" (ordinal case-insensitive)\n                                {\n                                    return false; // The input didn\'t match.\n                                }\n                                \n                                pos += 3;\n                                slice = inputSpan.Slice(pos);\n                                break;\n                                \n                            case \'D\' or \'d\':\n                                if ((uint)slice.Length < 3 ||\n                                    !slice.Slice(1).StartsWith("ef", StringComparison.OrdinalIgnoreCase)) // Match the string "ef" (ordinal case-insensitive)\n                                {\n                                    return false; // The input didn\'t match.\n                                }\n                                \n                                pos += 3;\n                                slice = inputSpan.Slice(pos);\n                                break;\n                                \n                            default:\n                                return false; // The input didn\'t match.\n                        }\n                    }\n                    \n                    // The input matched.\n                    base.runtextpos = pos;\n                    base.Capture(0, matchStart, pos);\n                    return true;\n                }\n            }\n        }\n\n    }\n    \n    /// <summary>Helper methods used by generated <see cref="Regex"/>-derived implementations.</summary>\n    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "7.0.8.17405")]\n    file static class Utilities\n    {\n        /// <summary>Default timeout value set in <see cref="AppContext"/>, or <see cref="Regex.InfiniteMatchTimeout"/> if none was set.</summary>\n        internal static readonly TimeSpan s_defaultTimeout = AppContext.GetData("REGEX_DEFAULT_MATCH_TIMEOUT") is TimeSpan timeout ? timeout : Regex.InfiniteMatchTimeout;\n        \n        /// <summary>Whether <see cref="s_defaultTimeout"/> is non-infinite.</summary>\n        internal static readonly bool s_hasTimeout = s_defaultTimeout != Timeout.InfiniteTimeSpan;\n    }\n}\n\n')))),(0,s.kt)("h2",{id:"usefull"},"Usefull"),(0,s.kt)("h3",{id:"download-example"},"Download Example"),(0,s.kt)("p",null,(0,s.kt)("a",{target:"_blank",href:n(8798).Z},"Download Example System.Text.RegularExpressions ")),(0,s.kt)("h3",{id:"download-pdf"},"Download PDF"),(0,s.kt)("p",null,(0,s.kt)("a",{target:"_blank",href:n(6116).Z},"Download PDF System.Text.RegularExpressions ")),(0,s.kt)("h3",{id:"share-this-page"},"Share this page"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/System.Text.RegularExpressions"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/System.Text.RegularExpressions")))}g.isMDXComponent=!0},6116:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/System.Text.RegularExpressions-b653c32e38ec4022c92b9d9ffb14d9a5.pdf"},8798:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/System.Text.RegularExpressions-a03cc30797df7301821ec011ad54fcbc.zip"}}]);