"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[2450],{17366:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>m,default:()=>b,frontMatter:()=>l,metadata:()=>p,toc:()=>g});var r=t(87462),a=(t(67294),t(3905)),s=t(73992),i=t(18679),o=t(68839);const l={sidebar_position:1960,title:"196 - ArgumentParsing",description:"Transform command line arguments into strongly typed objects",slug:"/ArgumentParsing"},m="ArgumentParsing  by",p={unversionedId:"RSCG-Examples/ArgumentParsing",id:"RSCG-Examples/ArgumentParsing",title:"196 - ArgumentParsing",description:"Transform command line arguments into strongly typed objects",source:"@site/docs/RSCG-Examples/ArgumentParsing.md",sourceDirName:"RSCG-Examples",slug:"/ArgumentParsing",permalink:"/RSCG_Examples/v2/docs/ArgumentParsing",draft:!1,tags:[],version:"current",sidebarPosition:1960,frontMatter:{sidebar_position:1960,title:"196 - ArgumentParsing",description:"Transform command line arguments into strongly typed objects",slug:"/ArgumentParsing"},sidebar:"tutorialSidebar",previous:{title:"195 - Comparison",permalink:"/RSCG_Examples/v2/docs/Comparison"},next:{title:"197 - BunnyTailServiceRegistration",permalink:"/RSCG_Examples/v2/docs/BunnyTailServiceRegistration"}},u={},g=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example (source csproj, source files)",id:"example-source-csproj-source-files",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share ArgumentParsing",id:"share-argumentparsing",level:3},{value:"In the same category (CommandLine) - 0 other generators",id:"in-the-same-category-commandline---0-other-generators",level:3}],d={toc:g},c="wrapper";function b(e){let{components:n,...l}=e;return(0,a.kt)(c,(0,r.Z)({},d,l,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"argumentparsing--by"},"ArgumentParsing  by"),(0,a.kt)(o.Z,{toc:g,mdxType:"TOCInline"}),(0,a.kt)("h2",{id:"nuget--site-data"},"NuGet / site data"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/ArgumentParsing/"},(0,a.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/ArgumentParsing?label=ArgumentParsing",alt:"Nuget"})),"\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/DoctorKrolic/ArgumentParsing"},(0,a.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/DoctorKrolic/ArgumentParsing?label=updated",alt:"GitHub last commit"})),"\n",(0,a.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/DoctorKrolic/ArgumentParsing?style=social",alt:"GitHub Repo stars"})),(0,a.kt)("h2",{id:"details"},"Details"),(0,a.kt)("h3",{id:"info"},"Info"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Name: ",(0,a.kt)("strong",{parentName:"p"},"ArgumentParsing")),(0,a.kt)("p",{parentName:"admonition"},"Source generator based command line arguments parser"),(0,a.kt)("p",{parentName:"admonition"},"Author: "),(0,a.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/ArgumentParsing/"},"https://www.nuget.org/packages/ArgumentParsing/")),"   "),(0,a.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/DoctorKrolic/ArgumentParsing"},"https://github.com/DoctorKrolic/ArgumentParsing")),(0,a.kt)("p",{parentName:"admonition"},"Source: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/DoctorKrolic/ArgumentParsing"},"https://github.com/DoctorKrolic/ArgumentParsing"))),(0,a.kt)("h3",{id:"original-readme"},"Original Readme"),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("h1",{parentName:"admonition",id:"argument-parsing"},"Argument Parsing"),(0,a.kt)("p",{parentName:"admonition"},"Library for command line arguments parsing with intuitive API in declarative style, allowing you to build complex command line applications by simply declaring options type and annotating its members with attributes to get the desired behavior. All logic is source-generated, making this library completely AOT-friendly!"),(0,a.kt)("h2",{parentName:"admonition",id:"overview"},"Overview"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"Best works on latest .NET version, but is ",(0,a.kt)("strong",{parentName:"li"},".NET Standard 2.0 compatible"),", meaning it works on a huge variety of .NET versions, including .NET Framework"),(0,a.kt)("li",{parentName:"ul"},"Provides simple declarative API: you define ",(0,a.kt)("em",{parentName:"li"},"what")," you want and the library figures out ",(0,a.kt)("em",{parentName:"li"},"how")," to achieve that"),(0,a.kt)("li",{parentName:"ul"},"Supports wide variety of types, including nullable value types and immutable sequences like ",(0,a.kt)("inlineCode",{parentName:"li"},"ImmutableArray<T>")),(0,a.kt)("li",{parentName:"ul"},"Good integration with modern C# features (e.g. you can specify a required option/parameter by making its corresponding property ",(0,a.kt)("inlineCode",{parentName:"li"},"required"),")"),(0,a.kt)("li",{parentName:"ul"},"Provides default implementations of ",(0,a.kt)("inlineCode",{parentName:"li"},"--help")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"--version")," commands with additional customization"),(0,a.kt)("li",{parentName:"ul"},"All parsing logic is entirely source-generated, making this library completely NativeAOT-friendly"),(0,a.kt)("li",{parentName:"ul"},"Delivers rich developer experience: the editor provides real-time diagnostics, including error detection, code suggestions and more as you type"),(0,a.kt)("li",{parentName:"ul"},"Includes detailed and comprehensive wiki documentation")),(0,a.kt)("h2",{parentName:"admonition",id:"quick-start-example"},"Quick start example"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-cs"},'using ArgumentParsing;\nusing ArgumentParsing.Generated;\nusing ArgumentParsing.Results;\nusing ArgumentParsing.SpecialCommands.Help;\nusing System;\nusing System.Collections.Immutable;\nusing System.Linq;\n\nnamespace SimpleSumApp;\n\npartial class Program\n{\n    private static void Main(string[] args)\n    {\n        ParseArguments(args).ExecuteDefaults(ExecuteMainApp);\n    }\n\n    [GeneratedArgumentParser]\n    private static partial ParseResult<Options> ParseArguments(string[] args);\n\n    private static void ExecuteMainApp(Options options)\n    {\n        // At this point all errors and special cases are handled,\n        // so we get valid options object we can work with\n        var sum = options.FirstRequiredParameter + options.SecondRequiredParameter;\n        if (options.Verbose)\n        {\n            Console.WriteLine($"Sum of 2 required parameters: {sum}");\n        }\n\n        var remainingSum = options.RemainingParameters.Sum();\n        if (options.Verbose)\n        {\n            Console.WriteLine($"Sum of remaining parameters: {remainingSum}");\n        }\n\n        Console.WriteLine($"Total sum: {sum + remainingSum}");\n    }\n}\n\n[OptionsType]\nclass Options\n{\n    [Option(\'v\'), HelpInfo("Enables verbose logging")]\n    public bool Verbose { get; init; }\n\n    [Parameter(0)]\n    public required int FirstRequiredParameter { get; init; }\n\n    [Parameter(1)]\n    public required int SecondRequiredParameter { get; init; }\n\n    [RemainingParameters]\n    public ImmutableArray<int> RemainingParameters { get; init; }\n}\n'))),(0,a.kt)("h3",{id:"about"},"About"),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Transform command line arguments into strongly typed objects")),(0,a.kt)("h2",{id:"how-to-use"},"How to use"),(0,a.kt)("h3",{id:"example-source-csproj-source-files"},"Example (source csproj, source files)"),(0,a.kt)(s.Z,{mdxType:"Tabs"},(0,a.kt)(i.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,a.kt)("p",null,"This is the CSharp Project that references ",(0,a.kt)("strong",{parentName:"p"},"ArgumentParsing")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {11}",showLineNumbers:!0,"{11}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  \x3c!--<ItemGroup>\n    <ProjectReference Include="..\\src\\ArgumentParsing\\ArgumentParsing.csproj" />\n    <ProjectReference Include="..\\src\\ArgumentParsing.Generators\\ArgumentParsing.Generators.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false" PrivateAssets="all" />\n  </ItemGroup>--\x3e\n  \n  \n  <PropertyGroup>\n    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n    <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n  </PropertyGroup>\n  \n  \n  <ItemGroup>\n    <PackageReference Include="ArgumentParsing" Version="0.3.0" OutputItemType="Analyzer" ReferenceOutputAssembly="false" PrivateAssets="all" />\n  </ItemGroup>\n\n</Project>\n\n'))),(0,a.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\ArgumentParsing\\src\\ArgPars\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,a.kt)("p",null,"  This is the use of ",(0,a.kt)("strong",{parentName:"p"},"ArgumentParsing")," in ",(0,a.kt)("em",{parentName:"p"},"Program.cs")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using ArgumentParsing;\nusing ArgumentParsing.Results;\n\nnamespace ArgPars;\n\npartial class Program\n{\n    /// <summary>\n    /// Execute in the folder with csproj file:\n    ///\n    /// dotnet run -- --help\n    /// dotnet run -- --version\n    /// dotnet run -- sample-input.txt\n    /// dotnet run -- -v -f Xml sample-input.txt\n    /// </summary>\n    /// <param name="args"></param>\n    private static void Main(string[] args)\n    {\n        // Parse the command line arguments with the generated parser\n        var result = ParseArguments(args);\n        \n        // Handle the result based on its state\n        switch (result.State) \n        {\n            case ParseResultState.ParsedOptions:\n                ExecuteMainApp(result.Options!);\n                break;\n            case ParseResultState.ParsedWithErrors:\n                Console.Error.WriteLine("Error parsing arguments:");\n                if (result.Errors != null)\n                {\n                    foreach (var error in result.Errors)\n                    {\n                        Console.Error.WriteLine($"  {error.GetMessage()}");\n                    }\n                }\n                Environment.Exit(1);\n                break;\n            case ParseResultState.ParsedSpecialCommand:\n                var exitCode = result.SpecialCommandHandler!.HandleCommand();\n                Environment.Exit(exitCode);\n                break;\n        }\n    }\n\n    [GeneratedArgumentParser]\n    private static partial ParseResult<FileProcessorOptions> ParseArguments(string[] args);\n\n    private static void ExecuteMainApp(FileProcessorOptions options)\n    {\n        // At this point all errors and special cases are handled,\n        // so we get valid options object we can work with\n        \n        Console.WriteLine("=== File Processor Tool ===");\n        Console.WriteLine($"Verbose mode: {options.Verbose}");\n\n        if (options.Verbose)\n        {\n            Console.WriteLine($"Verbose mode: enabled");\n            Console.WriteLine($"Output format: {options.OutputFormat}");\n            Console.WriteLine($"Max file size: {options.MaxFileSizeBytes} bytes");\n            Console.WriteLine($"Input file: {options.InputFile}");\n            \n            if (!string.IsNullOrEmpty(options.OutputFile))\n                Console.WriteLine($"Output file: {options.OutputFile}");\n                \n            if (options.AdditionalFiles.Length > 0)\n            {\n                Console.WriteLine($"Additional files ({options.AdditionalFiles.Length}):");\n                foreach (var file in options.AdditionalFiles)\n                {\n                    Console.WriteLine($"  - {file}");\n                }\n            }\n        }\n\n        //TODO: Simulate file processing\n        \n    }\n\n    \n\n    \n}\n\n'))),(0,a.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\ArgumentParsing\\src\\ArgPars\\FileProcessorOptions.cs",label:"FileProcessorOptions.cs",mdxType:"TabItem"},(0,a.kt)("p",null,"  This is the use of ",(0,a.kt)("strong",{parentName:"p"},"ArgumentParsing")," in ",(0,a.kt)("em",{parentName:"p"},"FileProcessorOptions.cs")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using ArgumentParsing;\nusing ArgumentParsing.SpecialCommands.Help;\nusing System.Collections.Immutable;\n\nnamespace ArgPars;\n\n[OptionsType]\nclass FileProcessorOptions\n{\n    [Option(\'v\', "verbose"), HelpInfo("Enable verbose logging and detailed output")]\n    public bool Verbose { get; init; }\n\n    [Option(\'f\', "format"), HelpInfo("Output format for processed files (json, xml, csv)")]\n    public OutputFormat OutputFormat { get; init; } = OutputFormat.Json;\n\n    [Option(\'m\', "max-size"), HelpInfo("Maximum file size in bytes (default: 10MB)")]\n    public long MaxFileSizeBytes { get; init; } = 10 * 1024 * 1024; // 10MB default\n\n    [Option(\'o\', "output"), HelpInfo("Output file path (optional, defaults to input file with new extension)")]\n    public string? OutputFile { get; init; }\n\n    [Parameter(0, Name = "input-file"), HelpInfo("Path to the input file to process")]\n    public required string InputFile { get; init; }\n\n    [RemainingParameters, HelpInfo("Additional files to process")]\n    public ImmutableArray<string> AdditionalFiles { get; init; }\n}\n\n')))),(0,a.kt)("h3",{id:"generated-files"},"Generated Files"),(0,a.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,a.kt)(s.Z,{mdxType:"Tabs"},(0,a.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\ArgumentParsing\\src\\ArgPars\\obj\\GX\\ArgumentParsing.Generators\\ArgumentParsing.Generators.ArgumentParserGenerator\\ExampleProject.FileProcessorOptions.g.cs",label:"ExampleProject.FileProcessorOptions.g.cs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated/>\n#nullable disable\n#pragma warning disable\n\nnamespace ArgumentParsing.Generated\n{\n    internal static partial class ParseResultExtensions\n    {\n        /// <summary>\n        /// Executes common default actions for the given <see cref="global::ArgumentParsing.Results.ParseResult{TOptions}"/>\n        /// <list type="bullet">\n        /// <item>If <paramref name="result"/> is in <see cref="global::ArgumentParsing.Results.ParseResultState.ParsedOptions"/> state invokes provided <paramref name="action"/> with parsed options object</item>\n        /// <item>If <paramref name="result"/> is in <see cref="global::ArgumentParsing.Results.ParseResultState.ParsedWithErrors"/> state writes help screen text with parse errors to <see cref="global::System.Console.Error"/> and exits application with code 1</item>\n        /// <item>If <paramref name="result"/> is in <see cref="global::ArgumentParsing.Results.ParseResultState.ParsedSpecialCommand"/> state executes parsed handler and exits application with code, returned from the handler</item>\n        /// </list>\n        /// </summary>\n        /// <param name="result">Parse result</param>\n        /// <param name="action">Action, which will be invoked if options type is correctly parsed</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ArgumentParsing.Generators.ArgumentParserGenerator", "0.3.0.0")]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]\n        public static void ExecuteDefaults(this global::ArgumentParsing.Results.ParseResult<global::ExampleProject.FileProcessorOptions> result, global::System.Action<global::ExampleProject.FileProcessorOptions> action)\n        {\n            switch (result.State)\n            {\n                case global::ArgumentParsing.Results.ParseResultState.ParsedOptions:\n                    action(result.Options);\n                    break;\n                case global::ArgumentParsing.Results.ParseResultState.ParsedWithErrors:\n                    string errorScreenText = global::ArgumentParsing.Generated.HelpCommandHandler_ExampleProject_FileProcessorOptions.GenerateHelpText(result.Errors);\n                    global::System.Console.Error.WriteLine(errorScreenText);\n                    global::System.Environment.Exit(1);\n                    break;\n                case global::ArgumentParsing.Results.ParseResultState.ParsedSpecialCommand:\n                    int exitCode = result.SpecialCommandHandler.HandleCommand();\n                    global::System.Environment.Exit(exitCode);\n                    break;\n            }\n        }\n    }\n}\n\nnamespace ExampleProject\n{\n    partial class Program\n    {\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ArgumentParsing.Generators.ArgumentParserGenerator", "0.3.0.0")]\n        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]\n        private static partial global::ArgumentParsing.Results.ParseResult<global::ExampleProject.FileProcessorOptions> ParseArguments(string[] args)\n        {\n            bool Verbose_val = default(bool);\n            global::ExampleProject.OutputFormat OutputFormat_val = default(global::ExampleProject.OutputFormat);\n            long MaxFileSizeBytes_val = default(long);\n            string OutputFile_val = default(string);\n            string InputFile_val = default(string);\n            global::System.Collections.Immutable.ImmutableArray<string>.Builder remainingParametersBuilder = global::System.Collections.Immutable.ImmutableArray.CreateBuilder<string>();\n\n            int state = -3;\n            int seenOptions = 0;\n            global::System.Collections.Generic.HashSet<global::ArgumentParsing.Results.Errors.ParseError> errors = null;\n            global::System.Span<global::System.Range> longArgSplit = stackalloc global::System.Range[2];\n            global::System.ReadOnlySpan<char> latestOptionName = default(global::System.ReadOnlySpan<char>);\n            string previousArgument = null;\n            int parameterIndex = 0;\n\n            foreach (string arg in args)\n            {\n                if (state == -3)\n                {\n                    switch (arg)\n                    {\n                        case "--help":\n                            return new global::ArgumentParsing.Results.ParseResult<global::ExampleProject.FileProcessorOptions>(new global::ArgumentParsing.Generated.HelpCommandHandler_ExampleProject_FileProcessorOptions());\n                        case "--version":\n                            return new global::ArgumentParsing.Results.ParseResult<global::ExampleProject.FileProcessorOptions>(new global::ArgumentParsing.Generated.VersionCommandHandler());\n                    }\n\n                    state = 0;\n                }\n\n                global::System.ReadOnlySpan<char> val;\n\n                bool hasLetters = global::System.Linq.Enumerable.Any(arg, char.IsLetter);\n                bool startsOption = hasLetters && arg.Length > 1 && arg.StartsWith(\'-\');\n\n                if (state > 0 && startsOption)\n                {\n                    errors ??= new();\n                    errors.Add(new global::ArgumentParsing.Results.Errors.OptionValueIsNotProvidedError(previousArgument));\n                    state = 0;\n                }\n\n                if (state != -2)\n                {\n                    if (arg.StartsWith("--") && (hasLetters || arg.Length == 2 || arg.Contains(\'=\')))\n                    {\n                        global::System.ReadOnlySpan<char> slice = global::System.MemoryExtensions.AsSpan(arg, 2);\n                        int written = global::System.MemoryExtensions.Split(slice, longArgSplit, \'=\');\n\n                        latestOptionName = slice[longArgSplit[0]];\n                        switch (latestOptionName)\n                        {\n                            case "":\n                                if (written == 1)\n                                {\n                                    state = -2;\n                                }\n                                else\n                                {\n                                    errors ??= new();\n                                    errors.Add(new global::ArgumentParsing.Results.Errors.UnrecognizedArgumentError(arg));\n                                }\n                                continue;\n                            case "verbose":\n                                if ((seenOptions & 0b0001) > 0)\n                                {\n                                    errors ??= new();\n                                    errors.Add(new global::ArgumentParsing.Results.Errors.DuplicateOptionError("verbose"));\n                                }\n                                Verbose_val = true;\n                                state = -10;\n                                seenOptions |= 0b0001;\n                                break;\n                            case "format":\n                                if ((seenOptions & 0b0010) > 0)\n                                {\n                                    errors ??= new();\n                                    errors.Add(new global::ArgumentParsing.Results.Errors.DuplicateOptionError("format"));\n                                }\n                                state = 2;\n                                seenOptions |= 0b0010;\n                                break;\n                            case "max-size":\n                                if ((seenOptions & 0b0100) > 0)\n                                {\n                                    errors ??= new();\n                                    errors.Add(new global::ArgumentParsing.Results.Errors.DuplicateOptionError("max-size"));\n                                }\n                                state = 3;\n                                seenOptions |= 0b0100;\n                                break;\n                            case "output":\n                                if ((seenOptions & 0b1000) > 0)\n                                {\n                                    errors ??= new();\n                                    errors.Add(new global::ArgumentParsing.Results.Errors.DuplicateOptionError("output"));\n                                }\n                                state = 4;\n                                seenOptions |= 0b1000;\n                                break;\n                            default:\n                                errors ??= new();\n                                errors.Add(new global::ArgumentParsing.Results.Errors.UnknownOptionError(latestOptionName.ToString(), arg));\n                                if (written == 1)\n                                {\n                                    state = -1;\n                                }\n                                goto continueMainLoop;\n                        }\n\n                        if (written == 2)\n                        {\n                            val = slice[longArgSplit[1]];\n                            goto decodeValue;\n                        }\n\n                        goto continueMainLoop;\n                    }\n\n                    if (startsOption)\n                    {\n                        global::System.ReadOnlySpan<char> slice = global::System.MemoryExtensions.AsSpan(arg, 1);\n\n                        for (int i = 0; i < slice.Length; i++)\n                        {\n                            if (state > 0)\n                            {\n                                val = slice.Slice(i);\n                                goto decodeValue;\n                            }\n\n                            char shortOptionName = slice[i];\n                            latestOptionName = new global::System.ReadOnlySpan<char>(in slice[i]);\n                            switch (shortOptionName)\n                            {\n                                case \'v\':\n                                    if ((seenOptions & 0b0001) > 0)\n                                    {\n                                        errors ??= new();\n                                        errors.Add(new global::ArgumentParsing.Results.Errors.DuplicateOptionError("v"));\n                                    }\n                                    Verbose_val = true;\n                                    state = -10;\n                                    seenOptions |= 0b0001;\n                                    break;\n                                case \'f\':\n                                    if ((seenOptions & 0b0010) > 0)\n                                    {\n                                        errors ??= new();\n                                        errors.Add(new global::ArgumentParsing.Results.Errors.DuplicateOptionError("f"));\n                                    }\n                                    state = 2;\n                                    seenOptions |= 0b0010;\n                                    break;\n                                case \'m\':\n                                    if ((seenOptions & 0b0100) > 0)\n                                    {\n                                        errors ??= new();\n                                        errors.Add(new global::ArgumentParsing.Results.Errors.DuplicateOptionError("m"));\n                                    }\n                                    state = 3;\n                                    seenOptions |= 0b0100;\n                                    break;\n                                case \'o\':\n                                    if ((seenOptions & 0b1000) > 0)\n                                    {\n                                        errors ??= new();\n                                        errors.Add(new global::ArgumentParsing.Results.Errors.DuplicateOptionError("o"));\n                                    }\n                                    state = 4;\n                                    seenOptions |= 0b1000;\n                                    break;\n                                default:\n                                    if (state <= -10)\n                                    {\n                                        val = slice.Slice(i);\n                                        latestOptionName = new global::System.ReadOnlySpan<char>(in slice[i - 1]);\n                                        goto decodeValue;\n                                    }\n                                    errors ??= new();\n                                    errors.Add(new global::ArgumentParsing.Results.Errors.UnknownOptionError(shortOptionName.ToString(), arg));\n                                    state = -1;\n                                    goto continueMainLoop;\n                            }\n                        }\n\n                        goto continueMainLoop;\n                    }\n                }\n\n                val = global::System.MemoryExtensions.AsSpan(arg);\n\n            decodeValue:\n                switch (state)\n                {\n                    case -1:\n                        break;\n                    case 2:\n                        if (!global::System.Enum.TryParse<global::ExampleProject.OutputFormat>(val, out OutputFormat_val))\n                        {\n                            errors ??= new();\n                            errors.Add(new global::ArgumentParsing.Results.Errors.BadOptionValueFormatError(val.ToString(), latestOptionName.ToString()));\n                        }\n                        break;\n                    case 3:\n                        if (!long.TryParse(val, global::System.Globalization.NumberStyles.Integer, global::System.Globalization.CultureInfo.InvariantCulture, out MaxFileSizeBytes_val))\n                        {\n                            errors ??= new();\n                            errors.Add(new global::ArgumentParsing.Results.Errors.BadOptionValueFormatError(val.ToString(), latestOptionName.ToString()));\n                        }\n                        break;\n                    case 4:\n                        OutputFile_val = val.ToString();\n                        break;\n                    default:\n                        switch (parameterIndex++)\n                        {\n                            case 0:\n                                InputFile_val = arg;\n                                break;\n                            default:\n                                remainingParametersBuilder.Add(arg);\n                                break;\n                        }\n                        break;\n                }\n\n                state = 0;\n\n            continueMainLoop:\n                previousArgument = arg;\n            }\n\n            if (state > 0)\n            {\n                errors ??= new();\n                errors.Add(new global::ArgumentParsing.Results.Errors.OptionValueIsNotProvidedError(previousArgument));\n            }\n\n            if (parameterIndex <= 0)\n            {\n                errors ??= new();\n                errors.Add(new global::ArgumentParsing.Results.Errors.MissingRequiredParameterError(\n                "input-file", 0));\n            }\n\n            if (errors != null)\n            {\n                return new global::ArgumentParsing.Results.ParseResult<global::ExampleProject.FileProcessorOptions>(global::ArgumentParsing.Results.Errors.ParseErrorCollection.AsErrorCollection(errors));\n            }\n\n            global::ExampleProject.FileProcessorOptions options = new global::ExampleProject.FileProcessorOptions\n            {\n                Verbose = Verbose_val,\n                OutputFormat = OutputFormat_val,\n                MaxFileSizeBytes = MaxFileSizeBytes_val,\n                OutputFile = OutputFile_val,\n                InputFile = InputFile_val,\n                AdditionalFiles = remainingParametersBuilder.ToImmutable(),\n            };\n\n            return new global::ArgumentParsing.Results.ParseResult<global::ExampleProject.FileProcessorOptions>(options);\n        }\n    }\n}\n'))),(0,a.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\ArgumentParsing\\src\\ArgPars\\obj\\GX\\ArgumentParsing.Generators\\ArgumentParsing.Generators.ArgumentParserGenerator\\HelpCommandHandler.ExampleProject.FileProcessorOptions.g.cs",label:"HelpCommandHandler.ExampleProject.FileProcessorOptions.g.cs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated/>\n#nullable disable\n#pragma warning disable\n\nnamespace ArgumentParsing.Generated\n{\n    /// <summary>\n    /// Default implementation of <c>--help</c> command for <see cref="global::ExampleProject.FileProcessorOptions"/> type\n    /// </summary>\n    [global::ArgumentParsing.SpecialCommands.SpecialCommandAliasesAttribute("--help")]\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ArgumentParsing.Generators.ArgumentParserGenerator", "0.3.0.0")]\n    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]\n    internal sealed class HelpCommandHandler_ExampleProject_FileProcessorOptions : global::ArgumentParsing.SpecialCommands.ISpecialCommandHandler\n    {\n        /// <summary>\n        /// Generates help text for <see cref="global::ExampleProject.FileProcessorOptions"/> type.\n        /// If <paramref name="errors"/> parameter is supplied, generated text will contain an error section\n        /// </summary>\n        /// <param name="errors">Parse errors to include into help text</param>\n        /// <returns>Generated help text</returns>\n        public static string GenerateHelpText(global::ArgumentParsing.Results.Errors.ParseErrorCollection? errors = null)\n        {\n            global::System.Text.StringBuilder helpBuilder = new();\n            helpBuilder.AppendLine("ArgPars 1.0.0");\n            helpBuilder.AppendLine("Copyright (C) " + global::System.DateTime.UtcNow.Year.ToString());\n            if ((object)errors != null)\n            {\n                helpBuilder.AppendLine();\n                helpBuilder.AppendLine("ERROR(S):");\n                foreach (global::ArgumentParsing.Results.Errors.ParseError error in errors)\n                {\n                    helpBuilder.AppendLine("  " + error.GetMessage());\n                }\n            }\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("OPTIONS:");\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("  -v, --verbose\\tEnable verbose logging and detailed output");\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("  -f, --format\\tOutput format for processed files (json, xml, csv)");\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("  -m, --max-size\\tMaximum file size in bytes (default: 10MB)");\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("  -o, --output\\tOutput file path (optional, defaults to input file with new extension)");\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("PARAMETERS:");\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("  input-file (at index 0)\\tRequired. Path to the input file to process");\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("  Remaining parameters\\tAdditional files to process");\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("COMMANDS:");\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("  --help\\tShow help screen");\n            helpBuilder.AppendLine();\n            helpBuilder.AppendLine("  --version\\tShow version information");\n            return helpBuilder.ToString();\n        }\n\n        /// <inheritdoc/>\n        public int HandleCommand()\n        {\n            global::System.Console.Out.WriteLine(GenerateHelpText());\n            return 0;\n        }\n    }\n}\n'))),(0,a.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\ArgumentParsing\\src\\ArgPars\\obj\\GX\\ArgumentParsing.Generators\\ArgumentParsing.Generators.ArgumentParserGenerator\\VersionCommandHandler.ArgPars.g.cs",label:"VersionCommandHandler.ArgPars.g.cs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated/>\n#nullable disable\n#pragma warning disable\n\nnamespace ArgumentParsing.Generated\n{\n    /// <summary>\n    /// Default implementation of <c>--version</c> command for <c>ArgPars</c> assembly\n    /// </summary>\n    [global::ArgumentParsing.SpecialCommands.SpecialCommandAliasesAttribute("--version")]\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ArgumentParsing.Generators.ArgumentParserGenerator", "0.3.0.0")]\n    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]\n    internal sealed class VersionCommandHandler : global::ArgumentParsing.SpecialCommands.ISpecialCommandHandler\n    {\n        /// <inheritdoc/>\n        public int HandleCommand()\n        {\n            global::System.Console.WriteLine("ArgPars 1.0.0");\n            return 0;\n        }\n    }\n}\n')))),(0,a.kt)("h2",{id:"useful"},"Useful"),(0,a.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("a",{target:"_blank",href:t(38555).Z},"Download Example project ArgumentParsing "))),(0,a.kt)("h3",{id:"share-argumentparsing"},"Share ArgumentParsing"),(0,a.kt)("ul",null,(0,a.kt)("li",null,(0,a.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FArgumentParsing&quote=ArgumentParsing",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,a.kt)("li",null,(0,a.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FArgumentParsing&text=ArgumentParsing:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FArgumentParsing",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,a.kt)("li",null,(0,a.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FArgumentParsing&title=ArgumentParsing",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,a.kt)("li",null,(0,a.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FArgumentParsing&title=ArgumentParsing&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FArgumentParsing",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/ArgumentParsing"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/ArgumentParsing")),(0,a.kt)("h3",{id:"in-the-same-category-commandline---0-other-generators"},"In the same category (CommandLine) - 0 other generators"))}b.isMDXComponent=!0},38555:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/files/ArgumentParsing-f0680b0aae872541540029c84f960c64.zip"}}]);