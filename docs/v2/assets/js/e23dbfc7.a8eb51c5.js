"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[5605],{7522:(e,i,t)=>{t.d(i,{A:()=>s});const s=t.p+"assets/files/BitsKit-5adc7d82bd92242a73d685670f8b99fa.zip"},39846:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>h,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>b});const s=JSON.parse('{"id":"RSCG-Examples/BitsKit","title":"135 - BitsKit","description":"Reading efficiently from a bit structure","source":"@site/docs/RSCG-Examples/BitsKit.md","sourceDirName":"RSCG-Examples","slug":"/BitsKit","permalink":"/RSCG_Examples/v2/docs/BitsKit","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/RSCG-Examples/BitsKit.md","tags":[],"version":"current","sidebarPosition":1350,"frontMatter":{"sidebar_position":1350,"title":"135 - BitsKit","description":"Reading efficiently from a bit structure","slug":"/BitsKit"},"sidebar":"tutorialSidebar","previous":{"title":"134 - StronglyTypedUid","permalink":"/RSCG_Examples/v2/docs/StronglyTypedUid"},"next":{"title":"136 - MinimalApis.Discovery","permalink":"/RSCG_Examples/v2/docs/MinimalApis.Discovery"}}');var n=t(74848),r=t(28453),a=t(11470),l=t(19365),d=t(14252);const o={sidebar_position:1350,title:"135 - BitsKit",description:"Reading efficiently from a bit structure",slug:"/BitsKit"},c="BitsKit  by barncastle",h={},b=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"Features",id:"features",level:2},{value:"Usage",id:"usage",level:2},{value:"BitPrimitives",id:"bitprimitives",level:3},{value:"Bit Fields",id:"bit-fields",level:3},{value:"Padding Fields",id:"padding-fields",level:4},{value:"Boolean Bit Fields",id:"boolean-bit-fields",level:4},{value:"Enum Bit Fields",id:"enum-bit-fields",level:4},{value:"Modifiers",id:"modifiers",level:4},{value:"Examples",id:"examples",level:4},{value:"Straddling Unit Boundaries",id:"straddling-unit-boundaries",level:4},{value:"Errors",id:"errors",level:4},{value:"IO Classes",id:"io-classes",level:3},{value:"Utility Methods",id:"utility-methods",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example (source csproj, source files)",id:"example-source-csproj-source-files",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share BitsKit",id:"share-bitskit",level:3},{value:"In the same category (Bitwise) - 1 other generators",id:"in-the-same-category-bitwise---1-other-generators",level:3},{value:"Darp.BinaryObjects",id:"darpbinaryobjects",level:4}];function u(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"bitskit--by-barncastle",children:"BitsKit  by barncastle"})}),"\n",(0,n.jsx)(d.A,{toc:b}),"\n",(0,n.jsx)(i.h2,{id:"nuget--site-data",children:"NuGet / site data"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"https://www.nuget.org/packages/BitsKit/",children:(0,n.jsx)(i.img,{src:"https://img.shields.io/nuget/dt/BitsKit?label=BitsKit",alt:"Nuget"})}),"\n",(0,n.jsx)(i.a,{href:"https://github.com/barncastle/BitsKit",children:(0,n.jsx)(i.img,{src:"https://img.shields.io/github/last-commit/barncastle/BitsKit?label=updated",alt:"GitHub last commit"})}),"\n",(0,n.jsx)(i.img,{src:"https://img.shields.io/github/stars/barncastle/BitsKit?style=social",alt:"GitHub Repo stars"})]}),"\n",(0,n.jsx)(i.h2,{id:"details",children:"Details"}),"\n",(0,n.jsx)(i.h3,{id:"info",children:"Info"}),"\n",(0,n.jsxs)(i.admonition,{type:"info",children:[(0,n.jsxs)(i.p,{children:["Name: ",(0,n.jsx)(i.strong,{children:"BitsKit"})]}),(0,n.jsx)(i.p,{children:"BitsKit is a library for efficient bit-level reading and writing also adding bit field support."}),(0,n.jsx)(i.p,{children:"Author: barncastle"}),(0,n.jsxs)(i.p,{children:["NuGet:\n",(0,n.jsx)(i.em,{children:(0,n.jsx)(i.a,{href:"https://www.nuget.org/packages/BitsKit/",children:"https://www.nuget.org/packages/BitsKit/"})})]}),(0,n.jsxs)(i.p,{children:["You can find more details at ",(0,n.jsx)(i.a,{href:"https://github.com/barncastle/BitsKit",children:"https://github.com/barncastle/BitsKit"})]}),(0,n.jsxs)(i.p,{children:["Source: ",(0,n.jsx)(i.a,{href:"https://github.com/barncastle/BitsKit",children:"https://github.com/barncastle/BitsKit"})]})]}),"\n",(0,n.jsx)(i.h3,{id:"original-readme",children:"Original Readme"}),"\n",(0,n.jsxs)(i.admonition,{type:"note",children:[(0,n.jsx)(i.h1,{id:"bitskit",children:"BitsKit"}),(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://www.nuget.org/packages/BitsKit",children:(0,n.jsx)(i.img,{src:"https://img.shields.io/nuget/v/BitsKit",alt:"NuGet Version"})})}),(0,n.jsxs)(i.p,{children:["BitsKit is a lightweight C# library that provides efficient bit-level reading, writing and manipulation. As well as adding bit-field support to C#, not dissimilar to ",(0,n.jsx)(i.a,{href:"https://en.cppreference.com/w/cpp/language/bit_field",children:"C/C++ languages"}),"."]}),(0,n.jsx)(i.p,{children:"All features support integral and memory types, as well as targeting both, Little Endian (LE) Least Significant Bit (LSB) and Big Endian (BE) Most Significant Bit (MSB)."}),(0,n.jsx)(i.h2,{id:"features",children:"Features"}),(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"#bitprimitives",children:"BitPrimitives"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"#bit-fields",children:"Bit Fields"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"#io-classes",children:"IO Classes"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"#utility-methods",children:"Utility Methods"})}),"\n"]}),(0,n.jsx)(i.h2,{id:"usage",children:"Usage"}),(0,n.jsx)(i.h3,{id:"bitprimitives",children:"BitPrimitives"}),(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"BitsKit.Primitives.BitPrimitives"})," is the workhorse of the library containing all of the read and write logic. This class is the bit equivalent of ",(0,n.jsx)(i.code,{children:"System.Buffers.Binary.BinaryPrimitives"})," and contains a MSB and LSB read and write method for each of the below integral types:"]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"sbyte, byte, short, ushort, int, uint, long, ulong, nint, nuint\n"})}),(0,n.jsxs)(i.p,{children:["Each type has two overloads allowing the source/destination to be either a ",(0,n.jsx)(i.code,{children:"Span<byte>"})," or ",(0,n.jsx)(i.code,{children:"T"})," e.g.,"]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"// reads a range of bits from a uint as MSB\nstatic uint ReadUInt32MSB(uint source, int bitOffset, int bitCount);\n\n// reads a range of bits from a span as MSB\nstatic uint ReadUInt32MSB(ReadOnlySpan<byte> source, int bitOffset, int bitCount);\n\n// writes a range of bits to a uint as MSB\nstatic void WriteUInt32MSB(ref uint destination, int bitOffset, uint value, int bitCount);\n\n// writes a range of bits to a span as MSB\nstatic void WriteUInt32MSB(Span<byte> destination, int bitOffset, uint value, int bitCount);\n"})}),(0,n.jsxs)(i.p,{children:["This class also provides a ",(0,n.jsx)(i.code,{children:"ReverseBitOrder"})," method for each integral type which inverts the bit order of each byte within the value, but not the order (endianness) of the bytes themselves e.g."]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"// reverses the bit order of each byte\nstatic uint ReverseBitOrder(uint value);\n\n//7......0 7......0      0......7 0......7\n0b11001000_00111011 => 0b00010011_11011100\n"})}),(0,n.jsx)(i.h3,{id:"bit-fields",children:"Bit Fields"}),(0,n.jsx)(i.p,{children:"BitsKit provides the ability to generate bit-fields within types and aims to be as feature complete as the C and C++ implementations. This is achieved through the use of attributes applied to backing fields, which describe the structure and layout. These are converted into properties via a source generator."}),(0,n.jsxs)(i.p,{children:["Bit fields can be added to class, struct and record types, supporting all of their variants too e.g., ",(0,n.jsx)(i.code,{children:"readonly struct"}),", ",(0,n.jsx)(i.code,{children:"record struct"})," etc. Objects containing bit-fields are declared by the ",(0,n.jsx)(i.code,{children:"[BitObjectAttribute(BitOrder)]"})," attribute which also declares the default bit order for the type. Types must be partial and not nested."]}),(0,n.jsxs)(i.p,{children:["Due to the nature of source generators, the user must generate the backing fields. Whilst this is more verbose than in C, it does provide much more granularity and control opening up some interesting dynamics. Backing fields must be a ",(0,n.jsx)(i.code,{children:"field"})," and either; one of integral types above or one of the memory types below."]}),(0,n.jsx)(i.p,{children:(0,n.jsx)(i.code,{children:"byte[], fixed byte[], byte*, Span<byte>, ReadOnlySpan<byte>, Memory<byte>, ReadOnlyMemory<byte>"})}),(0,n.jsxs)(i.p,{children:["Bit fields are declared using the ",(0,n.jsx)(i.code,{children:"[BitFieldAttribute]"})," attribute which describes their name, size, bit order and properties. Each attribute defines a new bit-field sequential from the previous. A backing field can have as many bit-fields as desired, limited only by field boundaries."]}),(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Notes:"})}),(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"If the backing field is an integral type, the bit-field will be of the same type."}),"\n",(0,n.jsxs)(i.li,{children:["If the backing field is a memory type, the ",(0,n.jsx)(i.code,{children:"FieldType"})," is required as it cannot be inferred."]}),"\n",(0,n.jsxs)(i.li,{children:["If the backing field is ",(0,n.jsx)(i.code,{children:"readonly"})," or represents a readonly type, the bit-field will also be readonly."]}),"\n"]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"// Constructor for integral backed bit-fields\n[BitFieldAttribute(string name, byte size)]\n// Constructor for memory backed bit-fields\n[BitFieldAttribute(string name, byte size, BitFieldType fieldType)]\n\nFields:\n// The name of the bit-field\npublic string? Name { get; }\n// The number of bits the field occupies \npublic byte Size { get; }\n// The integral type of the field if backed by a memory type\npublic BitFieldType? FieldType { get; }\n// Uses the opposite bit order than declared on the type\npublic bool ReverseBitOrder { get; set; }\n// Modifiers that change the source generation\npublic BitFieldModifiers Modifiers { get; set; }\n"})}),(0,n.jsx)(i.h4,{id:"padding-fields",children:"Padding Fields"}),(0,n.jsx)(i.p,{children:'Like C, an unnamed bit-field generates a set of inaccessible "padding" bits. These are primarily used for alignment or to map reserved/unused bits. There is a constructor overload dedicated to these fields.'}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"// Constructor for integral padding bit-fields\n[BitFieldAttribute(byte size)]\n// Constructor for boolean padding bit-fields\n[BooleanFieldAttribute]\n// Constructor for enum padding bit-fields\n[EnumFieldAttribute(byte size)]\n"})}),(0,n.jsx)(i.h4,{id:"boolean-bit-fields",children:"Boolean Bit Fields"}),(0,n.jsxs)(i.p,{children:["Boolean bit-fields are supported by the ",(0,n.jsx)(i.code,{children:"[BooleanFieldAttribute]"})," helper attribute. Boolean fields consume a single bit and return if it is set or not. This attribute can be applied to any valid backing field and inherits from the ",(0,n.jsx)(i.code,{children:"[BitFieldAttribute]"})," attribute. Boolean fields can be mixed with integer and enum fields without incurring a new unit."]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"// Constructor for boolean bit-fields\n[BooleanFieldAttribute(string name)]\n"})}),(0,n.jsx)(i.h4,{id:"enum-bit-fields",children:"Enum Bit Fields"}),(0,n.jsxs)(i.p,{children:["Enum bit-fields are supported by the ",(0,n.jsx)(i.code,{children:"[EnumFieldAttribute]"})," helper attribute. This attribute can be applied to any valid backing field and inherits from the ",(0,n.jsx)(i.code,{children:"[BitFieldAttribute]"})," attribute. The enum type must be passed as a type argument i.e., ",(0,n.jsx)(i.code,{children:"typeof(MyEnum)"}),". Enum fields can be mixed with integer and boolean fields without incurring a new unit."]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"// Constructor for enum bit-fields\n[EnumFieldAttribute(string name, byte size, Type enumType)]\n"})}),(0,n.jsx)(i.h4,{id:"modifiers",children:"Modifiers"}),(0,n.jsxs)(i.p,{children:["The ",(0,n.jsx)(i.code,{children:"BitFieldModifiers"})," enum allows alterations to the way that the source generator produces the bit-fields. By default all bit-fields are generated as a ",(0,n.jsx)(i.em,{children:"public read/write"})," or ",(0,n.jsx)(i.em,{children:"public readonly"})," properties relative to their backing field's accessibility. The ",(0,n.jsx)(i.code,{children:"Modifiers"})," field allows control over this and provides the ability to change a bit-field's accessibility and if it is ",(0,n.jsx)(i.code,{children:"readonly"}),", ",(0,n.jsx)(i.code,{children:"init only"})," (.NET 6.0) and/or ",(0,n.jsx)(i.code,{children:"required"})," (.NET 7.0)."]}),(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"Note:"})," Currently both the getter and setter share the same accessibility therefore you cannot have public bit-fields with private setters."]}),(0,n.jsx)(i.h4,{id:"examples",children:"Examples"}),(0,n.jsx)(i.p,{children:"Putting this into action with the following C struct:"}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c++",children:'struct S\n{\n    // occupies 2 bytes:\n    unsigned char b1 : 3;  // 1st 3 bits (in 1st byte) are b1\n    unsigned char    : 2;  // next 2 bits (in 1st byte) are unused "padding"\n    unsigned char b2 : 1;  // next 1 bit (in 1st byte) is b2\n    unsigned char b3 : 6;  // 6 bits for b3 - doesn\'t fit into the 1st byte => starts a 2nd\n    unsigned char b4 : 2;  // 2 bits for b4 - next (and final) bits in the 2nd byte\n};\n'})}),(0,n.jsx)(i.p,{children:"Converted to it's BitsKit representation:"}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:'[BitObject(BitOrder.LeastSignificantBit)]\npublic partial struct S \n{\n    [BitField("b1", 3)]     // 1st 3 bits (in 1st byte) are b1\n    [BitField(2)]           // next 2 bits (in 1st byte) are unused "padding"\n    [BitField("b2", 1)]     // next 1 bit (in 1st byte) is b2\n    private byte _backingField1;\n    \n    [BitField("b3", 6)]     // 6 bits for b3 - doesn\'t fit into the 1st byte => use a 2nd\n    [BitField("b4", 2)]     // 2 bits for b4 - next (and final) bits in the 2nd byte\n    private byte _backingField2;\n}\n'})}),(0,n.jsx)(i.p,{children:"Which produces a new generated partial class containing:"}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"public partial struct S \n{\n    public byte b1 { get => ..; set => ..; }; // _backingField1 0..2\n    public byte b2 { get => ..; set => ..; }; // _backingField1 5\n    public byte b3 { get => ..; set => ..; }; // _backingField2 0..5\n    public byte b4 { get => ..; set => ..; }; // _backingField2 6..7\n}\n"})}),(0,n.jsx)(i.h4,{id:"straddling-unit-boundaries",children:"Straddling Unit Boundaries"}),(0,n.jsx)(i.p,{children:'Some C compilers support straddling storage-unit boundaries. An example of this would be the "b3" field in the above example occupying the last 2 bits in the first byte and the first 4 bits in the second byte. BitsKit enforces unit boundaries for integral types however memory types do allow this.'}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:'[BitObject(BitOrder.LeastSignificantBit)]\npublic unsafe partial struct S \n{\n    [BitField("b1", 3)] // 1st 3 bits (in 1st byte) are b1\n    [BitField(2)]       // next 2 bits (in 1st byte) are unused "padding"\n    [BitField("b2", 1)] // next 1 bit (in 1st byte) is b2\n    [BitField("b3", 6)] // next (and final) 2 bits in 1st byte and 1st 4 bits in 2nd byte\n    [BitField("b4", 4)] // 4 bits for b4 - next (and final) bits in the 2nd byte\n    private fixed byte _backingField[2];\n}\n'})}),(0,n.jsx)(i.h4,{id:"errors",children:"Errors"}),(0,n.jsxs)(i.p,{children:["Below are the diagnostics BitsKit produces. Additionally, an ",(0,n.jsx)(i.code,{children:"ArgumentOutOfRangeException"})," exception is thrown if the bit offset or count exceed the bounds of the backing field/source."]}),(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Rule ID"}),(0,n.jsx)(i.th,{children:"Severity"}),(0,n.jsx)(i.th,{children:"Notes"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"BITSKIT001"}),(0,n.jsx)(i.td,{children:"Error"}),(0,n.jsx)(i.td,{children:"BitsKit object must be partial"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"BITSKIT002"}),(0,n.jsx)(i.td,{children:"Error"}),(0,n.jsx)(i.td,{children:"BitsKit object must not be a nested type"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"BITSKIT003"}),(0,n.jsx)(i.td,{children:"Error"}),(0,n.jsx)(i.td,{children:"Cannot infer FieldType"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"BITSKIT004"}),(0,n.jsx)(i.td,{children:"Warning"}),(0,n.jsx)(i.td,{children:"Conflicting accessibility modifiers"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"BITSKIT005"}),(0,n.jsx)(i.td,{children:"Warning"}),(0,n.jsx)(i.td,{children:"Conflicting setter modifiers"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"BITSKIT006"}),(0,n.jsx)(i.td,{children:"Error"}),(0,n.jsx)(i.td,{children:"Enum type argument expected"})]})]})]}),(0,n.jsx)(i.h3,{id:"io-classes",children:"IO Classes"}),(0,n.jsxs)(i.p,{children:["There are a number of IO types available under the ",(0,n.jsx)(i.code,{children:"BitsKit.IO"})," namespace built to sequentially read/write regions of bit data. Each of these classes expose all the ",(0,n.jsx)(i.code,{children:"BitPrimitives"})," methods whilst supporting seeking and writing in-place."]}),(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"BitReader/BitWriter"})," - Classes for reading/writing to a byte array.\n",(0,n.jsx)(i.code,{children:"MemoryBitReader/MemoryBitWriter"})," - Ref structs for reading/writing to a ",(0,n.jsx)(i.code,{children:"Span<byte>"}),".\n",(0,n.jsx)(i.code,{children:"BitStreamReader/BitStreamWriter"})," - Classes for reading/writing to a stream."]}),(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Notes:"})}),(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["The array and span backed types support up to ",(0,n.jsx)(i.code,{children:"int.MaxValue"})," bits as they use a signed integer for positioning to boost performance. This limits the source to being less than 0x10000000 bytes."]}),"\n",(0,n.jsxs)(i.li,{children:["The ",(0,n.jsx)(i.code,{children:"BitStreamWriter"})," class does support writing in-place however, the destination stream must be both readable and seekable to allowing buffering of the stream's existing data."]}),"\n"]}),(0,n.jsx)(i.h3,{id:"utility-methods",children:"Utility Methods"}),(0,n.jsxs)(i.p,{children:["Additional utilities for common bit processing tasks are provided under the ",(0,n.jsx)(i.code,{children:"BitsKit.Utilities"})," namespace. Many of these functions have been taken from the awesome ",(0,n.jsx)(i.a,{href:"https://graphics.stanford.edu/~seander/bithacks.html",children:"Bit Twiddling Hacks"})," page created by Sean Eron Anderson."]}),(0,n.jsxs)(i.p,{children:[(0,n.jsxs)(i.strong,{children:["BitUtilities.InterleaveBits (",(0,n.jsx)(i.a,{href:"https://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN",children:"See"}),")"]}),' Interleaves the bits of two integral numbers. This is also known as "Morton numbers" or "Morton codes" e.g.,']}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"static uint InterleaveBits(ushort a, ushort b)\n\n//  a          b          baba_baba_baba\n0b00_1111, 0b10_0010 => 0b1000_0101_1101\n"})}),(0,n.jsxs)(i.p,{children:[(0,n.jsxs)(i.strong,{children:["BitUtilities.MergeBits (",(0,n.jsx)(i.a,{href:"https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge",children:"See"}),")"]})," Merges the bits of two integral numbers according to a mask. If the mask bit is a ",(0,n.jsx)(i.code,{children:"0"}),", the bit is taken from ",(0,n.jsx)(i.code,{children:"a"})," otherwise it is taken from ",(0,n.jsx)(i.code,{children:"b"})," e.g.,"]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"static uint MergeBits(uint a, uint b, uint mask)\n\n//   a           b          mask        bbbbaaaa\n0b10101110, 0b11001010, 0b11110000 => 0b11001110\n"})}),(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"BitUtilities.NegateBits"})," Negates a range of bits within an integral number e.g.,"]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"static uint NegateBits(uint value, int bitOffset, int bitCount)\n\n//  value   offset count      xxxx\n0b1100_1101   4     4    => 0b0011_1101\n"})}),(0,n.jsxs)(i.p,{children:[(0,n.jsxs)(i.strong,{children:["BitUtilities.ReverseBits (",(0,n.jsx)(i.a,{href:"https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel",children:"See"}),")"]})," Reverses both the bit and byte order (endian) of an integral number e.g.,"]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"static uint ReverseBits(uint value)\n\n//   a        b             b        a\n//7......0 7......0      0......7 0......7\n0b11001000_00111011 => 0b11011100_00010011\n"})}),(0,n.jsxs)(i.p,{children:[(0,n.jsxs)(i.strong,{children:["BitUtilities.SwapBits (",(0,n.jsx)(i.a,{href:"https://graphics.stanford.edu/~seander/bithacks.html#SwappingBitsXOR",children:"See"}),")"]})," Swaps the positions of two ranges of bits within an integral number e.g.,"]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"static uint SwapBits(uint value, int offsetA, int offsetB, int bitCount)\n\n//  value   offsetA offsetB bitCount       bbaa\n0b1100_1101    4       6       2      => 0b0011_1101\n"})}),(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"ZigZag"})," An integer encoding used to convert signed integers to unsigned integers whilst maintaining a relative sized bit count. This is achieved by making the least significant bit the sign bit thus making the bit count proportional to the magnitude. This encoding is particularly useful for deltas with a small range e.g.,"]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c#",children:"static uint Encode(int value)\nstatic int Decode(uint value)\n\n//   -2         -1         0         1         2\n// Two's complement\n0b11111110 0b11111111 0b00000000 0b00000001 0b00000010\n// ZigZag Encoded\n0b00000011 0b00000001 0b00000000 0b00000010 0b00000100\n"})})]}),"\n",(0,n.jsx)(i.h3,{id:"about",children:"About"}),"\n",(0,n.jsx)(i.admonition,{type:"note",children:(0,n.jsx)(i.p,{children:"Reading efficiently from a bit structure"})}),"\n",(0,n.jsx)(i.h2,{id:"how-to-use",children:"How to use"}),"\n",(0,n.jsx)(i.h3,{id:"example-source-csproj-source-files",children:"Example (source csproj, source files)"}),"\n",(0,n.jsxs)(a.A,{children:[(0,n.jsxs)(l.A,{value:"csproj",label:"CSharp Project",children:[(0,n.jsxs)(i.p,{children:["This is the CSharp Project that references ",(0,n.jsx)(i.strong,{children:"BitsKit"})]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-xml",metastring:"showLineNumbers {11}",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include="BitsKit" Version="1.0.0" />\n  </ItemGroup>\n\n\t<PropertyGroup>\n\t\t<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n\t\t<CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n\t</PropertyGroup>\n\n</Project>\n\n'})})]}),(0,n.jsxs)(l.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\BitsKit\\src\\BitsDemo\\Program.cs",label:"Program.cs",children:[(0,n.jsxs)(i.p,{children:["This is the use of ",(0,n.jsx)(i.strong,{children:"BitsKit"})," in ",(0,n.jsx)(i.em,{children:"Program.cs"})]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"using BitsDemo;\n\nvar z = new zlib_header(0x78, 0x9C);\nConsole.WriteLine( z.FLEVEL );\nConsole.WriteLine(z.CM);\n"})})]}),(0,n.jsxs)(l.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\BitsKit\\src\\BitsDemo\\BitStruct.cs",label:"BitStruct.cs",children:[(0,n.jsxs)(i.p,{children:["This is the use of ",(0,n.jsx)(i.strong,{children:"BitsKit"})," in ",(0,n.jsx)(i.em,{children:"BitStruct.cs"})]}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'using BitsKit;\nusing BitsKit.BitFields;\nusing System.IO.Compression;\n\nnamespace BitsDemo;\n//[BitObject(BitOrder.LeastSignificant)]\n//partial struct zlib_header\n//{\n//    public zlib_header(byte cmf, byte flg)\n//    {\n//        CMF = cmf;\n//        FLG = flg;\n//    }\n//    [EnumField("CM", 4, typeof(CompressionMode))]\n//    [BitField("CINFO", 4)]\n//    private byte CMF;\n\n//    [BitField("FCHECK", 5)]\n//    [BooleanField("FDICT")]\n//    [EnumField("FLEVEL", 2, typeof(CompressionLevel))]\n//    private byte FLG;\n//}\n\n[BitObject(BitOrder.LeastSignificant)]\npartial struct zlib_header\n{\n    public zlib_header(byte cmf, byte flg)\n    {\n        CMF = cmf;\n        FLG = flg;\n    }\n\n    [BitField("CM", 4)]\n    [BitField("CINFO", 4)]\n    private byte CMF;\n\n    [BitField("FCHECK", 5)]\n    [BitField("FDICT", 1)]\n    [BitField("FLEVEL", 2)]\n    private byte FLG;\n}\n'})})]})]}),"\n",(0,n.jsx)(i.h3,{id:"generated-files",children:"Generated Files"}),"\n",(0,n.jsx)(i.p,{children:"Those are taken from $(BaseIntermediateOutputPath)\\GX"}),"\n",(0,n.jsx)(a.A,{children:(0,n.jsx)(l.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\BitsKit\\src\\BitsDemo\\obj\\GX\\BitsKit.Generator\\BitsKit.Generator.BitObjectGenerator\\BitsKitGeneratedFields.g.cs",label:"BitsKitGeneratedFields.g.cs",children:(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"#nullable enable\n#pragma warning disable IDE0005 // Using directive is unnecessary\n#pragma warning disable IDE0005_gen // Using directive is unnecessary\n#pragma warning disable CS8019  // Unnecessary using directive.\n#pragma warning disable IDE0161 // Convert to file-scoped namespace\n\nusing System;\nusing System.Runtime.InteropServices;\nusing BitsKit.Primitives;\n\nnamespace BitsDemo\n{\n    partial struct  zlib_header\n    {\n        public  Byte CM \n        {\n            get => BitPrimitives.ReadUInt8LSB(CMF, 0, 4);\n            set => BitPrimitives.WriteUInt8LSB(ref CMF, 0, value, 4);\n        }\n\n        public  Byte CINFO \n        {\n            get => BitPrimitives.ReadUInt8LSB(CMF, 4, 4);\n            set => BitPrimitives.WriteUInt8LSB(ref CMF, 4, value, 4);\n        }\n\n        public  Byte FCHECK \n        {\n            get => BitPrimitives.ReadUInt8LSB(FLG, 0, 5);\n            set => BitPrimitives.WriteUInt8LSB(ref FLG, 0, value, 5);\n        }\n\n        public  Byte FDICT \n        {\n            get => BitPrimitives.ReadUInt8LSB(FLG, 5, 1);\n            set => BitPrimitives.WriteUInt8LSB(ref FLG, 5, value, 1);\n        }\n\n        public  Byte FLEVEL \n        {\n            get => BitPrimitives.ReadUInt8LSB(FLG, 6, 2);\n            set => BitPrimitives.WriteUInt8LSB(ref FLG, 6, value, 2);\n        }\n    }\n}\n\n"})})})}),"\n",(0,n.jsx)(i.h2,{id:"useful",children:"Useful"}),"\n",(0,n.jsx)(i.h3,{id:"download-example-net--c-",children:"Download Example (.NET  C# )"}),"\n",(0,n.jsx)(i.admonition,{type:"tip",children:(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(7522).A+"",children:"Download Example project BitsKit "})})}),"\n",(0,n.jsx)(i.h3,{id:"share-bitskit",children:"Share BitsKit"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:(0,n.jsx)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FBitsKit&quote=BitsKit",title:"Share on Facebook",target:"_blank",children:"Share on Facebook"})}),(0,n.jsx)("li",{children:(0,n.jsx)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FBitsKit&text=BitsKit:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FBitsKit",target:"_blank",title:"Tweet",children:"Share in Twitter"})}),(0,n.jsx)("li",{children:(0,n.jsx)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FBitsKit&title=BitsKit",target:"_blank",title:"Submit to Reddit",children:"Share on Reddit"})}),(0,n.jsx)("li",{children:(0,n.jsx)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FBitsKit&title=BitsKit&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FBitsKit",target:"_blank",title:"Share on LinkedIn",children:"Share on Linkedin"})})]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/BitsKit",children:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/BitsKit"})}),"\n",(0,n.jsx)(i.h3,{id:"in-the-same-category-bitwise---1-other-generators",children:"In the same category (Bitwise) - 1 other generators"}),"\n",(0,n.jsx)(i.h4,{id:"darpbinaryobjects",children:(0,n.jsx)(i.a,{href:"/docs/Darp.BinaryObjects",children:"Darp.BinaryObjects"})})]})}function p(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}}}]);