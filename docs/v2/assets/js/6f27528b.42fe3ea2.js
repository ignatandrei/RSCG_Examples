"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[2044],{4874:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>m,default:()=>g,frontMatter:()=>s,metadata:()=>u,toc:()=>v});var i=n(87462),r=(n(67294),n(3905)),a=n(73992),o=n(18679),l=n(68839);const s={sidebar_position:970,title:"97 - DomainPrimitives",description:"One of the most complete and mature libraries for DomainPrimitives in  .NET",slug:"/DomainPrimitives"},m="DomainPrimitives  by Alta Software - Teimuraz Nikolaishvili",u={unversionedId:"RSCG-Examples/DomainPrimitives",id:"RSCG-Examples/DomainPrimitives",title:"97 - DomainPrimitives",description:"One of the most complete and mature libraries for DomainPrimitives in  .NET",source:"@site/docs/RSCG-Examples/DomainPrimitives.md",sourceDirName:"RSCG-Examples",slug:"/DomainPrimitives",permalink:"/RSCG_Examples/v2/docs/DomainPrimitives",draft:!1,tags:[],version:"current",sidebarPosition:970,frontMatter:{sidebar_position:970,title:"97 - DomainPrimitives",description:"One of the most complete and mature libraries for DomainPrimitives in  .NET",slug:"/DomainPrimitives"},sidebar:"tutorialSidebar",previous:{title:"96 - HsuSgSync",permalink:"/RSCG_Examples/v2/docs/HsuSgSync"},next:{title:"98 - Funcky.DiscriminatedUnion",permalink:"/RSCG_Examples/v2/docs/Funcky.DiscriminatedUnion"}},p={},v=[{value:"Nuget / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share DomainPrimitives",id:"share-domainprimitives",level:3},{value:"In the same category (PrimitiveObsession) - 3 other generators",id:"in-the-same-category-primitiveobsession---3-other-generators",level:3},{value:"Strongly",id:"strongly",level:4},{value:"UnitGenerator",id:"unitgenerator",level:4},{value:"Vogen",id:"vogen",level:4}],d={toc:v},c="wrapper";function g(e){let{components:t,...s}=e;return(0,r.kt)(c,(0,i.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"domainprimitives--by-alta-software---teimuraz-nikolaishvili"},"DomainPrimitives  by Alta Software - Teimuraz Nikolaishvili"),(0,r.kt)(l.Z,{toc:v,mdxType:"TOCInline"}),(0,r.kt)("h2",{id:"nuget--site-data"},"Nuget / site data"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Generator"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/AltaSoft.DomainPrimitives.Generator?label=AltaSoft.DomainPrimitives.Generator",alt:"Nuget"})),(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Abstractions"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/AltaSoft.DomainPrimitives.Abstractions?label=AltaSoft.DomainPrimitives.Abstractions",alt:"Nuget"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/altasoft/DomainPrimitives"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/altasoft/DomainPrimitives?label=updated",alt:"GitHub last commit"})),"\n",(0,r.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/altasoft/DomainPrimitives?style=social",alt:"GitHub Repo stars"})),(0,r.kt)("h2",{id:"details"},"Details"),(0,r.kt)("h3",{id:"info"},"Info"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Name: ",(0,r.kt)("strong",{parentName:"p"},"DomainPrimitives")),(0,r.kt)("p",{parentName:"admonition"},"Domain Primitives source generator for C#."),(0,r.kt)("p",{parentName:"admonition"},"Author: Alta Software - Teimuraz Nikolaishvili"),(0,r.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Generator"},"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Generator")),"   "),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Abstractions"},"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Abstractions")),"   "),(0,r.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/altasoft/DomainPrimitives"},"https://github.com/altasoft/DomainPrimitives")),(0,r.kt)("p",{parentName:"admonition"},"Source : ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/altasoft/DomainPrimitives"},"https://github.com/altasoft/DomainPrimitives"))),(0,r.kt)("h3",{id:"original-readme"},"Original Readme"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("h1",{parentName:"admonition",id:"domainprimitives-for-c"},"DomainPrimitives for C#"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/profiles/AltaSoft"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/static/v1?label=Version&message=1.0.3&color=0c3c60&style=for-the-badge",alt:"Version"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://dotnet.microsoft.com"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/static/v1?label=DOTNET&message=7%2B&color=0c3c60&style=for-the-badge",alt:"Dot NET 7+"}))),(0,r.kt)("h1",{parentName:"admonition",id:"table-of-contents"},"Table of Contents"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#introduction"},"Introduction")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#key-features"},"Key Features")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#generator-features"},"Generator Features")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#supported-underlying-types"},"Supported Underlying types")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#getting-started"},"Getting Started")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#prerequisites"},"Prerequisites")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#installation"},"Installation")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#creating-your-domain-type"},"Creating your Domain type")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#json-conversion"},"Json Conversion")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#contributions"},"Contributions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#contact"},"Contact")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#license"},"License"))),(0,r.kt)("h2",{parentName:"admonition",id:"introduction"},"Introduction"),(0,r.kt)("p",{parentName:"admonition"},"Welcome to ",(0,r.kt)("strong",{parentName:"p"},"AltaSoft.DomainPrimitives")," - a C# toolkit purposefully designed to accelerate the development of domain-specific primitives within your applications. This streamlined solution empowers developers to efficiently encapsulate fundamental domain logic. Through this toolkit, you'll significantly reduce code complexity while improving the maintainability of your project."),(0,r.kt)("h2",{parentName:"admonition",id:"key-features"},"Key Features"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Simplified Primitive Creation")," - Utilize source generators to swiftly create domain-specific primitives with ease and precision."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Versatile Underlying Type Support")," - Embrace a wide array of underlying types, catering to diverse application requirements."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Enhanced Code Quality")," - Create clean, maintainable, and thoroughly testable code through encapsulation and robust design principles.")),(0,r.kt)("p",{parentName:"admonition"},"With ",(0,r.kt)("inlineCode",{parentName:"p"},"AltaSoft.DomainPrimitives"),", experience an accelerated development process while upholding code quality standards. This toolkit empowers developers to focus on the core business logic without compromising on precision or efficiency."),(0,r.kt)("h2",{parentName:"admonition",id:"generator-features"},"Generator Features"),(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("strong",{parentName:"p"},"AltaSoft.DomainPrimitives.Generator")," offers a diverse set of features:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Implicit Operators:")," Streamlines type conversion to/from the underlying primitive type. ",(0,r.kt)("a",{parentName:"li",href:"#implicit-usage-of-domaintype"},"Example")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Specialized Constructor Generation:"),"  Automatically validates and constructs instances of this domain type. This constructor, tailored for the domain primitive, utilizes the underlying type as a parameter, ensuring the value's correctness within the domain."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"JsonConverters:")," Handles JSON serialization and deserialization for the underlying type. ",(0,r.kt)("a",{parentName:"li",href:"#json-conversion"},"Example")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"TypeConverters:")," Assists in type conversion to/from it's underlying type. ",(0,r.kt)("a",{parentName:"li",href:"#type-converter"},"Please refer to generated type converter below")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Swagger Custom Type Mappings:")," Facilitates easy integration with Swagger by treating the primitive type as it's underlying type. ",(0,r.kt)("a",{parentName:"li",href:"#swagger-mappers"},"Please refer to generated swagger helper below")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Interface Implementations:")," All DomainPritmitives Implement ",(0,r.kt)("inlineCode",{parentName:"li"},"IConvertible"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"IComparable"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"IComparable<T>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"IEquatable<T>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"IEqualityComparer<T>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"IParsable")," interfaces."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"NumberType Operations:")," Automatically generates basic arithmetic and comparison operators, by implementing Static abstract interfaces. ",(0,r.kt)("a",{parentName:"li",href:"#number-types-attribute"},"More details regarding numeric types")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"IParsable Implementation:")," Automatically generates parsing for non-string types.")),(0,r.kt)("h2",{parentName:"admonition",id:"supported-underlying-types"},"Supported Underlying types"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"string")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Guid")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"byte")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"sbyte")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"short")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"ushort")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"int")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"uint")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"long")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"ulong")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"decimal")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"double")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"float")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"bool")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"char")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"string")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"TimeSpan")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Guid")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"DateTime")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"DateTimeOffset")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"DateOnly")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"TimeOnly"))),(0,r.kt)("h2",{parentName:"admonition",id:"getting-started"},"Getting Started"),(0,r.kt)("h3",{parentName:"admonition",id:"prerequisites"},"Prerequisites"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},".NET 7 or higher"),(0,r.kt)("li",{parentName:"ul"},"NuGet Package Manager")),(0,r.kt)("h3",{parentName:"admonition",id:"installation"},"Installation"),(0,r.kt)("p",{parentName:"admonition"},"To use ",(0,r.kt)("strong",{parentName:"p"},"AltaSoft.DomainPrimitives"),", install two NuGet packages:"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"AltaSoft.DomainPrimitives.Abstractions")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"AltaSoft.DomainPrimitives.Generator"))),(0,r.kt)("p",{parentName:"admonition"},"In your project file add references as follows:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<ItemGroup>\n  <PackageReference Include="AltaSoft.DomainPrimitives.Abstractions" Version="1.0.3" />\n  <PackageReference Include="AltaSoft.DomainPrimitives.Generator" Version="1.0.3" OutputItemType="Analyzer" ReferenceOutputAssembly="false" PrivateAssets="all" ExcludeAssets="runtime" />\n</ItemGroup>\n')),(0,r.kt)("h2",{parentName:"admonition",id:"creating-your-domain-type"},(0,r.kt)("strong",{parentName:"h2"},"Creating your Domain type")),(0,r.kt)("p",{parentName:"admonition"},"For optimal performance, we recommend using ",(0,r.kt)("inlineCode",{parentName:"p"},"readonly struct")," - especially for wrapping value types"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public readonly partial record struct PositiveInteger : IDomainValue<int>\n{\n    public static void Validate(int value)\n    {\n        if (value <= 0)\n            throw new InvalidDomainValueException("Number must be positive");\n    }\n    public static int Default => 1;\n}\n')),(0,r.kt)("p",{parentName:"admonition"},"This will automatically generate by default 4 classes"),(0,r.kt)("h2",{parentName:"admonition",id:"positiveintegergenerated"},(0,r.kt)("strong",{parentName:"h2"},"PositiveInteger.Generated")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Text.Json.Serialization;\nusing AltaSoft.DomainPrimitives.Converters;\nusing System.ComponentModel;\n\nnamespace AltaSoft.DomainPrimitives;\n\n[JsonConverter(typeof(PositiveIntegerJsonConverter))]\n[TypeConverter(typeof(PositiveIntegerTypeConverter))]\n[DebuggerDisplay("{_valueOrDefault}")]\npublic readonly partial record struct PositiveInteger :\n        IAdditionOperators<PositiveInteger, PositiveInteger, PositiveInteger>,\n        ISubtractionOperators<PositiveInteger, PositiveInteger, PositiveInteger>,\n        IMultiplyOperators<PositiveInteger, PositiveInteger, PositiveInteger>,\n        IDivisionOperators<PositiveInteger, PositiveInteger, PositiveInteger>,\n        IModulusOperators<PositiveInteger, PositiveInteger, PositiveInteger>,\n        IComparisonOperators<PositiveInteger, PositiveInteger, bool>,\n        IComparable,\n        IComparable<PositiveInteger>,\n        IParsable<PositiveInteger>,\n        IConvertible\n{\n    private int _valueOrDefault => _isInitialized ? _value : Default;\n    [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n    private readonly int _value;\n    [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n    private readonly bool _isInitialized;\n    \n    /// <summary>\n    /// Initializes a new instance of the PositiveInteger class by validating the provided value using <see cref="Validate"/>.\n    /// </summary>\n    /// <param name="value">The value to be validated..</param>\n    public PositiveInteger(int value)\n    {\n            Validate(value);\n            _value = value;\n            _isInitialized = true;\n    }\n    \n    [Obsolete("Domain primitive cannot be created using empty Ctor", true)]\n    public PositiveInteger() : this(Default)\n    {\n    }\n    \n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "PositiveInteger"/></summary>\n    /// </summary>\n    public static implicit operator PositiveInteger(int value) => new(value);\n\n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "PositiveInteger"/></summary>\n    /// </summary>\n    [return: NotNullIfNotNull(nameof(value))]\n    public static implicit operator PositiveInteger?(int? value) => value is null ? null : new(value.Value);\n\n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "PositiveInteger"/> to <see cref = "int"/></summary>\n    /// </summary>\n    public static implicit operator int(PositiveInteger value) => (int)value._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static PositiveInteger operator +(PositiveInteger left, PositiveInteger right) => new(left._valueOrDefault + right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static PositiveInteger operator -(PositiveInteger left, PositiveInteger right) => new(left._valueOrDefault - right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static PositiveInteger operator *(PositiveInteger left, PositiveInteger right) => new(left._valueOrDefault * right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static PositiveInteger operator /(PositiveInteger left, PositiveInteger right) => new(left._valueOrDefault / right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static PositiveInteger operator %(PositiveInteger left, PositiveInteger right) => new(left._valueOrDefault % right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public int CompareTo(object? value)\n    {\n        if (value is null)\n            return 1;\n\n        if (value is PositiveInteger c)\n            return CompareTo(c);\n\n        throw new ArgumentException("Object is not a PositiveInteger", nameof(value));\n    }\n\n    /// <inheritdoc/>\n    public int CompareTo(PositiveInteger other) => _valueOrDefault.CompareTo(other._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static bool operator <(PositiveInteger left, PositiveInteger right) => left._valueOrDefault < right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator <=(PositiveInteger left, PositiveInteger right) => left._valueOrDefault <= right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator >(PositiveInteger left, PositiveInteger right) => left._valueOrDefault > right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator >=(PositiveInteger left, PositiveInteger right) => left._valueOrDefault >= right._valueOrDefault;\n\n\n    /// <inheritdoc/>\n    public static PositiveInteger Parse(string s, IFormatProvider? provider) => int.Parse(s, provider);\n\n    /// <inheritdoc/>\n    public static bool TryParse(string? s, IFormatProvider? provider, out PositiveInteger result)\n    {\n        if (int.TryParse(s, provider, out var value))\n        {\n            result = new PositiveInteger(value);\n            return true;\n        }\n        result = default;\n        return false;\n    }\n\n    /// <inheritdoc/>\n    public override string ToString() => _valueOrDefault.ToString();\n\n    /// <inheritdoc/>\n    TypeCode IConvertible.GetTypeCode() => ((IConvertible)_valueOrDefault).GetTypeCode();\n\n    /// <inheritdoc/>\n    bool IConvertible.ToBoolean(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToBoolean(provider);\n\n    /// <inheritdoc/>\n    byte IConvertible.ToByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToByte(provider);\n\n    /// <inheritdoc/>\n    char IConvertible.ToChar(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToChar(provider);\n\n    /// <inheritdoc/>\n    DateTime IConvertible.ToDateTime(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDateTime(provider);\n\n    /// <inheritdoc/>\n    decimal IConvertible.ToDecimal(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDecimal(provider);\n\n    /// <inheritdoc/>\n    double IConvertible.ToDouble(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDouble(provider);\n\n    /// <inheritdoc/>\n    short IConvertible.ToInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt16(provider);\n\n    /// <inheritdoc/>\n    int IConvertible.ToInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt32(provider);\n\n    /// <inheritdoc/>\n    long IConvertible.ToInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt64(provider);\n\n    /// <inheritdoc/>\n    sbyte IConvertible.ToSByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSByte(provider);\n\n    /// <inheritdoc/>\n    float IConvertible.ToSingle(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSingle(provider);\n\n    /// <inheritdoc/>\n    string IConvertible.ToString(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToString(provider);\n\n    /// <inheritdoc/>\n    object IConvertible.ToType(Type conversionType, IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToType(conversionType, provider);\n\n    /// <inheritdoc/>\n    ushort IConvertible.ToUInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt16(provider);\n\n    /// <inheritdoc/>\n    uint IConvertible.ToUInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt32(provider);\n\n    /// <inheritdoc/>\n    ulong IConvertible.ToUInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt64(provider);\n}\n')),(0,r.kt)("h2",{parentName:"admonition",id:"jsonconverter"},(0,r.kt)("strong",{parentName:"h2"},"JsonConverter")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing AltaSoft.DomainPrimitives;\nusing System;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Globalization;\nusing System.Text.Json.Serialization.Metadata;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace AltaSoft.DomainPrimitives.Converters;\n\n/// <summary>\n/// JsonConverter for <see cref = "PositiveInteger"/>\n/// </summary>\npublic sealed class PositiveIntegerJsonConverter : JsonConverter<PositiveInteger>\n{\n    /// <inheritdoc/>\n    public override PositiveInteger Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        try\n        {\n            return JsonInternalConverters.Int32Converter.Read(ref reader, typeToConvert, options);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new JsonException(ex.Message);\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void Write(Utf8JsonWriter writer, PositiveInteger value, JsonSerializerOptions options)\n    {\n        JsonInternalConverters.Int32Converter.Write(writer, (int)value, options);\n    }\n\n    /// <inheritdoc/>\n    public override PositiveInteger ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        try\n        {\n            return JsonInternalConverters.Int32Converter.ReadAsPropertyName(ref reader, typeToConvert, options);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new JsonException(ex.Message);\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void WriteAsPropertyName(Utf8JsonWriter writer, PositiveInteger value, JsonSerializerOptions options)\n    {\n        JsonInternalConverters.Int32Converter.WriteAsPropertyName(writer, (int)value, options);\n    }\n}\n\n')),(0,r.kt)("h2",{parentName:"admonition",id:"type-converter"},(0,r.kt)("strong",{parentName:"h2"},"Type Converter")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing AltaSoft.DomainPrimitives;\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace AltaSoft.DomainPrimitives.Converters;\n\n/// <summary>\n/// TypeConverter for <see cref = "PositiveInteger"/>\n/// </summary>\npublic sealed class PositiveIntegerTypeConverter : Int32Converter\n{\n    /// <inheritdoc/>\n    public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)\n    {\n        var result = base.ConvertFrom(context, culture, value);\n        if (result is null)\n            return null;\n        try\n        {\n            return new PositiveInteger((int)result);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new FormatException("Cannot parse PositiveInteger", ex);\n        }\n    }\n}\n')),(0,r.kt)("h2",{parentName:"admonition",id:"swagger-mappers"},(0,r.kt)("strong",{parentName:"h2"},"Swagger Mappers")),(0,r.kt)("p",{parentName:"admonition"},"A single file for all domainPrimitives containing all type mappings is generated. "),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing AltaSoft.DomainPrimitives;\nusing Microsoft.Extensions.DependencyInjection;\nusing Swashbuckle.AspNetCore.SwaggerGen;\nusing Microsoft.OpenApi.Models;\n\nnamespace AltaSoft.DomainPrimitives.Converters.Extensions;\n\n/// <summary>\n/// Helper class providing methods to configure Swagger mappings for DomainPrimitive types of AltaSoft.DomainPrimitives\n/// </summary>\npublic static class SwaggerTypeHelper\n{\n    /// <summary>\n    /// Adds Swagger mappings for specific custom types to ensure proper OpenAPI documentation generation.\n    /// </summary>\n    /// <param name="options">The SwaggerGenOptions instance to which mappings are added..</param>\n    /// <remarks>\n    /// The method adds Swagger mappings for the following types:\n    /// <see cref="PositiveInteger"/>\n    /// </remarks>\n    public static void AddSwaggerMappings(this SwaggerGenOptions options)\n    {\n        options.MapType<PositiveInteger>(() => new OpenApiSchema { Type = "integer", Format = "Int32" });\n        options.MapType<PositiveInteger?>(() => new OpenApiSchema { Type = "integer", Format = "Int32" });\n    }\n}\n')),(0,r.kt)("h2",{parentName:"admonition",id:"specialized-tostring-method"},"Specialized ToString method"),(0,r.kt)("p",{parentName:"admonition"},"By Default IDomainValue uses its underlying type's ToString method however this can be overriden by implementing a method specified below"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"static virtual string ToString(T value) => value.ToString() ?? string.Empty;\n")),(0,r.kt)("h2",{parentName:"admonition",id:"managing-generated-operators-for-numeric-types"},"Managing Generated Operators for numeric types"),(0,r.kt)("p",{parentName:"admonition"},"Mathematical operators for particular numeric types can be customized using the ",(0,r.kt)("inlineCode",{parentName:"p"},"SupportedOperationsAttribute"),". If left unspecified, all operators are generated by default (as shown below). Once this attribute is applied, manual specification of the operators becomes mandatory. Note that for ",(0,r.kt)("inlineCode",{parentName:"p"},"byte"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"sbyte"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"short"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"ushort")," types, mathematical operators will not be generated by default."),(0,r.kt)("h3",{parentName:"admonition",id:"default-numeric-types-generated-operators"},"Default numeric types Generated Operators"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"byte, sbyte")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"None")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"short, ushort")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"None")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"int, uint")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"+ - / * %")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"long, ulong")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"+ - / * %")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"double")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"+ - / * %")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"decimal")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"+ - / * %"))),(0,r.kt)("h3",{parentName:"admonition",id:"using-supportedoperationsattribute"},"using ",(0,r.kt)("inlineCode",{parentName:"h3"},"SupportedOperationsAttribute")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[SupportedOperations(Addition = false,Division = false,Modulus = false,Multiplication = true,Subtraction = true)]\npublic readonly partial record struct PositiveInteger : IDomainValue<int>\n{\n    public static void Validate(int value)\n    {\n        if (value <= 0)\n            throw new InvalidDomainValueException("Number must be positive");\n    }\n    public static int Default => 1;\n}\n')),(0,r.kt)("h3",{parentName:"admonition",id:"for-further-customization-of-the-operators-consider-implementing-specific-interfaces-this-action-will-override-the-generated-operators-for-the-respective-domain-type"},"For further customization of the operators, consider implementing specific interfaces. This action will override the generated operators for the respective domain type:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public readonly partial record struct PositiveInteger :\n    IDomainValue<int>,\n    IAdditionOperators<PositiveInteger, PositiveInteger, PositiveInteger>\n{\n    public static void Validate(int value)\n    {\n        if (value <= 0)\n            throw new InvalidDomainValueException("Number must be positive");\n    }\n    public static int Default => 1;\n    //custom + operator\n    public static PositiveInteger operator +(PositiveInteger left, PositiveInteger right)\n    {\n        return (left._value + right._value + 1);\n    }\n}\n')),(0,r.kt)("h2",{parentName:"admonition",id:"managing-serialization-format-for-date-related-types"},"Managing Serialization Format for date-related types"),(0,r.kt)("p",{parentName:"admonition"},"Certain date-related types like ",(0,r.kt)("inlineCode",{parentName:"p"},"DateTime"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"DateOnly"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"TimeOnly"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"DateTimeOffset"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"TimeSpan")," can modify their serialization/deserialization format using the ",(0,r.kt)("inlineCode",{parentName:"p"},"SerializationFormatAttribute"),".\nFor instance, consider the ",(0,r.kt)("inlineCode",{parentName:"p"},"GDay")," type, which represents an XML gDay value. It implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"IDomainValue<DateOnly>")," interface and utilizes the ",(0,r.kt)("inlineCode",{parentName:"p"},"SerializationFormatAttribute")," to specify a serialization format."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'\n/// <summary>\n/// Represents an XML gDay value object, providing operations for parsing and handling gDay values.\n/// </summary>\n[SerializationFormat("dd")]\npublic readonly partial record struct GDay : IDomainValue<DateOnly>\n{\n    /// <inheritdoc/>\n    public static void Validate(DateOnly value)\n    { }\n\n    /// <inheritdoc/>\n    public static DateOnly Default => default;\n\n    /// <inheritdoc/>\n    // Customized string representation of DateOnly\n    public static string ToString(DateOnly value) => value.ToString("dd");\n}\n')),(0,r.kt)("h1",{parentName:"admonition",id:"disable-generation-of-converters"},"Disable Generation of Converters"),(0,r.kt)("p",{parentName:"admonition"},"To disable the generation of Converters or Swagger Mappers in csproj file follow the below described steps.However,please note that if Swagger is ",(0,r.kt)("strong",{parentName:"p"},"enabled")," then you'll need to add reference to the  ",(0,r.kt)("strong",{parentName:"p"},"Swashbuckle.AspNetCore.SwaggerGen")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'  <PropertyGroup>\n    <DomainPrimitiveGenerator_GenerateJsonConverters>false</DomainPrimitiveGenerator_GenerateJsonConverters>\n    <DomainPrimitiveGenerator_GenerateTypeConverters>false</DomainPrimitiveGenerator_GenerateTypeConverters>\n    <DomainPrimitiveGenerator_GenerateSwaggerConverters>false</DomainPrimitiveGenerator_GenerateSwaggerConverters>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateJsonConverters" />\n    <CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateTypeConverters" />\n    <CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateSwaggerConverters" />\n  </ItemGroup>\n')),(0,r.kt)("h1",{parentName:"admonition",id:"additional-features"},"Additional Features"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Handling Domain Value Exception")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"To ensure correct error handling, it's recommended to throw ",(0,r.kt)("inlineCode",{parentName:"li"},"InvalidDomainValueException")," or (descendants of ",(0,r.kt)("inlineCode",{parentName:"li"},"InvalidDomainValueException"),") provided in ",(0,r.kt)("inlineCode",{parentName:"li"},"AltaSoft.DomainPrimitives.Abstractions"),". This exception, when thrown from ",(0,r.kt)("inlineCode",{parentName:"li"},"JsonConverter")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"TypeConverter"),", will  be converted to ",(0,r.kt)("inlineCode",{parentName:"li"},"BadRequest"),". Using any other exception in the ",(0,r.kt)("inlineCode",{parentName:"li"},"Validate")," method will prompt a compiler warning."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Chaining Primitive Types")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Chaining of primitive types is possible. For instance, considering the ",(0,r.kt)("inlineCode",{parentName:"li"},"PositiveInteger")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"BetweenOneAnd100")," DomainPrimitives:")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public readonly partial record struct PositiveInteger : IDomainValue<int>\n    {\n        public static void Validate(int value)\n        {\n            if (value <= 0)\n                throw new InvalidDomainValueException("Number must be positive");\n        }\n        public static int Default => 1;\n    }\n\npublic readonly partial record struct BetweenOneAnd100 : IDomainValue<PositiveInteger>\n{\n    public static void Validate(PositiveInteger value)\n    {\n            if (value < 100)\n                throw new InvalidDomainValueException("Value must be less than 100");\n    }\n    public static PositiveInteger Default => 1; // using implicit operators this is possible.\n}\n')),(0,r.kt)("p",{parentName:"li"},"Defined type ",(0,r.kt)("inlineCode",{parentName:"p"},"BetweenOneAnd100"),"  automatically inherits restrictions from PositiveInteger. Operators restricted in PositiveInteger are also inherited. Further restrictions on operators can be added using the ",(0,r.kt)("inlineCode",{parentName:"p"},"SupportedOperationsAttribute"),":\t"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[SupportedOperations(Addition=false)]\npublic readonly partial record struct BetweenOneAnd100 : IDomainValue<PositiveInteger>\n    {\n        public static void Validate(PositiveInteger value)\n        {\n                if (value < 100)\n                    throw new InvalidDomainValueException("Value must be less than 100");\n        }\n        public static PositiveInteger Default => 1; // using implicit operators this is possible.\n    }\n')))),(0,r.kt)("ol",{parentName:"admonition",start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Default Value Guarantee with IDomainValue of T")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"* `IDomainValue<T>` incorporates a static abstract property Default to ensure the correct domain state if a value is uninitialized. For example:\n```csharp\npublic class TestObject\n{\n    public PositiveInteger CustomerId { get; set; }\n}\n\npublic class Program\n{\n    var test = new TestObject();\n    Console.Write(test); // If no Default was defined, CustomerId would default to 0, providing invalid value in the Domain. Providing a Default value ensures initialization according to validation rules by initializing in this example to 1 .\n}\n```\n")),(0,r.kt)("p",{parentName:"li"},"These additional features offer enhanced control over exceptions, chaining of primitive types, inheritance of restrictions and operators, and a mechanism to ensure correct default values within the domain."))),(0,r.kt)("h1",{parentName:"admonition",id:"restrictions"},"Restrictions"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Implementation of IDomainValue Interface")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"DomainPrimitives are mandated to implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"IDomainValue<T>")," interface to ensure adherence to domain-specific constraints and behaviors."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Constructor Limitation")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"No constructors should be explicitly defined within DomainPrimitives. Doing so will result in a compiler error."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Prohibition of Public Properties or Fields")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"DomainPrimitive types should not contain any explicitly defined public properties or fields. The backing field will be automatically generated.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If any property or field is explicitly named ",(0,r.kt)("inlineCode",{parentName:"li"},"_value"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"_valueOrDefault"),", or ",(0,r.kt)("inlineCode",{parentName:"li"},"_isInitialized"),", a compiler error will be triggered.")))))),(0,r.kt)("h1",{parentName:"admonition",id:"examples"},"Examples"),(0,r.kt)("h2",{parentName:"admonition",id:"implicit-usage-of-domaintype"},"Implicit Usage of DomainType"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public readonly partial record struct PositiveAmount : IDomainValue<decimal>\n{\n    public static void Validate(decimal value)\n    {\n        if (value <= 0m)\n            throw new InvalidDomainValueException("Must be a a positive number");\n    }\n\n    public static decimal Default => 1m;\n}\n\npublic static class Example\n{\n    public static void ImplicitConversion()\n    {\n        var amount = new PositiveAmount(100m);\n        PositiveAmount amount2 = 100m; // implicitly converted to PositiveAmount\n\n        //implicilty casted to decimal\n        decimal amountInDecimal = amount + amount2;        \n    }\n}\n\n')),(0,r.kt)("h1",{parentName:"admonition",id:"json-conversion"},"Json Conversion"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[SupportedOperations] // no mathematical operators should be generated\npublic readonly partial record struct CustomerId : IDomainValue<int>\n{\n    public static void Validate(int value)\n    {\n        if (value <= 0)\n            throw new InvalidDomainValueException("Value must be a positive number");\n    }\n\n    public static int Default => 1;\n}\n\npublic sealed class Transaction\n{\n    public CustomerId FromId { get; set; }\n    public CustomerId? ToId { get; set; }\n    public PositiveAmount Amount { get; set; }\n    public PositiveAmount? Fees { get; set; }\n}\n\npublic static void JsonSerializationAndDeserialization()\n{\n    var amount = new Transaction()\n        {\n            Amount = 100.523m,\n            Fees = null,\n            FromId = 1,\n            ToId = null\n        };\n\n    var jsonValue = JsonSerializer.Serialize(amount); //this will produce the same result as changing customerId to int and PositiveAmount to decimal\n    var newValue = JsonSerializer.Deserialize<Transaction>(jsonValue)\n}\n')),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"Serialized Json")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "FromId": 1,\n    "ToId": null,\n    "Amount": 100.523,\n    "Fees": null\n}\n')),(0,r.kt)("h1",{parentName:"admonition",id:"contributions"},"Contributions"),(0,r.kt)("p",{parentName:"admonition"},"Contributions to AltaSoft.DomainPrimitives are welcome! Whether you have suggestions or wish to contribute code, feel free to submit a pull request or open an issue."),(0,r.kt)("h1",{parentName:"admonition",id:"contact"},"Contact"),(0,r.kt)("p",{parentName:"admonition"},"For support, questions, or additional information, please visit GitHub Issues."),(0,r.kt)("h1",{parentName:"admonition",id:"license"},"License"),(0,r.kt)("p",{parentName:"admonition"},"This project is licensed under ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/altasoft/DomainPrimitives/LICENSE.TXT"},"MIT"),". See the LICENSE file for details.")),(0,r.kt)("h3",{id:"about"},"About"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"One of the most complete and mature libraries for DomainPrimitives in  .NET")),(0,r.kt)("h2",{id:"how-to-use"},"How to use"),(0,r.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,r.kt)(a.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,r.kt)("p",null,"This is the CSharp Project that references ",(0,r.kt)("strong",{parentName:"p"},"DomainPrimitives")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {12}",showLineNumbers:!0,"{12}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n    <PropertyGroup>\n        <OutputType>Exe</OutputType>\n        <TargetFramework>net8.0</TargetFramework>\n        <ImplicitUsings>enable</ImplicitUsings>\n        <Nullable>enable</Nullable>\n    </PropertyGroup>\n\n    <ItemGroup>\n        <PackageReference Include="AltaSoft.DomainPrimitives.Abstractions" Version="1.0.3" />\n        <PackageReference Include="AltaSoft.DomainPrimitives.Generator" Version="1.0.3" OutputItemType="Analyzer" ReferenceOutputAssembly="false" PrivateAssets="all" ExcludeAssets="runtime" />\n    </ItemGroup>\n    <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n\n    <PropertyGroup>\n        \x3c!--<DomainPrimitiveGenerator_GenerateJsonConverters>false</DomainPrimitiveGenerator_GenerateJsonConverters>--\x3e\n        \x3c!--<DomainPrimitiveGenerator_GenerateTypeConverters>false</DomainPrimitiveGenerator_GenerateTypeConverters>--\x3e\n        <DomainPrimitiveGenerator_GenerateSwaggerConverters>false</DomainPrimitiveGenerator_GenerateSwaggerConverters>\n    </PropertyGroup>\n    <ItemGroup>\n        \x3c!--<CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateTypeConverters" />--\x3e\n        \x3c!--<CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateJsonConverters" />--\x3e\n        <CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateSwaggerConverters" />\n    </ItemGroup>\n\n</Project>\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"DomainPrimitives")," in ",(0,r.kt)("em",{parentName:"p"},"Program.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// See https://aka.ms/new-console-template for more information\nusing DomainPrimitives;\n\nvar year = new YearDate(1970);\nvar month = new MonthDate(4);\nvar day = new DayDate(16);\nyear += 1;\nvar p=new Person(year,month,day);\n\nConsole.WriteLine(p.DOB);\n"))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\DOB.cs",label:"DOB.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"DomainPrimitives")," in ",(0,r.kt)("em",{parentName:"p"},"DOB.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives;\n\npublic readonly partial record struct YearDate : IDomainValue<int>\n{\n    public static void Validate(int value)\n    {\n        if (value <= 0)\n            throw new InvalidDomainValueException("year must be positive");\n    }\n    public static int Default => 1;\n}\npublic readonly partial record struct MonthDate : IDomainValue<int>\n{\n    public static void Validate(int value)\n    {\n        if (value <= 0)\n            throw new InvalidDomainValueException("year must be positive");\n    }\n    public static int Default => 1;\n}\n\npublic readonly partial record struct DayDate : IDomainValue<int>\n{\n    public static void Validate(int value)\n    {\n        if (value <= 0)\n            throw new InvalidDomainValueException("year must be positive");\n    }\n    public static int Default => 1;\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\TaskAfterDelay.cs",label:"TaskAfterDelay.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"DomainPrimitives")," in ",(0,r.kt)("em",{parentName:"p"},"TaskAfterDelay.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"namespace DomainPrimitives;\ninternal class Person\n{\n    public Person(YearDate year,MonthDate month,DayDate day)\n    {\n        DOB = new DateOnly(year,month,day);\n    }\n    public DateOnly DOB { get; private set; }\n\n    \n}\n\n")))),(0,r.kt)("h3",{id:"generated-files"},"Generated Files"),(0,r.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,r.kt)(a.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\DayDate.g.cs",label:"DayDate.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Text.Json.Serialization;\nusing DomainPrimitives.Converters;\nusing System.ComponentModel;\n\nnamespace DomainPrimitives;\n\n[JsonConverter(typeof(DayDateJsonConverter))]\n[TypeConverter(typeof(DayDateTypeConverter))]\n[DebuggerDisplay("{_valueOrDefault}")]\npublic readonly partial record struct DayDate :\n        IAdditionOperators<DayDate, DayDate, DayDate>,\n        ISubtractionOperators<DayDate, DayDate, DayDate>,\n        IMultiplyOperators<DayDate, DayDate, DayDate>,\n        IDivisionOperators<DayDate, DayDate, DayDate>,\n        IModulusOperators<DayDate, DayDate, DayDate>,\n        IComparisonOperators<DayDate, DayDate, bool>,\n        IComparable,\n        IComparable<DayDate>,\n        IParsable<DayDate>,\n        IConvertible\n{\n    private int _valueOrDefault => _isInitialized ? _value : Default;\n    [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n    private readonly int _value;\n    [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n    private readonly bool _isInitialized;\n    \n    /// <summary>\n    /// Initializes a new instance of the <see cref="DayDate"/> class by validating the specified <see cref="int"/> value using <see cref="Validate"/> static method.\n    /// </summary>\n    /// <param name="value">The value to be validated..</param>\n    public DayDate(int value)\n    {\n            Validate(value);\n            _value = value;\n            _isInitialized = true;\n    }\n    \n    [Obsolete("Domain primitive cannot be created using empty Ctor", true)]\n    public DayDate() : this(Default)\n    {\n    }\n    \n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "DayDate"/></summary>\n    /// </summary>\n    public static implicit operator DayDate(int value) => new(value);\n\n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "int?"/> to <see cref = "DayDate?"/></summary>\n    /// </summary>\n    [return: NotNullIfNotNull(nameof(value))]\n    public static implicit operator DayDate?(int? value) => value is null ? null : new(value.Value);\n\n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "DayDate"/> to <see cref = "int"/></summary>\n    /// </summary>\n    public static implicit operator int(DayDate value) => (int)value._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static DayDate operator +(DayDate left, DayDate right) => new(left._valueOrDefault + right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static DayDate operator -(DayDate left, DayDate right) => new(left._valueOrDefault - right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static DayDate operator *(DayDate left, DayDate right) => new(left._valueOrDefault * right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static DayDate operator /(DayDate left, DayDate right) => new(left._valueOrDefault / right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static DayDate operator %(DayDate left, DayDate right) => new(left._valueOrDefault % right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public int CompareTo(object? value)\n    {\n        if (value is null)\n            return 1;\n\n        if (value is DayDate c)\n            return CompareTo(c);\n\n        throw new ArgumentException("Object is not a DayDate", nameof(value));\n    }\n\n    /// <inheritdoc/>\n    public int CompareTo(DayDate other) => _valueOrDefault.CompareTo(other._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static bool operator <(DayDate left, DayDate right) => left._valueOrDefault < right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator <=(DayDate left, DayDate right) => left._valueOrDefault <= right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator >(DayDate left, DayDate right) => left._valueOrDefault > right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator >=(DayDate left, DayDate right) => left._valueOrDefault >= right._valueOrDefault;\n\n\n    /// <inheritdoc/>\n    public static DayDate Parse(string s, IFormatProvider? provider) => int.Parse(s, provider);\n\n    /// <inheritdoc/>\n    public static bool TryParse(string? s, IFormatProvider? provider, out DayDate result)\n    {\n        if (int.TryParse(s, provider, out var value))\n        {\n            result = new DayDate(value);\n            return true;\n        }\n        result = default;\n        return false;\n    }\n\n\n    /// <inheritdoc/>\n    public override string ToString() => _valueOrDefault.ToString();\n\n    /// <inheritdoc/>\n    TypeCode IConvertible.GetTypeCode() => ((IConvertible)_valueOrDefault).GetTypeCode();\n\n    /// <inheritdoc/>\n    bool IConvertible.ToBoolean(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToBoolean(provider);\n\n    /// <inheritdoc/>\n    byte IConvertible.ToByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToByte(provider);\n\n    /// <inheritdoc/>\n    char IConvertible.ToChar(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToChar(provider);\n\n    /// <inheritdoc/>\n    DateTime IConvertible.ToDateTime(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDateTime(provider);\n\n    /// <inheritdoc/>\n    decimal IConvertible.ToDecimal(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDecimal(provider);\n\n    /// <inheritdoc/>\n    double IConvertible.ToDouble(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDouble(provider);\n\n    /// <inheritdoc/>\n    short IConvertible.ToInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt16(provider);\n\n    /// <inheritdoc/>\n    int IConvertible.ToInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt32(provider);\n\n    /// <inheritdoc/>\n    long IConvertible.ToInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt64(provider);\n\n    /// <inheritdoc/>\n    sbyte IConvertible.ToSByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSByte(provider);\n\n    /// <inheritdoc/>\n    float IConvertible.ToSingle(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSingle(provider);\n\n    /// <inheritdoc/>\n    string IConvertible.ToString(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToString(provider);\n\n    /// <inheritdoc/>\n    object IConvertible.ToType(Type conversionType, IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToType(conversionType, provider);\n\n    /// <inheritdoc/>\n    ushort IConvertible.ToUInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt16(provider);\n\n    /// <inheritdoc/>\n    uint IConvertible.ToUInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt32(provider);\n\n    /// <inheritdoc/>\n    ulong IConvertible.ToUInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt64(provider);\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\DayDateJsonConverter.g.cs",label:"DayDateJsonConverter.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Globalization;\nusing System.Text.Json.Serialization.Metadata;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// JsonConverter for <see cref = "DayDate"/>\n/// </summary>\npublic sealed class DayDateJsonConverter : JsonConverter<DayDate>\n{\n    /// <inheritdoc/>\n    public override DayDate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        try\n        {\n            return JsonInternalConverters.Int32Converter.Read(ref reader, typeToConvert, options);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new JsonException(ex.Message);\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void Write(Utf8JsonWriter writer, DayDate value, JsonSerializerOptions options)\n    {\n        JsonInternalConverters.Int32Converter.Write(writer, (int)value, options);\n    }\n\n    /// <inheritdoc/>\n    public override DayDate ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        try\n        {\n            return JsonInternalConverters.Int32Converter.ReadAsPropertyName(ref reader, typeToConvert, options);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new JsonException(ex.Message);\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void WriteAsPropertyName(Utf8JsonWriter writer, DayDate value, JsonSerializerOptions options)\n    {\n        JsonInternalConverters.Int32Converter.WriteAsPropertyName(writer, (int)value, options);\n    }\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\DayDateTypeConverter.g.cs",label:"DayDateTypeConverter.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// TypeConverter for <see cref = "DayDate"/>\n/// </summary>\npublic sealed class DayDateTypeConverter : Int32Converter\n{\n    /// <inheritdoc/>\n    public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)\n    {\n        var result = base.ConvertFrom(context, culture, value);\n        if (result is null)\n            return null;\n        try\n        {\n            return new DayDate((int)result);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new FormatException("Cannot parse DayDate", ex);\n        }\n    }\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\MinutesInteger.g.cs",label:"MinutesInteger.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Text.Json.Serialization;\nusing DomainPrimitives.Converters;\nusing System.ComponentModel;\n\nnamespace DomainPrimitives;\n\n[JsonConverter(typeof(MinutesIntegerJsonConverter))]\n[TypeConverter(typeof(MinutesIntegerTypeConverter))]\n[DebuggerDisplay("{_valueOrDefault}")]\npublic readonly partial record struct MinutesInteger :\n        IAdditionOperators<MinutesInteger, MinutesInteger, MinutesInteger>,\n        ISubtractionOperators<MinutesInteger, MinutesInteger, MinutesInteger>,\n        IMultiplyOperators<MinutesInteger, MinutesInteger, MinutesInteger>,\n        IDivisionOperators<MinutesInteger, MinutesInteger, MinutesInteger>,\n        IModulusOperators<MinutesInteger, MinutesInteger, MinutesInteger>,\n        IComparisonOperators<MinutesInteger, MinutesInteger, bool>,\n        IComparable,\n        IComparable<MinutesInteger>,\n        IParsable<MinutesInteger>,\n        IConvertible\n{\n    private int _valueOrDefault => _isInitialized ? _value : Default;\n    [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n    private readonly int _value;\n    [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n    private readonly bool _isInitialized;\n    \n    /// <summary>\n    /// Initializes a new instance of the <see cref="MinutesInteger"/> class by validating the specified <see cref="int"/> value using <see cref="Validate"/> static method.\n    /// </summary>\n    /// <param name="value">The value to be validated..</param>\n    public MinutesInteger(int value)\n    {\n            Validate(value);\n            _value = value;\n            _isInitialized = true;\n    }\n    \n    [Obsolete("Domain primitive cannot be created using empty Ctor", true)]\n    public MinutesInteger() : this(Default)\n    {\n    }\n    \n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "MinutesInteger"/></summary>\n    /// </summary>\n    public static implicit operator MinutesInteger(int value) => new(value);\n\n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "int?"/> to <see cref = "MinutesInteger?"/></summary>\n    /// </summary>\n    [return: NotNullIfNotNull(nameof(value))]\n    public static implicit operator MinutesInteger?(int? value) => value is null ? null : new(value.Value);\n\n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "MinutesInteger"/> to <see cref = "int"/></summary>\n    /// </summary>\n    public static implicit operator int(MinutesInteger value) => (int)value._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static MinutesInteger operator +(MinutesInteger left, MinutesInteger right) => new(left._valueOrDefault + right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static MinutesInteger operator -(MinutesInteger left, MinutesInteger right) => new(left._valueOrDefault - right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static MinutesInteger operator *(MinutesInteger left, MinutesInteger right) => new(left._valueOrDefault * right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static MinutesInteger operator /(MinutesInteger left, MinutesInteger right) => new(left._valueOrDefault / right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static MinutesInteger operator %(MinutesInteger left, MinutesInteger right) => new(left._valueOrDefault % right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public int CompareTo(object? value)\n    {\n        if (value is null)\n            return 1;\n\n        if (value is MinutesInteger c)\n            return CompareTo(c);\n\n        throw new ArgumentException("Object is not a MinutesInteger", nameof(value));\n    }\n\n    /// <inheritdoc/>\n    public int CompareTo(MinutesInteger other) => _valueOrDefault.CompareTo(other._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static bool operator <(MinutesInteger left, MinutesInteger right) => left._valueOrDefault < right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator <=(MinutesInteger left, MinutesInteger right) => left._valueOrDefault <= right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator >(MinutesInteger left, MinutesInteger right) => left._valueOrDefault > right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator >=(MinutesInteger left, MinutesInteger right) => left._valueOrDefault >= right._valueOrDefault;\n\n\n    /// <inheritdoc/>\n    public static MinutesInteger Parse(string s, IFormatProvider? provider) => int.Parse(s, provider);\n\n    /// <inheritdoc/>\n    public static bool TryParse(string? s, IFormatProvider? provider, out MinutesInteger result)\n    {\n        if (int.TryParse(s, provider, out var value))\n        {\n            result = new MinutesInteger(value);\n            return true;\n        }\n        result = default;\n        return false;\n    }\n\n\n    /// <inheritdoc/>\n    public override string ToString() => _valueOrDefault.ToString();\n\n    /// <inheritdoc/>\n    TypeCode IConvertible.GetTypeCode() => ((IConvertible)_valueOrDefault).GetTypeCode();\n\n    /// <inheritdoc/>\n    bool IConvertible.ToBoolean(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToBoolean(provider);\n\n    /// <inheritdoc/>\n    byte IConvertible.ToByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToByte(provider);\n\n    /// <inheritdoc/>\n    char IConvertible.ToChar(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToChar(provider);\n\n    /// <inheritdoc/>\n    DateTime IConvertible.ToDateTime(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDateTime(provider);\n\n    /// <inheritdoc/>\n    decimal IConvertible.ToDecimal(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDecimal(provider);\n\n    /// <inheritdoc/>\n    double IConvertible.ToDouble(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDouble(provider);\n\n    /// <inheritdoc/>\n    short IConvertible.ToInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt16(provider);\n\n    /// <inheritdoc/>\n    int IConvertible.ToInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt32(provider);\n\n    /// <inheritdoc/>\n    long IConvertible.ToInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt64(provider);\n\n    /// <inheritdoc/>\n    sbyte IConvertible.ToSByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSByte(provider);\n\n    /// <inheritdoc/>\n    float IConvertible.ToSingle(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSingle(provider);\n\n    /// <inheritdoc/>\n    string IConvertible.ToString(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToString(provider);\n\n    /// <inheritdoc/>\n    object IConvertible.ToType(Type conversionType, IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToType(conversionType, provider);\n\n    /// <inheritdoc/>\n    ushort IConvertible.ToUInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt16(provider);\n\n    /// <inheritdoc/>\n    uint IConvertible.ToUInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt32(provider);\n\n    /// <inheritdoc/>\n    ulong IConvertible.ToUInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt64(provider);\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\MinutesIntegerJsonConverter.g.cs",label:"MinutesIntegerJsonConverter.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Globalization;\nusing System.Text.Json.Serialization.Metadata;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// JsonConverter for <see cref = "MinutesInteger"/>\n/// </summary>\npublic sealed class MinutesIntegerJsonConverter : JsonConverter<MinutesInteger>\n{\n    /// <inheritdoc/>\n    public override MinutesInteger Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        try\n        {\n            return JsonInternalConverters.Int32Converter.Read(ref reader, typeToConvert, options);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new JsonException(ex.Message);\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void Write(Utf8JsonWriter writer, MinutesInteger value, JsonSerializerOptions options)\n    {\n        JsonInternalConverters.Int32Converter.Write(writer, (int)value, options);\n    }\n\n    /// <inheritdoc/>\n    public override MinutesInteger ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        try\n        {\n            return JsonInternalConverters.Int32Converter.ReadAsPropertyName(ref reader, typeToConvert, options);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new JsonException(ex.Message);\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void WriteAsPropertyName(Utf8JsonWriter writer, MinutesInteger value, JsonSerializerOptions options)\n    {\n        JsonInternalConverters.Int32Converter.WriteAsPropertyName(writer, (int)value, options);\n    }\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\MinutesIntegerTypeConverter.g.cs",label:"MinutesIntegerTypeConverter.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// TypeConverter for <see cref = "MinutesInteger"/>\n/// </summary>\npublic sealed class MinutesIntegerTypeConverter : Int32Converter\n{\n    /// <inheritdoc/>\n    public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)\n    {\n        var result = base.ConvertFrom(context, culture, value);\n        if (result is null)\n            return null;\n        try\n        {\n            return new MinutesInteger((int)result);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new FormatException("Cannot parse MinutesInteger", ex);\n        }\n    }\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\MonthDate.g.cs",label:"MonthDate.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Text.Json.Serialization;\nusing DomainPrimitives.Converters;\nusing System.ComponentModel;\n\nnamespace DomainPrimitives;\n\n[JsonConverter(typeof(MonthDateJsonConverter))]\n[TypeConverter(typeof(MonthDateTypeConverter))]\n[DebuggerDisplay("{_valueOrDefault}")]\npublic readonly partial record struct MonthDate :\n        IAdditionOperators<MonthDate, MonthDate, MonthDate>,\n        ISubtractionOperators<MonthDate, MonthDate, MonthDate>,\n        IMultiplyOperators<MonthDate, MonthDate, MonthDate>,\n        IDivisionOperators<MonthDate, MonthDate, MonthDate>,\n        IModulusOperators<MonthDate, MonthDate, MonthDate>,\n        IComparisonOperators<MonthDate, MonthDate, bool>,\n        IComparable,\n        IComparable<MonthDate>,\n        IParsable<MonthDate>,\n        IConvertible\n{\n    private int _valueOrDefault => _isInitialized ? _value : Default;\n    [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n    private readonly int _value;\n    [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n    private readonly bool _isInitialized;\n    \n    /// <summary>\n    /// Initializes a new instance of the <see cref="MonthDate"/> class by validating the specified <see cref="int"/> value using <see cref="Validate"/> static method.\n    /// </summary>\n    /// <param name="value">The value to be validated..</param>\n    public MonthDate(int value)\n    {\n            Validate(value);\n            _value = value;\n            _isInitialized = true;\n    }\n    \n    [Obsolete("Domain primitive cannot be created using empty Ctor", true)]\n    public MonthDate() : this(Default)\n    {\n    }\n    \n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "MonthDate"/></summary>\n    /// </summary>\n    public static implicit operator MonthDate(int value) => new(value);\n\n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "int?"/> to <see cref = "MonthDate?"/></summary>\n    /// </summary>\n    [return: NotNullIfNotNull(nameof(value))]\n    public static implicit operator MonthDate?(int? value) => value is null ? null : new(value.Value);\n\n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "MonthDate"/> to <see cref = "int"/></summary>\n    /// </summary>\n    public static implicit operator int(MonthDate value) => (int)value._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static MonthDate operator +(MonthDate left, MonthDate right) => new(left._valueOrDefault + right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static MonthDate operator -(MonthDate left, MonthDate right) => new(left._valueOrDefault - right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static MonthDate operator *(MonthDate left, MonthDate right) => new(left._valueOrDefault * right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static MonthDate operator /(MonthDate left, MonthDate right) => new(left._valueOrDefault / right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static MonthDate operator %(MonthDate left, MonthDate right) => new(left._valueOrDefault % right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public int CompareTo(object? value)\n    {\n        if (value is null)\n            return 1;\n\n        if (value is MonthDate c)\n            return CompareTo(c);\n\n        throw new ArgumentException("Object is not a MonthDate", nameof(value));\n    }\n\n    /// <inheritdoc/>\n    public int CompareTo(MonthDate other) => _valueOrDefault.CompareTo(other._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static bool operator <(MonthDate left, MonthDate right) => left._valueOrDefault < right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator <=(MonthDate left, MonthDate right) => left._valueOrDefault <= right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator >(MonthDate left, MonthDate right) => left._valueOrDefault > right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator >=(MonthDate left, MonthDate right) => left._valueOrDefault >= right._valueOrDefault;\n\n\n    /// <inheritdoc/>\n    public static MonthDate Parse(string s, IFormatProvider? provider) => int.Parse(s, provider);\n\n    /// <inheritdoc/>\n    public static bool TryParse(string? s, IFormatProvider? provider, out MonthDate result)\n    {\n        if (int.TryParse(s, provider, out var value))\n        {\n            result = new MonthDate(value);\n            return true;\n        }\n        result = default;\n        return false;\n    }\n\n\n    /// <inheritdoc/>\n    public override string ToString() => _valueOrDefault.ToString();\n\n    /// <inheritdoc/>\n    TypeCode IConvertible.GetTypeCode() => ((IConvertible)_valueOrDefault).GetTypeCode();\n\n    /// <inheritdoc/>\n    bool IConvertible.ToBoolean(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToBoolean(provider);\n\n    /// <inheritdoc/>\n    byte IConvertible.ToByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToByte(provider);\n\n    /// <inheritdoc/>\n    char IConvertible.ToChar(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToChar(provider);\n\n    /// <inheritdoc/>\n    DateTime IConvertible.ToDateTime(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDateTime(provider);\n\n    /// <inheritdoc/>\n    decimal IConvertible.ToDecimal(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDecimal(provider);\n\n    /// <inheritdoc/>\n    double IConvertible.ToDouble(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDouble(provider);\n\n    /// <inheritdoc/>\n    short IConvertible.ToInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt16(provider);\n\n    /// <inheritdoc/>\n    int IConvertible.ToInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt32(provider);\n\n    /// <inheritdoc/>\n    long IConvertible.ToInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt64(provider);\n\n    /// <inheritdoc/>\n    sbyte IConvertible.ToSByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSByte(provider);\n\n    /// <inheritdoc/>\n    float IConvertible.ToSingle(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSingle(provider);\n\n    /// <inheritdoc/>\n    string IConvertible.ToString(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToString(provider);\n\n    /// <inheritdoc/>\n    object IConvertible.ToType(Type conversionType, IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToType(conversionType, provider);\n\n    /// <inheritdoc/>\n    ushort IConvertible.ToUInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt16(provider);\n\n    /// <inheritdoc/>\n    uint IConvertible.ToUInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt32(provider);\n\n    /// <inheritdoc/>\n    ulong IConvertible.ToUInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt64(provider);\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\MonthDateJsonConverter.g.cs",label:"MonthDateJsonConverter.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Globalization;\nusing System.Text.Json.Serialization.Metadata;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// JsonConverter for <see cref = "MonthDate"/>\n/// </summary>\npublic sealed class MonthDateJsonConverter : JsonConverter<MonthDate>\n{\n    /// <inheritdoc/>\n    public override MonthDate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        try\n        {\n            return JsonInternalConverters.Int32Converter.Read(ref reader, typeToConvert, options);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new JsonException(ex.Message);\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void Write(Utf8JsonWriter writer, MonthDate value, JsonSerializerOptions options)\n    {\n        JsonInternalConverters.Int32Converter.Write(writer, (int)value, options);\n    }\n\n    /// <inheritdoc/>\n    public override MonthDate ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        try\n        {\n            return JsonInternalConverters.Int32Converter.ReadAsPropertyName(ref reader, typeToConvert, options);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new JsonException(ex.Message);\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void WriteAsPropertyName(Utf8JsonWriter writer, MonthDate value, JsonSerializerOptions options)\n    {\n        JsonInternalConverters.Int32Converter.WriteAsPropertyName(writer, (int)value, options);\n    }\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\MonthDateTypeConverter.g.cs",label:"MonthDateTypeConverter.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// TypeConverter for <see cref = "MonthDate"/>\n/// </summary>\npublic sealed class MonthDateTypeConverter : Int32Converter\n{\n    /// <inheritdoc/>\n    public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)\n    {\n        var result = base.ConvertFrom(context, culture, value);\n        if (result is null)\n            return null;\n        try\n        {\n            return new MonthDate((int)result);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new FormatException("Cannot parse MonthDate", ex);\n        }\n    }\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\YearDate.g.cs",label:"YearDate.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Text.Json.Serialization;\nusing DomainPrimitives.Converters;\nusing System.ComponentModel;\n\nnamespace DomainPrimitives;\n\n[JsonConverter(typeof(YearDateJsonConverter))]\n[TypeConverter(typeof(YearDateTypeConverter))]\n[DebuggerDisplay("{_valueOrDefault}")]\npublic readonly partial record struct YearDate :\n        IAdditionOperators<YearDate, YearDate, YearDate>,\n        ISubtractionOperators<YearDate, YearDate, YearDate>,\n        IMultiplyOperators<YearDate, YearDate, YearDate>,\n        IDivisionOperators<YearDate, YearDate, YearDate>,\n        IModulusOperators<YearDate, YearDate, YearDate>,\n        IComparisonOperators<YearDate, YearDate, bool>,\n        IComparable,\n        IComparable<YearDate>,\n        IParsable<YearDate>,\n        IConvertible\n{\n    private int _valueOrDefault => _isInitialized ? _value : Default;\n    [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n    private readonly int _value;\n    [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n    private readonly bool _isInitialized;\n    \n    /// <summary>\n    /// Initializes a new instance of the <see cref="YearDate"/> class by validating the specified <see cref="int"/> value using <see cref="Validate"/> static method.\n    /// </summary>\n    /// <param name="value">The value to be validated..</param>\n    public YearDate(int value)\n    {\n            Validate(value);\n            _value = value;\n            _isInitialized = true;\n    }\n    \n    [Obsolete("Domain primitive cannot be created using empty Ctor", true)]\n    public YearDate() : this(Default)\n    {\n    }\n    \n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "YearDate"/></summary>\n    /// </summary>\n    public static implicit operator YearDate(int value) => new(value);\n\n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "int?"/> to <see cref = "YearDate?"/></summary>\n    /// </summary>\n    [return: NotNullIfNotNull(nameof(value))]\n    public static implicit operator YearDate?(int? value) => value is null ? null : new(value.Value);\n\n    /// <summary>\n    /// <summary>Implicit conversion from <see cref = "YearDate"/> to <see cref = "int"/></summary>\n    /// </summary>\n    public static implicit operator int(YearDate value) => (int)value._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static YearDate operator +(YearDate left, YearDate right) => new(left._valueOrDefault + right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static YearDate operator -(YearDate left, YearDate right) => new(left._valueOrDefault - right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static YearDate operator *(YearDate left, YearDate right) => new(left._valueOrDefault * right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static YearDate operator /(YearDate left, YearDate right) => new(left._valueOrDefault / right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static YearDate operator %(YearDate left, YearDate right) => new(left._valueOrDefault % right._valueOrDefault);\n\n    /// <inheritdoc/>\n    public int CompareTo(object? value)\n    {\n        if (value is null)\n            return 1;\n\n        if (value is YearDate c)\n            return CompareTo(c);\n\n        throw new ArgumentException("Object is not a YearDate", nameof(value));\n    }\n\n    /// <inheritdoc/>\n    public int CompareTo(YearDate other) => _valueOrDefault.CompareTo(other._valueOrDefault);\n\n    /// <inheritdoc/>\n    public static bool operator <(YearDate left, YearDate right) => left._valueOrDefault < right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator <=(YearDate left, YearDate right) => left._valueOrDefault <= right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator >(YearDate left, YearDate right) => left._valueOrDefault > right._valueOrDefault;\n\n    /// <inheritdoc/>\n    public static bool operator >=(YearDate left, YearDate right) => left._valueOrDefault >= right._valueOrDefault;\n\n\n    /// <inheritdoc/>\n    public static YearDate Parse(string s, IFormatProvider? provider) => int.Parse(s, provider);\n\n    /// <inheritdoc/>\n    public static bool TryParse(string? s, IFormatProvider? provider, out YearDate result)\n    {\n        if (int.TryParse(s, provider, out var value))\n        {\n            result = new YearDate(value);\n            return true;\n        }\n        result = default;\n        return false;\n    }\n\n\n    /// <inheritdoc/>\n    public override string ToString() => _valueOrDefault.ToString();\n\n    /// <inheritdoc/>\n    TypeCode IConvertible.GetTypeCode() => ((IConvertible)_valueOrDefault).GetTypeCode();\n\n    /// <inheritdoc/>\n    bool IConvertible.ToBoolean(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToBoolean(provider);\n\n    /// <inheritdoc/>\n    byte IConvertible.ToByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToByte(provider);\n\n    /// <inheritdoc/>\n    char IConvertible.ToChar(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToChar(provider);\n\n    /// <inheritdoc/>\n    DateTime IConvertible.ToDateTime(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDateTime(provider);\n\n    /// <inheritdoc/>\n    decimal IConvertible.ToDecimal(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDecimal(provider);\n\n    /// <inheritdoc/>\n    double IConvertible.ToDouble(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDouble(provider);\n\n    /// <inheritdoc/>\n    short IConvertible.ToInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt16(provider);\n\n    /// <inheritdoc/>\n    int IConvertible.ToInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt32(provider);\n\n    /// <inheritdoc/>\n    long IConvertible.ToInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt64(provider);\n\n    /// <inheritdoc/>\n    sbyte IConvertible.ToSByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSByte(provider);\n\n    /// <inheritdoc/>\n    float IConvertible.ToSingle(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSingle(provider);\n\n    /// <inheritdoc/>\n    string IConvertible.ToString(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToString(provider);\n\n    /// <inheritdoc/>\n    object IConvertible.ToType(Type conversionType, IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToType(conversionType, provider);\n\n    /// <inheritdoc/>\n    ushort IConvertible.ToUInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt16(provider);\n\n    /// <inheritdoc/>\n    uint IConvertible.ToUInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt32(provider);\n\n    /// <inheritdoc/>\n    ulong IConvertible.ToUInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt64(provider);\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\YearDateJsonConverter.g.cs",label:"YearDateJsonConverter.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Globalization;\nusing System.Text.Json.Serialization.Metadata;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// JsonConverter for <see cref = "YearDate"/>\n/// </summary>\npublic sealed class YearDateJsonConverter : JsonConverter<YearDate>\n{\n    /// <inheritdoc/>\n    public override YearDate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        try\n        {\n            return JsonInternalConverters.Int32Converter.Read(ref reader, typeToConvert, options);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new JsonException(ex.Message);\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void Write(Utf8JsonWriter writer, YearDate value, JsonSerializerOptions options)\n    {\n        JsonInternalConverters.Int32Converter.Write(writer, (int)value, options);\n    }\n\n    /// <inheritdoc/>\n    public override YearDate ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        try\n        {\n            return JsonInternalConverters.Int32Converter.ReadAsPropertyName(ref reader, typeToConvert, options);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new JsonException(ex.Message);\n        }\n    }\n\n    /// <inheritdoc/>\n    public override void WriteAsPropertyName(Utf8JsonWriter writer, YearDate value, JsonSerializerOptions options)\n    {\n        JsonInternalConverters.Int32Converter.WriteAsPropertyName(writer, (int)value, options);\n    }\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\YearDateTypeConverter.g.cs",label:"YearDateTypeConverter.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// TypeConverter for <see cref = "YearDate"/>\n/// </summary>\npublic sealed class YearDateTypeConverter : Int32Converter\n{\n    /// <inheritdoc/>\n    public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)\n    {\n        var result = base.ConvertFrom(context, culture, value);\n        if (result is null)\n            return null;\n        try\n        {\n            return new YearDate((int)result);\n        }\n        catch (InvalidDomainValueException ex)\n        {\n            throw new FormatException("Cannot parse YearDate", ex);\n        }\n    }\n}\n\n')))),(0,r.kt)("h2",{id:"usefull"},"Usefull"),(0,r.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{target:"_blank",href:n(7983).Z},"Download Example project DomainPrimitives "))),(0,r.kt)("h3",{id:"share-domainprimitives"},"Share DomainPrimitives"),(0,r.kt)("ul",null,(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives&quote=DomainPrimitives",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives&text=DomainPrimitives:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives&title=DomainPrimitives",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives&title=DomainPrimitives&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/DomainPrimitives"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/DomainPrimitives")),(0,r.kt)("h3",{id:"in-the-same-category-primitiveobsession---3-other-generators"},"In the same category (PrimitiveObsession) - 3 other generators"),(0,r.kt)("h4",{id:"strongly"},(0,r.kt)("a",{parentName:"h4",href:"/docs/Strongly"},"Strongly")),(0,r.kt)("h4",{id:"unitgenerator"},(0,r.kt)("a",{parentName:"h4",href:"/docs/UnitGenerator"},"UnitGenerator")),(0,r.kt)("h4",{id:"vogen"},(0,r.kt)("a",{parentName:"h4",href:"/docs/Vogen"},"Vogen")))}g.isMDXComponent=!0},7983:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/files/DomainPrimitives-fb299eedd08fa14f01e555a2fd14f378.zip"}}]);