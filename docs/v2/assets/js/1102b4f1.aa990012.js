"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[2274],{63675:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>p,default:()=>h,frontMatter:()=>l,metadata:()=>m,toc:()=>c});var a=t(87462),r=(t(67294),t(3905)),s=t(73992),o=t(18679),i=t(68839);const l={sidebar_position:1150,title:"115 - UnionsGenerator",description:"Generating Union types for C#",slug:"/UnionsGenerator"},p="UnionsGenerator  by Paul Braetz",m={unversionedId:"RSCG-Examples/UnionsGenerator",id:"RSCG-Examples/UnionsGenerator",title:"115 - UnionsGenerator",description:"Generating Union types for C#",source:"@site/docs/RSCG-Examples/UnionsGenerator.md",sourceDirName:"RSCG-Examples",slug:"/UnionsGenerator",permalink:"/RSCG_Examples/v2/docs/UnionsGenerator",draft:!1,tags:[],version:"current",sidebarPosition:1150,frontMatter:{sidebar_position:1150,title:"115 - UnionsGenerator",description:"Generating Union types for C#",slug:"/UnionsGenerator"},sidebar:"tutorialSidebar",previous:{title:"114 - corecraft",permalink:"/RSCG_Examples/v2/docs/corecraft"},next:{title:"116 - CopyTo",permalink:"/RSCG_Examples/v2/docs/CopyTo"}},u={},c=[{value:"Nuget / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share UnionsGenerator",id:"share-unionsgenerator",level:3},{value:"In the same category (FunctionalProgramming) - 15 other generators",id:"in-the-same-category-functionalprogramming---15-other-generators",level:3},{value:"cachesourcegenerator",id:"cachesourcegenerator",level:4},{value:"dunet",id:"dunet",level:4},{value:"Dusharp",id:"dusharp",level:4},{value:"Funcky.DiscriminatedUnion",id:"funckydiscriminatedunion",level:4},{value:"FunicularSwitch",id:"funicularswitch",level:4},{value:"N.SourceGenerators.UnionTypes",id:"nsourcegeneratorsuniontypes",level:4},{value:"OneOf",id:"oneof",level:4},{value:"PartiallyApplied",id:"partiallyapplied",level:4},{value:"polytype",id:"polytype",level:4},{value:"rscg_demeter",id:"rscg_demeter",level:4},{value:"rscg_queryables",id:"rscg_queryables",level:4},{value:"RSCG_Utils_Memo",id:"rscg_utils_memo",level:4},{value:"Sera.Union",id:"seraunion",level:4},{value:"TypeUtilities",id:"typeutilities",level:4},{value:"UnionGen",id:"uniongen",level:4}],y={toc:c},d="wrapper";function h(e){let{components:n,...l}=e;return(0,r.kt)(d,(0,a.Z)({},y,l,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"unionsgenerator--by-paul-braetz"},"UnionsGenerator  by Paul Braetz"),(0,r.kt)(i.Z,{toc:c,mdxType:"TOCInline"}),(0,r.kt)("h2",{id:"nuget--site-data"},"Nuget / site data"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/RhoMicro.CodeAnalysis.UnionsGenerator"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/RhoMicro.CodeAnalysis.UnionsGenerator?label=RhoMicro.CodeAnalysis.UnionsGenerator",alt:"Nuget"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/PaulBraetz/RhoMicro.CodeAnalysis?label=updated",alt:"GitHub last commit"})),"\n",(0,r.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/PaulBraetz/RhoMicro.CodeAnalysis?style=social",alt:"GitHub Repo stars"})),(0,r.kt)("h2",{id:"details"},"Details"),(0,r.kt)("h3",{id:"info"},"Info"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Name: ",(0,r.kt)("strong",{parentName:"p"},"UnionsGenerator")),(0,r.kt)("p",{parentName:"admonition"},"Generate hybrid (tagged/type) union types."),(0,r.kt)("p",{parentName:"admonition"},"Author: Paul Braetz"),(0,r.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/RhoMicro.CodeAnalysis.UnionsGenerator"},"https://www.nuget.org/packages/RhoMicro.CodeAnalysis.UnionsGenerator")),"   "),(0,r.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/"},"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/")),(0,r.kt)("p",{parentName:"admonition"},"Source : ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/"},"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/"))),(0,r.kt)("h3",{id:"original-readme"},"Original Readme"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("h1",{parentName:"admonition",id:"rhomicrocodeanalysis"},"Rhomicro.CodeAnalysis"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("img",{parentName:"p",src:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/actions/workflows/buildPublish.yml/badge.svg",alt:"Build"})),(0,r.kt)("p",{parentName:"admonition"},"This repository contains my explorations on c# source code generation and analysis."),(0,r.kt)("p",{parentName:"admonition"},"The ","[UnionsGenerator]","(",(0,r.kt)("a",{parentName:"p",href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//UnionsGenerator"},"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//UnionsGenerator")," generator enables the use of union types in C#."),(0,r.kt)("p",{parentName:"admonition"},"The ","[UtilityGenerators]","(",(0,r.kt)("a",{parentName:"p",href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//UtilityGenerators"},"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//UtilityGenerators")," generator helps you write code generators and analyzers."),(0,r.kt)("p",{parentName:"admonition"},"The ","[CopyTo]","(",(0,r.kt)("a",{parentName:"p",href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//CopyTo"},"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//CopyTo")," generator generates methods to copy the contents of one instance to another. I created this generator for a friend, so it is not as feature rich as it could be.")),(0,r.kt)("h3",{id:"about"},"About"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Generating Union types for C#")),(0,r.kt)("h2",{id:"how-to-use"},"How to use"),(0,r.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,r.kt)("p",null,"This is the CSharp Project that references ",(0,r.kt)("strong",{parentName:"p"},"UnionsGenerator")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {16}",showLineNumbers:!0,"{16}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n    <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n\n    <ItemGroup>\n      <PackageReference Include="RhoMicro.CodeAnalysis.UnionsGenerator" Version="14.0.2">\n        <PrivateAssets>all</PrivateAssets>\n        <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n      </PackageReference>\n    </ItemGroup>\n</Project>\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"UnionsGenerator")," in ",(0,r.kt)("em",{parentName:"p"},"Program.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using UnionTypesDemo;\n\nConsole.WriteLine("Save or not");\nvar data = SaveToDatabase.Save(0);\nConsole.WriteLine(data.IsValidationError);\ndata = SaveToDatabase.Save(1);\nConsole.WriteLine(data.IsSuccess);\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\ResultSave.cs",label:"ResultSave.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"UnionsGenerator")," in ",(0,r.kt)("em",{parentName:"p"},"ResultSave.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using RhoMicro.CodeAnalysis;\nnamespace UnionTypesDemo;\npublic record Success(int Value);\npublic record ValidationError(string Message);\n\n[UnionType<Success>]\n[UnionTypeAttribute<ValidationError>]\npublic partial class ResultSave\n{\n}\n\n\n\n"))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\SaveToDatabase.cs",label:"SaveToDatabase.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"UnionsGenerator")," in ",(0,r.kt)("em",{parentName:"p"},"SaveToDatabase.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'namespace UnionTypesDemo;\n\npublic class SaveToDatabase\n{\n    public static ResultSave Save(int i)\n    {\n        if(i ==0)\n        {\n            return new ValidationError(" cannot save 0");\n        }\n        return new Success(i);\n    }\n}\n\n\n\n')))),(0,r.kt)("h3",{id:"generated-files"},"Generated Files"),(0,r.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\RhoMicro_CodeAnalysis_RelationTypeAttribute.g.cs",label:"RhoMicro_CodeAnalysis_RelationTypeAttribute.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated>\n// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#nullable enable\n#pragma warning disable\n\nnamespace RhoMicro.CodeAnalysis\n{\n    using System;\n\n    /// <summary>\n    /// Marks the target type to be related to another union type.\n    /// </summary>\n    /// <typeparam name="T0">The type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n#if UNIONS_GENERATOR\n    [GenerateFactory(OmitTypeCheck = true)]\n#endif\n    sealed partial class RelationAttribute<T0> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T3">The fourth type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2, T3> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T3">The fourth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T4">The fifth type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2, T3, T4> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T3">The fourth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T4">The fifth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T5">The sixth type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2, T3, T4, T5> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T3">The fourth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T4">The fifth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T5">The sixth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T6">The seventh type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2, T3, T4, T5, T6> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T3">The fourth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T4">The fifth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T5">The sixth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T6">The seventh type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T7">The eighth type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2, T3, T4, T5, T6, T7> : Attribute\n    { }\n}\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\RhoMicro_CodeAnalysis_UnionFactoryAttribute.g.cs",label:"RhoMicro_CodeAnalysis_UnionFactoryAttribute.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated>\n// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#nullable enable\n#pragma warning disable\n\nnamespace RhoMicro.CodeAnalysis\n{\n    using System;\n\n    /// <summary>\n    /// Marks the target method as the factory method to use when instantiating \n    /// an instance of the union type representing a value of the annotated parameter.\n    /// Factory methods must be static, have no type parameters and only have one \n    /// parameter of a type representable by the union type. \n    /// Factory polymorphism is not yet supported.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\n#if UNIONS_GENERATOR\n    [GenerateFactory]\n#endif\n    sealed partial class UnionTypeFactoryAttribute : Attribute\n    { }\n}\n\n"))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\RhoMicro_CodeAnalysis_UnionsGenerator_Generated_Util.g.cs",label:"RhoMicro_CodeAnalysis_UnionsGenerator_Generated_Util.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated>\n// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#nullable enable\n#pragma warning disable\n\nnamespace RhoMicro.CodeAnalysis.UnionsGenerator.Generated\n{\n    using System.Collections.Concurrent;\n    using System.Collections.Generic;\n    using System.Text;\n    using System.Linq;\n    using System;\n\n    [System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n    internal static class Util\n    {\n        private readonly static ConcurrentDictionary<Type, String> _cache = new();\n        internal static String GetFullString(Type type) => _cache.GetOrAdd(type, ValueFactory);\n        static String ValueFactory(Type type)\n        {\n            var result = getString(type, new());\n\n            return result;\n\n            static String getString(Type type, StringBuilder builder)\n            {\n                var unboundTransitiveParameters = 0;\n                var transitiveParameters = new List<(String Format, Type? Argument)>();\n                append(type, builder, transitiveParameters, ref unboundTransitiveParameters);\n                var result = builder.ToString();\n\n                for(var i = 0; i < transitiveParameters.Count; i++)\n                {\n                    _ = builder.Clear();\n                    var (format, argument) = transitiveParameters[i];\n                    var replacement = getString(argument!, builder);\n                    result = result.Replace(format, replacement);\n                }\n\n                return result;\n\n                static void append(\n                    Type type,\n                    StringBuilder builder,\n                    List<(String Format, Type? Argument)> transitiveArgumentsMap,\n                    ref Int32 unboundTransitiveParameters)\n                {\n#if NETSTANDARD2_0\n                        if(type.IsGenericParameter && type.DeclaringMethod is null)\n#else\n                    if(type.IsGenericTypeParameter)\n#endif\n                    {\n                        var format = $"{Guid.NewGuid()}";\n                        _ = builder.Append(format);\n                        transitiveArgumentsMap.Add((format, null));\n                        unboundTransitiveParameters++;\n                        return;\n                    } else if(type.DeclaringType != null)\n                    {\n                        append(type.DeclaringType, builder, transitiveArgumentsMap, ref unboundTransitiveParameters);\n                        _ = builder.Append(\'.\');\n                    } else if(type.Namespace != null)\n                    {\n                        _ = builder.Append(type.Namespace)\n                                .Append(\'.\');\n                    }\n\n                    var tickIndex = type.Name.IndexOf(\'`\');\n                    _ = tickIndex != -1 ?\n#if NETSTANDARD2_0\n                            builder.Append(type.Name.Substring(0, tickIndex)) :\n#else\n                        builder.Append(type.Name.AsSpan(0, tickIndex)) :\n#endif\n                        builder.Append(type.Name);\n\n                    var arguments = type.GetGenericArguments();\n                    var inflectionPoint = unboundTransitiveParameters;\n                    if(arguments.Length > 0 && unboundTransitiveParameters > 0)\n                    {\n                        for(; unboundTransitiveParameters > 0;)\n                        {\n                            unboundTransitiveParameters--;\n                            var (format, _) = transitiveArgumentsMap[unboundTransitiveParameters];\n                            transitiveArgumentsMap[unboundTransitiveParameters] = (format, arguments[unboundTransitiveParameters]);\n                        }\n                    }\n\n                    if(arguments.Length > inflectionPoint)\n                    {\n                        _ = builder.Append(\'<\');\n                        append(arguments[inflectionPoint], builder, transitiveArgumentsMap, ref unboundTransitiveParameters);\n\n                        for(var i = inflectionPoint + 1; i < type.GenericTypeArguments.Length; i++)\n                        {\n                            _ = builder.Append(", ");\n                            append(arguments[i], builder, transitiveArgumentsMap, ref unboundTransitiveParameters);\n                        }\n\n                        _ = builder.Append(\'>\');\n                    }\n                }\n            }\n        }\n        \n        internal static System.Boolean IsMarked(Type type) =>\n            type.CustomAttributes.Any(a => a.AttributeType.FullName == "RhoMicro.CodeAnalysis.UnionTypeAttribute") ||\n            type.GenericTypeArguments.Any(t => t.CustomAttributes.Any(a => \n                a.AttributeType.FullName.StartsWith("RhoMicro.CodeAnalysis.UnionTypeAttribute`") \n                && a.AttributeType.GenericTypeArguments.Length < 255));\n\n        private static readonly System.Collections.Concurrent.ConcurrentDictionary<(Type, Type), Object> _conversionImplementations = new();\n        internal static TTo UnsafeConvert<TFrom, TTo>(in TFrom from)\n        {\n            var impl = (System.Func<TFrom, TTo>)_conversionImplementations.GetOrAdd((typeof(TFrom), typeof(TTo)), k =>\n            {\n                var param = System.Linq.Expressions.Expression.Parameter(k.Item1);\n                var castExpr = System.Linq.Expressions.Expression.Convert(param, k.Item2);\n                var lambda = System.Linq.Expressions.Expression.Lambda(castExpr, param).Compile();\n\n                return lambda;\n            });\n            var result = impl.Invoke(from);\n\n            return result;\n        }\n    }\n}\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\RhoMicro_CodeAnalysis_UnionTypeAttribute.g.cs",label:"RhoMicro_CodeAnalysis_UnionTypeAttribute.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated>\n// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#nullable enable\n#pragma warning disable\n\nnamespace RhoMicro.CodeAnalysis\n{\n    using System;\n    using System.Collections.Generic;\n\n    /// <summary>\n    /// Defines options for generating union types.\n    /// </summary>\n    [Flags]\n    enum UnionTypeOptions\n    {\n        /// <summary>\n        /// The default options.\n        /// </summary>\n        Default = ImplicitConversionIfSolitary,\n        /// <summary>\n        /// </summary>\n        None = 0x00,\n        /// <summary>\n        /// Instructs the generator to emit an implicit conversion to the representable type if it is the only one.\n        /// In effect, this option will enable the union type to act as an alias wrapper for the representable type.\n        /// </summary>\n        ImplicitConversionIfSolitary = 0x01,\n        /// <summary>\n        /// Instructs the generator to emit a superset conversion operator implementation even though\n        /// the representable type is a generic type parameter. By default, it is omitted because of possible\n        /// unification for certain generic arguments.\n        /// </summary>\n        //SupersetOfParameter = 0x02,\n        /// <summary>\n        /// Instructs the generator to treat the representable reference type \n        /// as nullable, allowing for <see langword="null"/> \n        /// arguments in factories, conversions etc.\n        /// </summary>\n        Nullable = 0x04\n    }\n\n    /// <summary>\n    /// Defines options for the storage implementation of a representable type.\n    /// In order for the generator to generate an efficient storage implementation, \n    /// consumers should communicate whether the representable type is known to\n    /// be a struct, class or of unknown nature. This is mostly relevant for generic\n    /// type parameters, however an explicit strategy may be selected for any representable\n    /// type. Whether or not generic type parameters are known to be reference\n    /// or value types depends on their constraints. Parameters constrained to \n    /// <see langword="struct"/> will be assumed to be value types. Conversely,\n    /// parameters constrained to <see langword="class"/> will be assumed to be reference types.\n    /// </summary>\n    /*\n               | box |value| auto | field\n        struct | rc! | vc  | vc   | cc\n        class  | rc  | rc! | rc   | cc\n        none   | rc! | vc! | rc!  | cc\n    */\n    enum StorageOption\n    {\n        /// <summary>\n        /// The generator will automatically decide on a storage strategy.\n        /// <para>\n        /// If the representable type is <b>known to be a value type</b>,\n        /// this will store values of that type inside a shared value type container.\n        /// <b>Boxing will not occur.</b>\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>known to be a reference type</b>,\n        /// this will store values of that type inside a shared reference type container.\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>neither known to be a reference type\n        /// nor a value type</b>, this option will cause values of that type to \n        /// be stored inside a shared reference type container.\n        /// <b>If the representable type is a generic type parameter,\n        /// boxing will occur for value type arguments to that parameter.</b>\n        /// </para>\n        /// </summary>\n        Auto,\n\n        /// <summary>\n        /// The generator will always store values of the representable type\n        /// inside a shared reference type container.\n        /// <para>\n        /// If the representable type is <b>known to be a value type</b>,\n        /// <b>boxing will occur</b>.\n        /// </para>\n        /// <para>\n        /// If the representable type is a <b>generic type parameter</b>,\n        /// <b>boxing will occur for value type arguments</b> to that parameter.\n        /// </para>\n        /// </summary>\n        Reference,\n\n        /// <summary>\n        /// The generator will attempt to store values of the representable type\n        /// inside a value type container.\n        /// <para>\n        /// If the representable type is <b>known to be a value type</b>,\n        /// this will store values of that type inside a shared value type container.\n        /// <b>Boxing will not occur.</b>\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>known to be a reference type</b>,\n        /// this will store values of that type inside a shared reference type container.\n        /// <b>Boxing will not occur.</b>\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>neither known to be a reference type\n        /// nor a value type</b>, this option will cause values of that type to \n        /// be stored inside a shared value type container.\n        /// <b>If the representable type is a generic type parameter,\n        /// an exception of type <see cref="TypeLoadException"/> will occur for\n        /// reference type arguments to that parameter.</b>\n        /// </para>\n        /// </summary>\n        Value,\n\n        /// <summary>\n        /// The generator will attempt to store values of the representable type\n        /// inside a dedicated container for that type.\n        /// <para>\n        /// If the representable type is <b>known to be a value type</b>,\n        /// this will store values of that type inside a dedicated \n        /// value type container.\n        /// <b>Boxing will not occur.</b>\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>known to be a reference type</b>,\n        /// this will store values of that type inside a \n        /// dedicated reference type container.\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>neither known to be a reference type\n        /// nor a value type</b>, this option will cause values of that type to \n        /// be stored inside a dedicated strongly typed container.\n        /// <b>Boxing will not occur.</b>\n        /// </para>\n        /// </summary>\n        Field\n    }\n\n    /// <summary>\n    /// Marks the target type as a union type being able to represent the type passed to the constructor.\n    /// </summary>\n    [AttributeUsage(( (AttributeTargets)( -1 ) ))]\n    partial class UnionTypeBaseAttribute : Attribute\n    {\n        /// <summary>\n        /// Gets or sets the alias groups that the representable type is to be a part of. \n        /// Represnetable types that share a group may be checked for using unified methods \n        /// and properties like <c>IsGroup</c> where <c>Group</c> is the name of the group\n        /// that the representable type is a part of.\n        /// </summary>\n        public virtual String[] Groups { get; set; } = Array.Empty<String>();\n\n        /// <summary>\n        /// Gets or sets the generator options to use.\n        /// </summary>\n        public virtual UnionTypeOptions Options { get; set; } = UnionTypeOptions.Default;\n\n        /// <summary>\n        /// Gets or sets the option defining storage generation.\n        /// </summary>\n        public virtual StorageOption Storage { get; set; }\n    }\n    [AttributeUsage(( (AttributeTargets)( -1 ) ))]\n#if UNIONS_GENERATOR\n    [GenerateFactory(OmitTypeCheck = true)]\n#endif\n    partial class AliasedUnionTypeBaseAttribute : UnionTypeBaseAttribute\n    {\n        /// <summary>\n        /// Gets or sets the alias to use for members representing the type represented by the union.\n        /// For example, the represented type <see cref="List{T}"/> would be represented using names like\n        /// <c>list_of_T</c>. Setting this property to <c>yourAlias</c> will instruct the generator to use\n        /// member names like <c>yourAlias</c> instead of <c>list_of_T</c>. Use this property to avoid\n        /// name collisions in generated code. Since the alias will be used for member names, it will\n        /// only be taken into account if it is a valid identifier name.\n        /// </summary>\n        public String? Alias { get; set; }\n        /// <inheritdoc/>\n        public override String[] Groups { get => base.Groups; set => base.Groups = value; }\n        /// <inheritdoc/>\n        public override UnionTypeOptions Options { get => base.Options; set => base.Options = value; }\n        /// <inheritdoc/>\n        public override StorageOption Storage { get => base.Storage; set => base.Storage = value; }\n    }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent <typeparamref name="T0"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0> : AliasedUnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>\n    /// and <typeparamref name="T1"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>\n    /// and <typeparamref name="T2"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>,\n    /// <typeparamref name="T2"/>\n    /// and <typeparamref name="T3"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2, T3> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>,\n    /// <typeparamref name="T2"/>,\n    /// <typeparamref name="T3"/>\n    /// and <typeparamref name="T4"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>,\n    /// <typeparamref name="T2"/>,\n    /// <typeparamref name="T3"/>,\n    /// <typeparamref name="T4"/>\n    /// and <typeparamref name="T5"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4, T5> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>,\n    /// <typeparamref name="T2"/>,\n    /// <typeparamref name="T3"/>,\n    /// <typeparamref name="T4"/>,\n    /// <typeparamref name="T5"/>\n    /// and <typeparamref name="T6"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4, T5, T6> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>,\n    /// <typeparamref name="T2"/>,\n    /// <typeparamref name="T3"/>,\n    /// <typeparamref name="T4"/>,\n    /// <typeparamref name="T5"/>,\n    /// <typeparamref name="T6"/>\n    /// and <typeparamref name="T7"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4, T5, T6, T7> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent the annotated type parameter.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]\n    sealed partial class UnionTypeAttribute : AliasedUnionTypeBaseAttribute\n    { }\n}\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\RhoMicro_CodeAnalysis_UnionTypeSettingsAttribute.g.cs",label:"RhoMicro_CodeAnalysis_UnionTypeSettingsAttribute.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated>\n// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#nullable enable\n#pragma warning disable\n\nnamespace RhoMicro.CodeAnalysis;\n\nusing System;\n\n#region Setting Enums\n/// <summary>\n/// Defines settings for generating an implementation of <see cref="Object.ToString"/>.\n/// </summary>\nenum ToStringSetting\n{\n    /// <summary>\n    /// The generator will emit an implementation that returns detailed information, including:\n    /// <list type="bullet">\n    /// <item><description>the name of the union type</description></item>\n    /// <item><description>a list of types representable by the union type</description></item>\n    /// <item><description>an indication of which type is being represented by the instance</description></item>\n    /// <item><description>the value currently being represented by the instance</description></item>\n    /// </list>\n    /// </summary>\n    Detailed,\n    /// <summary>\n    /// The generator will not generate an implementation of <see cref="Object.ToString"/>.\n    /// </summary>\n    None,\n    /// <summary>\n    /// The generator will generate an implementation that returns the result of calling <see cref="Object.ToString"/> on the currently represented value.\n    /// </summary>\n    Simple\n}\n/// <summary>\n/// Defines settings for annotating the target with an instance of <see cref="System.Runtime.InteropServices.StructLayoutAttribute"/>.\n/// </summary>\nenum LayoutSetting\n{\n    /// <summary>\n    /// Generate an annotation optimized for size.\n    /// </summary>\n    Small,\n    /// <summary>\n    /// Do not generate any annotations.\n    /// </summary>\n    Auto\n}\n/// <summary>\n/// Defines settings for controlling the accessibility of generated constructors.\n/// </summary>\nenum ConstructorAccessibilitySetting\n{\n    /// <summary>\n    /// Generated constructors should always be private, unless\n    /// no conversion operators are generated for the type they\n    /// accept. This would be the case for interface types or\n    /// supertypes of the target union.\n    /// </summary>\n    PublicIfInconvertible,\n    /// <summary>\n    /// Generated constructors should always be private.\n    /// </summary>\n    Private,\n    /// <summary>\n    /// Generated constructors should always be public\n    /// </summary>\n    Public\n}\n/// <summary>\n/// Defines settings on how to implement interfaces that all representable\n/// types implement.\n/// </summary>\nenum InterfaceMatchSetting\n{\n    /// <summary>\n    /// Generated interface implementations should be explicit if at least\n    /// one of the representable types implements the interface explicitly;\n    /// otherwise, interface implementations should be implicit.\n    /// </summary>\n    Auto,\n    /// <summary>\n    /// Generated interface implementations should always be explicit.\n    /// </summary>\n    Explicit,\n    /// <summary>\n    /// Generated interface implementations should always be implicit.\n    /// </summary>\n    Implicit,\n    /// <summary>\n    /// No interfaces implementations should be generated.\n    /// </summary>\n    Omit\n}\n/// <summary>\n/// Defines settings for the kind of diagnostics to report.\n/// </summary>\n[Flags]\nenum DiagnosticsLevelSettings\n{\n    /// <summary>\n    /// Instructs the analyzer not to emit diagnostics\n    /// </summary>\n    None = 0x00,\n    /// <summary>\n    /// Instructs the analyzer to report info diagnostics.\n    /// </summary>\n    Info = 0x01,\n    /// <summary>\n    /// Instructs the analyzer to report warning diagnostics.\n    /// </summary>\n    Warning = 0x02,\n    /// <summary>\n    /// Instructs the analyzer to report error diagnostics.\n    /// </summary>\n    Error = 0x04,\n    /// <summary>\n    /// Instructs the analyzer to report all diagnostics.\n    /// </summary>\n    All = Info | Warning | Error\n}\n/// <summary>\n/// Defines miscellaneous settings.\n/// </summary>\n[Flags]\nenum MiscellaneousSettings\n{\n    /// <summary>\n    /// </summary>\n    None = 0x00,\n    /// <summary>\n    /// The default settings.\n    /// </summary>\n    Default = None,\n    /// <summary>\n    /// Indicates whether the generated source code should be available as a string constant on the union type itself.\n    /// This setting is generally only useful if the generated implementation should be emitted from another generator.\n    /// </summary>\n    EmitGeneratedSourceCode = 0x01,\n    /// <summary>\n    /// Indicates whether to generate a custom converter type \n    /// for <c>System.Text.Json</c> deserialization. If set, this will also cause\n    /// the union type to be annotated with an appropriate <c>JsonConverter</c> attribute.\n    /// </summary>\n    GenerateJsonConverter = 0x02,\n    /// <summary>\n    /// Indicates that the generator should emit a comment detailing the structure of the union type.\n    /// </summary>\n    EmitStructuralRepresentation = 0x04\n}\n\n/// <summary>\n/// Defines settings pertaining to equality operator implementations.\n/// </summary>\nenum EqualityOperatorsSetting\n{\n    /// <summary>\n    /// Equality operators will be emitted only if the target union type is a value type.\n    /// </summary>\n    EmitOperatorsIfValueType,\n    /// <summary>\n    /// Equality operators will be emitted.\n    /// </summary>\n    EmitOperators,\n    /// <summary>\n    /// Equality operators will be omitted.\n    /// </summary>\n    OmitOperators\n}\n\n#endregion\n#region Attribute Declaration\n/// <summary>\n/// Supplies the generator with additional settings on how to generate a targeted union type.\n/// If the target member is an assembly, the attribute supplies default values for any union \n/// type setting not defined.\n/// </summary>\n[AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class | AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)]\n#if UNIONS_GENERATOR\n[GenerateFactory]\n#endif\nsealed partial class UnionTypeSettingsAttribute : Attribute\n{\n    #region Settings\n    /// <summary>\n    /// Defines how to generate an implementation <see cref="Object.ToString"/>.\n    /// </summary>\n    public ToStringSetting ToStringSetting { get; set; } = ToStringSetting.Detailed;\n    /// <summary>\n    /// Defines whether to generate a size optimizing annotation.\n    /// </summary>\n    public LayoutSetting Layout { get; set; } = LayoutSetting.Auto;\n    /// <summary>\n    /// The level of diagnostics to be reported by the analyzer.\n    /// </summary>\n    public DiagnosticsLevelSettings DiagnosticsLevel { get; set; } = DiagnosticsLevelSettings.All;\n    /// <summary>\n    /// The desired accessibility of generated constructors.\n    /// </summary>\n    public ConstructorAccessibilitySetting ConstructorAccessibility { get; set; } = ConstructorAccessibilitySetting.Private;\n    /// <summary>\n    /// Indicates how to generate implementations for\n    /// interfaces implemented by all representable types. Implementations will \n    /// map calls to interface instance methods and properties onto the represented\n    /// value. \n    /// <para>\n    /// Please note that currently, only fully bound and constructed interface implementations are supported.\n    /// </para>\n    /// </summary>\n    public InterfaceMatchSetting InterfaceMatchSetting { get; set; } = InterfaceMatchSetting.Auto;\n    /// <summary>\n    /// Indicates how to generate equality operators.\n    /// By default, equality operators will only be emitted for value types, so as to preserve\n    /// reference equality for comparing reference union types via <c>==</c> or <c>!=</c>.\n    /// </summary>\n    public EqualityOperatorsSetting EqualityOperatorsSetting { get; set; } = EqualityOperatorsSetting.EmitOperatorsIfValueType;\n    /// <summary>\n    /// Gets or sets miscellaneous settings.\n    /// </summary>\n    public MiscellaneousSettings Miscellaneous { get; set; } = MiscellaneousSettings.Default;\n    #endregion\n    #region Strings\n    /// <summary>\n    /// A raw code preface to prepend before the generated type declaration.\n    /// </summary>\n    public String TypeDeclarationPreface { get; set; } = "";\n    /// <summary>\n    /// The name of the generic parameter for generic <c>Is</c>, <c>As</c> and factory methods. \n    /// Set this property in order to avoid name collisions with generic union type parameters\n    /// </summary>\n    public String GenericTValueName { get; set; } = "TValue";\n    /// <summary>\n    /// The name of the generic parameter for the <c>TryConvert</c> method. \n    /// Set this property in order to avoid name collisions with generic union type parameters\n    /// </summary>\n    public String TryConvertTypeName { get; set; } = "TUnion";\n    /// <summary>\n    /// The name of the generic parameter for the <c>Match</c> method. \n    /// Set this property in order to avoid name collisions with generic union type parameters\n    /// </summary>\n    public String MatchTypeName { get; set; } = "TMatchResult";\n    /// <summary>\n    /// The name to use for the discriminating tag type.\n    /// </summary>\n    public String TagTypeName { get; set; } = "__Tag";\n    /// <summary>\n    /// The name to use for the container type containing value types.\n    /// </summary>\n    public String ValueTypeContainerTypeName { get; set; } = "__ValueTypeContainer";\n    /// <summary>\n    /// The name to use for the field containing value types.\n    /// </summary>\n    public String ValueTypeContainerName { get; set; } = "__value";\n    /// <summary>\n    /// The name to use for the field containing reference types.\n    /// </summary>\n    public String ReferenceTypeContainerName { get; set; } = "__reference";\n    /// <summary>\n    /// The name to use for the field containing the discriminating tag.\n    /// </summary>\n    public String TagFieldName { get; set; } = "__tag";\n    /// <summary>\n    /// The name to use for the default (uninitialized) tag value.\n    /// </summary>\n    public String TagNoneName { get; set; } = "__None";\n    /// <summary>\n    /// The name of the generated json converter type.\n    /// </summary>\n    public String JsonConverterTypeName { get; set; } = "JsonConverter";\n    #endregion\n}\n#endregion\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\UnionTypesDemo_ResultSave.g.cs",label:"UnionTypesDemo_ResultSave.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated>\n// This file was last generated by RhoMicro.CodeAnalysis.UnionsGenerator at 9/22/2024 10:00:02 PM +03:00\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#pragma warning disable\n#nullable enable\n#region Implementation of UnionTypesDemo.ResultSave\nnamespace UnionTypesDemo\n{\n    using System.Linq;\n    \n    #region Scoped Data\n    file static class UnionTypesDemo_ResultSave_ScopedData\n    {\n        public static System.Collections.Concurrent.ConcurrentDictionary<System.Type, System.Object> Cache { get; } = new();\n        public static System.Collections.Generic.HashSet<System.Type> RepresentableTypes { get; } = \n        new ()\n        {\n            typeof(UnionTypesDemo.Success),\n            typeof(UnionTypesDemo.ValidationError)\n        }\n        ;\n    }\n    #endregion\n    partial class ResultSave : System.IEquatable<ResultSave?>\n    {\n        \n        #region Nested Types\n        #region Value Type Container\n        #endregion\n        #region Tag Type\n        /// <summary>\n        /// Defines tags to discriminate between representable types.\n        /// </summary>\n        /// <remarks>\n        /// This member is not intended for use by user code inside of or any code outside of <see cref="UnionTypesDemo.ResultSave"/>.\n        /// </remarks>\n        [System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n        private enum __Tag : System.Byte\n        {\n            /// <summary>\n            /// Used when not representing any type due to e.g. incorrect or missing initialization.\n            /// </summary>\n            __None,\n\n            \n            /// <summary>\n            /// Used when representing an instance of <see cref="UnionTypesDemo.Success"/>.\n            /// </summary>\n            Success,\n            \n            /// <summary>\n            /// Used when representing an instance of <see cref="UnionTypesDemo.ValidationError"/>.\n            /// </summary>\n            ValidationError\n        }\n        #endregion\n        #endregion\n        \n        #region Constructors\n        \n        /// <summary>\n        /// Creates a new instance of <see cref="UnionTypesDemo.ResultSave"/>representing an instance of <see cref="UnionTypesDemo.Success"/>.\n        /// </summary>\n        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n        [System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n        private ResultSave(UnionTypesDemo.Success value)\n        {\n            __tag = __Tag.Success;\n            this.__reference = value;\n        }\n        \n        \n        /// <summary>\n        /// Creates a new instance of <see cref="UnionTypesDemo.ResultSave"/>representing an instance of <see cref="UnionTypesDemo.ValidationError"/>.\n        /// </summary>\n        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n        [System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n        private ResultSave(UnionTypesDemo.ValidationError value)\n        {\n            __tag = __Tag.ValidationError;\n            this.__reference = value;\n        }\n        #endregion\n        \n        #region Fields\n        \n        /// <summary>\n        /// Contains the value of instances of <see cref="UnionTypesDemo.ResultSave"/> representing one of these types:\n        /// <list type="bullet">\n        /// <item>\n        /// <see cref="UnionTypesDemo.Success"/>\n        /// </item>\n        /// <item>\n        /// <see cref="UnionTypesDemo.ValidationError"/>\n        /// </item>\n        /// </list>\n        /// </summary>\n        /// <remarks>\n        /// This member is not intended for use by user code inside of or any code outside of <see cref="UnionTypesDemo.ResultSave"/>.\n        /// </remarks>\n        [System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n        private readonly System.Object? __reference;\n        \n        /// <summary>\n        /// Used to determine the currently represented type and value.\n        /// </summary>\n        /// <remarks>\n        /// This member is not intended for use by user code inside of or any code outside of <see cref="UnionTypesDemo.ResultSave"/>.\n        /// </remarks>\n        [System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n        private readonly __Tag __tag;\n        #endregion\n        \n        #region Factories\n        \n        /// <summary>\n        /// Creates a new instance of <see cref="UnionTypesDemo.ResultSave"/> representing an instance of <see cref="UnionTypesDemo.Success"/>.\n        /// </summary>\n        /// <param name="value">\n        /// The value to be represented by the new instance of <see cref="UnionTypesDemo.ResultSave"/>.\n        /// </param>\n        /// <returns>\n        /// A new instance of <see cref="UnionTypesDemo.ResultSave"/> representing <paramref name="value"/>.\n        /// </returns>\n        public static ResultSave CreateFromSuccess([RhoMicro.CodeAnalysis.UnionTypeFactory]UnionTypesDemo.Success value) => new(value);\n        \n        /// <summary>\n        /// Creates a new instance of <see cref="UnionTypesDemo.ResultSave"/> representing an instance of <see cref="UnionTypesDemo.ValidationError"/>.\n        /// </summary>\n        /// <param name="value">\n        /// The value to be represented by the new instance of <see cref="UnionTypesDemo.ResultSave"/>.\n        /// </param>\n        /// <returns>\n        /// A new instance of <see cref="UnionTypesDemo.ResultSave"/> representing <paramref name="value"/>.\n        /// </returns>\n        public static ResultSave CreateFromValidationError([RhoMicro.CodeAnalysis.UnionTypeFactory]UnionTypesDemo.ValidationError value) => new(value);\n        /// <summary>\n        /// Attempts to create an instance of <see cref="UnionTypesDemo.ResultSave"/> from an instance of <typeparamref name="TValue"/>.\n        /// </summary>\n        /// <param name="value">\n        /// The value from which to attempt to create an instance of <see cref="UnionTypesDemo.ResultSave"/>.\n        /// </param>\n        /// <param name="result">\n        /// If an instance of <see cref="UnionTypesDemo.ResultSave"/> could successfully be created, this parameter will contain the newly created instance; otherwise, <see langword="default"/>.\n        /// </param>\n        /// <returns>\n        /// <see langword="true"/> if an instance of <see cref="UnionTypesDemo.ResultSave"/> could successfully be created; otherwise, <see langword="false"/>.\n        /// </returns>\n        public static System.Boolean TryCreate<TValue>(TValue value, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out ResultSave? result)\n        {\n            var metadataName = RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.GetFullString(typeof(TValue));\n            switch(metadataName)\n            {\n                case "UnionTypesDemo.Success":\n                {\n                    result = CreateFromSuccess((RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<TValue, UnionTypesDemo.Success>(value)));\n                    return true;\n                }\n                \n                case "UnionTypesDemo.ValidationError":\n                {\n                    result = CreateFromValidationError((RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<TValue, UnionTypesDemo.ValidationError>(value)));\n                    return true;\n                }\n                default:\n                {\n                    \n                    {\n                        var sourceType = typeof(TValue);\n                        if(!UnionTypesDemo_ResultSave_ScopedData.Cache.TryGetValue(sourceType, out var weakMatch))\n                        {\n                            if(!RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.IsMarked(sourceType))\n                            {\n                                result = default;\n                                return false;\n                            }\n                            weakMatch = UnionTypesDemo_ResultSave_ScopedData.Cache.GetOrAdd(sourceType, t =>\n                            {\n                                var tupleType = typeof(System.ValueTuple<System.Boolean, ResultSave>);\n                                var matchMethod = sourceType.GetMethod(nameof(Match), System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public)\n                                    ?.MakeGenericMethod(tupleType) ??\n                                    throw new System.InvalidOperationException("Unable to locate match function on source union type. This indicates a bug in the marker detection algorithm.");\n                                var targetFactoryMap = typeof(UnionTypesDemo.ResultSave).GetMethods()\n                                    .Where(c => c.CustomAttributes.Any(a => a.AttributeType.FullName == "RhoMicro.CodeAnalysis.UnionTypeFactoryAttribute"))\n                                    .ToDictionary(c => c.GetParameters()[0].ParameterType);\n                                var handlers = matchMethod.GetParameters()\n                                    .Select(p => p.ParameterType.GenericTypeArguments[0])\n                                    .Select(t => (ParameterExpr: System.Linq.Expressions.Expression.Parameter(t), ParameterExprType: t))\n                                    .Select(t =>\n                                    {\n                                        var delegateType = typeof(System.Func<,>).MakeGenericType(t.ParameterExprType, tupleType);\n                                        System.Linq.Expressions.Expression expression = targetFactoryMap.TryGetValue(t.ParameterExprType, out var factory)\n                                            ? System.Linq.Expressions.Expression.New(tupleType.GetConstructors()[0], System.Linq.Expressions.Expression.Constant(true), System.Linq.Expressions.Expression.Call(factory, t.ParameterExpr))\n                                            : System.Linq.Expressions.Expression.Default(tupleType);\n                                        return System.Linq.Expressions.Expression.Lambda(delegateType, expression, t.ParameterExpr);\n                                    }\n                                    );var paramExpr = System.Linq.Expressions.Expression.Parameter(sourceType);\n                                var callExpr = System.Linq.Expressions.Expression.Call(paramExpr, matchMethod, handlers);\n                                var lambdaExpr = System.Linq.Expressions.Expression.Lambda(callExpr, paramExpr);\n                                var result = lambdaExpr.Compile();\n                                return result;\n                            }\n                            );\n                        }\n                        var match = (System.Func<TValue, (System.Boolean, UnionTypesDemo.ResultSave)>)weakMatch;\n                        var matchResult = match.Invoke(value);\n                        if(!matchResult.Item1)\n                        {\n                            result = default;\n                            return false;\n                        }\n                        result = matchResult.Item2;\n                        return true;\n                    }\n                }\n            }\n        }\n        /// <summary>\n        /// Creates an instance of <see cref="UnionTypesDemo.ResultSave"/> from an instance of <typeparamref name="TValue"/>.\n        /// </summary>\n        /// <param name="value">\n        /// The value from which to create an instance of <see cref="UnionTypesDemo.ResultSave"/>.\n        /// </param>\n        /// <returns>\n        /// A new instance of <see cref="UnionTypesDemo.ResultSave"/> representing <paramref name="value"/>.\n        /// </returns>\n        public static ResultSave Create<TValue>(TValue value)\n        {\n            var metadataName = RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.GetFullString(typeof(TValue));\n            switch(metadataName)\n            {\n                case "UnionTypesDemo.Success":\n                {\n                    return CreateFromSuccess((RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<TValue, UnionTypesDemo.Success>(value)));\n                }\n                \n                case "UnionTypesDemo.ValidationError":\n                {\n                    return CreateFromValidationError((RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<TValue, UnionTypesDemo.ValidationError>(value)));\n                }\n                default:\n                {\n                    \n                    {\n                        var sourceType = typeof(TValue);\n                        if(!UnionTypesDemo_ResultSave_ScopedData.Cache.TryGetValue(sourceType, out var weakMatch))\n                        {\n                            if(!RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.IsMarked(sourceType))\n                            {\n                                throw new System.InvalidOperationException($"Unable to create an instance of UnionTypesDemo.ResultSave from an instance of {typeof(TValue)}.");\n                            }\n                            weakMatch = UnionTypesDemo_ResultSave_ScopedData.Cache.GetOrAdd(sourceType, t =>\n                            {\n                                var tupleType = typeof(System.ValueTuple<System.Boolean, ResultSave>);\n                                var matchMethod = sourceType.GetMethod(nameof(Match), System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public)\n                                    ?.MakeGenericMethod(tupleType) ??\n                                    throw new System.InvalidOperationException("Unable to locate match function on source union type. This indicates a bug in the marker detection algorithm.");\n                                var targetFactoryMap = typeof(UnionTypesDemo.ResultSave).GetMethods()\n                                    .Where(c => c.CustomAttributes.Any(a => a.AttributeType.FullName == "RhoMicro.CodeAnalysis.UnionTypeFactoryAttribute"))\n                                    .ToDictionary(c => c.GetParameters()[0].ParameterType);\n                                var handlers = matchMethod.GetParameters()\n                                    .Select(p => p.ParameterType.GenericTypeArguments[0])\n                                    .Select(t => (ParameterExpr: System.Linq.Expressions.Expression.Parameter(t), ParameterExprType: t))\n                                    .Select(t =>\n                                    {\n                                        var delegateType = typeof(System.Func<,>).MakeGenericType(t.ParameterExprType, tupleType);\n                                        System.Linq.Expressions.Expression expression = targetFactoryMap.TryGetValue(t.ParameterExprType, out var factory)\n                                            ? System.Linq.Expressions.Expression.New(tupleType.GetConstructors()[0], System.Linq.Expressions.Expression.Constant(true), System.Linq.Expressions.Expression.Call(factory, t.ParameterExpr))\n                                            : System.Linq.Expressions.Expression.Default(tupleType);\n                                        return System.Linq.Expressions.Expression.Lambda(delegateType, expression, t.ParameterExpr);\n                                    }\n                                    );var paramExpr = System.Linq.Expressions.Expression.Parameter(sourceType);\n                                var callExpr = System.Linq.Expressions.Expression.Call(paramExpr, matchMethod, handlers);\n                                var lambdaExpr = System.Linq.Expressions.Expression.Lambda(callExpr, paramExpr);\n                                var result = lambdaExpr.Compile();\n                                return result;\n                            }\n                            );\n                        }\n                        var match = (System.Func<TValue, (System.Boolean, UnionTypesDemo.ResultSave)>)weakMatch;\n                        var matchResult = match.Invoke(value);\n                        if(!matchResult.Item1)\n                        {\n                            throw new System.InvalidOperationException($"Unable to create an instance of UnionTypesDemo.ResultSave from an instance of {typeof(TValue)}.");\n                        }\n                        return matchResult.Item2;\n                    }\n                }\n            }\n        }\n        #endregion\n        \n        #region Switch\n        /// <summary>\n        /// Invokes a handler based on the type of value being represented.\n        /// </summary>\n        /// <param name="onSuccess">\n        /// The handler to invoke if the union is currently representing an instance of <see cref="UnionTypesDemo.Success"/>.\n        /// </param>\n        /// <param name="onValidationError">\n        /// The handler to invoke if the union is currently representing an instance of <see cref="UnionTypesDemo.ValidationError"/>.\n        /// </param>\n        public void Switch(\n            System.Action<UnionTypesDemo.Success> onSuccess,\n            System.Action<UnionTypesDemo.ValidationError> onValidationError)\n        {\n            switch(this.__tag)\n            {\n                case __Tag.Success:\n                {\n                    onSuccess.Invoke(((UnionTypesDemo.Success)this.__reference!));\n                    return;\n                }\n                \n                case __Tag.ValidationError:\n                {\n                    onValidationError.Invoke(((UnionTypesDemo.ValidationError)this.__reference!));\n                    return;\n                }\n                \n                default:\n                {\n                    throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.");\n                }\n            }\n        }\n        #endregion\n        \n        #region Match\n        /// <summary>\n        /// Invokes a projection based on the type of value being represented.\n        /// </summary>\n        /// <param name="onSuccess">\n        /// The projection to invoke if the union is currently representing an instance of <see cref="UnionTypesDemo.Success"/>.\n        /// </param>\n        /// <param name="onValidationError">\n        /// The projection to invoke if the union is currently representing an instance of <see cref="UnionTypesDemo.ValidationError"/>.\n        /// </param>\n        /// <typeparam name="TMatchResult">\n        /// The type of value produced by the projections passed.\n        /// </typeparam>\n        /// <returns>\n        /// The projected value.\n        /// </returns>\n        public TMatchResult Match<TMatchResult>(\n            System.Func<UnionTypesDemo.Success, TMatchResult> onSuccess,\n            System.Func<UnionTypesDemo.ValidationError, TMatchResult> onValidationError) =>\n        this.__tag switch\n        {\n            __Tag.Success => onSuccess.Invoke(((UnionTypesDemo.Success)this.__reference!))\n            ,\n            __Tag.ValidationError => onValidationError.Invoke(((UnionTypesDemo.ValidationError)this.__reference!))\n            ,\n            _ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n        }\n        ;\n        #endregion\n        \n        #region Represented Type\n        /// <summary>\n        /// Gets the types of value this union type can represent.\n        /// </summary>\n        public static System.Collections.Generic.IReadOnlyCollection<System.Type> RepresentableTypes { get; } = \n            UnionTypesDemo_ResultSave_ScopedData.RepresentableTypes;\n        /// <summary>\n        /// Gets the type of value represented by this instance.\n        /// </summary>\n        public System.Type RepresentedType => \n        this.__tag switch\n        {\n            __Tag.Success => typeof(UnionTypesDemo.Success),\n            __Tag.ValidationError => typeof(UnionTypesDemo.ValidationError),\n            _ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n        }\n        ;\n        #endregion\n        \n        #region Is/As Properties\n        \n        /// <summary>\n        /// Gets a value indicating whether this instance is representing a value of type <see cref="UnionTypesDemo.Success"/>.\n        /// </summary>\n        public System.Boolean IsSuccess => __tag == __Tag.Success;\n        \n        /// <summary>\n        /// Gets a value indicating whether this instance is representing a value of type <see cref="UnionTypesDemo.ValidationError"/>.\n        /// </summary>\n        public System.Boolean IsValidationError => __tag == __Tag.ValidationError;\n        \n        /// <summary>\n        /// Retrieves the value represented by this instance as a <see cref="UnionTypesDemo.Success"/>.\n        /// </summary>\n        public UnionTypesDemo.Success? AsSuccess => __tag == __Tag.Success\n        ? ((UnionTypesDemo.Success)this.__reference!)\n        : null;\n        \n        /// <summary>\n        /// Retrieves the value represented by this instance as a <see cref="UnionTypesDemo.ValidationError"/>.\n        /// </summary>\n        public UnionTypesDemo.ValidationError? AsValidationError => __tag == __Tag.ValidationError\n        ? ((UnionTypesDemo.ValidationError)this.__reference!)\n        : null;\n        #endregion\n        \n        #region Is Group Properties\n        \n        #endregion\n        \n        #region Is/As Functions\n        \n        /// <summary>\n        /// Determines whether this instance is representing a value of type <see cref="UnionTypesDemo.Success"/>.\n        /// </summary>\n        /// <returns>\n        /// <see langword="true"/> if this instance is representing a value of type <see cref="UnionTypesDemo.Success"/>; otherwise, <see langword="false"/>.\n        /// </returns>\n        /// <param name="value">\n        /// If this instance is representing a value of type <see cref="UnionTypesDemo.Success"/>, this parameter will contain that value; otherwise, <see langword="default"/>.\n        /// </param>\n        public System.Boolean TryAsSuccess([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out UnionTypesDemo.Success value)\n        {\n            if(this.__tag == __Tag.Success)\n            {\n                value = ((UnionTypesDemo.Success)this.__reference!);\n                return true;\n            }\n            value = default;\n            return false;\n        }\n        \n        /// <summary>\n        /// Determines whether this instance is representing a value of type <see cref="UnionTypesDemo.ValidationError"/>.\n        /// </summary>\n        /// <returns>\n        /// <see langword="true"/> if this instance is representing a value of type <see cref="UnionTypesDemo.ValidationError"/>; otherwise, <see langword="false"/>.\n        /// </returns>\n        /// <param name="value">\n        /// If this instance is representing a value of type <see cref="UnionTypesDemo.ValidationError"/>, this parameter will contain that value; otherwise, <see langword="default"/>.\n        /// </param>\n        public System.Boolean TryAsValidationError([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out UnionTypesDemo.ValidationError value)\n        {\n            if(this.__tag == __Tag.ValidationError)\n            {\n                value = ((UnionTypesDemo.ValidationError)this.__reference!);\n                return true;\n            }\n            value = default;\n            return false;\n        }\n        /// <summary>\n        /// Determines whether this instance is representing a value of type <typeparamref name="TValue"/>.\n        /// </summary>\n        /// <typeparam name="TValue">\n        /// The type whose representation in this instance to determine.\n        /// </typeparam>\n        /// <returns>\n        /// <see langword="true"/> if this instance is representing a value of type <typeparamref name="TValue"/>; otherwise, <see langword="false"/>.\n        /// </returns>\n        public System.Boolean Is<TValue>() =>typeof(TValue) ==this.__tag switch\n        {\n            __Tag.Success => typeof(UnionTypesDemo.Success),\n            __Tag.ValidationError => typeof(UnionTypesDemo.ValidationError),\n            _ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n        }\n        ;\n        /// <summary>\n        /// Determines whether this instance is representing a value of type <typeparamref name="TValue"/>.\n        /// </summary>\n        /// <param name="value">\n        /// If this instance is representing a value of type <typeparamref name="TValue"/>, this parameter will contain that value; otherwise, <see langword="default"/>.\n        /// </param>\n        /// <typeparam name="TValue">\n        /// The type whose representation in this instance to determine.\n        /// </typeparam>\n        /// <returns>\n        /// <see langword="true"/> if this instance is representing a value of type <typeparamref name="TValue"/>; otherwise, <see langword="false"/>.\n        /// </returns>\n        public System.Boolean Is<TValue>(out TValue? value)\n        {\n            var metadataName = RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.GetFullString(typeof(TValue));\n            switch(metadataName)\n            {\n                case "UnionTypesDemo.Success":\n                {\n                    value = (RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<UnionTypesDemo.Success, TValue>((UnionTypesDemo.Success)this.__reference!));\n                    return true;\n                }\n                \n                case "UnionTypesDemo.ValidationError":\n                {\n                    value = (RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<UnionTypesDemo.ValidationError, TValue>((UnionTypesDemo.ValidationError)this.__reference!));\n                    return true;\n                }\n                default:\n                {\n                    \n                    {\n                        value = default;\n                        return false;\n                    }\n                }\n            }\n        }\n        /// <summary>\n        /// Determines whether this instance is representing an instance of <paramref name="type"/>.\n        /// </summary>\n        /// <param name="type">\n        /// The type whose representation in this instance to determine.\n        /// </param>\n        /// <returns>\n        /// <see langword="true"/> if this instance is representing an instance of <paramref name="type"/>; otherwise, <see langword="false"/>.\n        /// </returns>\n        public System.Boolean Is(System.Type type) =>\n        type == this.__tag switch\n        {\n            __Tag.Success => typeof(UnionTypesDemo.Success),\n            __Tag.ValidationError => typeof(UnionTypesDemo.ValidationError),\n            _ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n        }\n        ;\n        /// <summary>\n        /// Retrieves the value represented by this instance as an instance of <typeparamref name="TValue"/>.\n        /// </summary>\n        /// <typeparam name="TValue">\n        /// The type to retrieve the represented value as.\n        /// </typeparam>\n        /// <returns>\n        /// The currently represented value as an instance of <typeparamref name="TValue"/>.\n        /// </returns>\n        public TValue As<TValue>() =>\n        this.__tag switch\n        {\n            __Tag.Success => typeof(TValue) == typeof(UnionTypesDemo.Success)\n            ? (RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<UnionTypesDemo.Success, TValue>((UnionTypesDemo.Success)this.__reference!))\n            : throw new System.InvalidOperationException($"Unable to convert from an instance of {typeof(UnionTypesDemo.ResultSave)} representing a value of type {this.RepresentedType} to an instance of {typeof(TValue)}."),\n            __Tag.ValidationError => typeof(TValue) == typeof(UnionTypesDemo.ValidationError)\n            ? (RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<UnionTypesDemo.ValidationError, TValue>((UnionTypesDemo.ValidationError)this.__reference!))\n            : throw new System.InvalidOperationException($"Unable to convert from an instance of {typeof(UnionTypesDemo.ResultSave)} representing a value of type {this.RepresentedType} to an instance of {typeof(TValue)}."),\n            _ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n        }\n        ;\n        #endregion\n        \n        #region ToString\n        /// <inheritdoc/>\n        public override System.String ToString()\n        {\n            var stringRepresentation = this.__tag switch\n            {\n                __Tag.Success => ((this.__reference!)?.ToString() ?? System.String.Empty),\n                __Tag.ValidationError => ((this.__reference!)?.ToString() ?? System.String.Empty),\n                _ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n            }\n            ;\n            var result = $"ResultSave({(__tag == __Tag.Success ? "<Success>" : "Success")}|{(__tag == __Tag.ValidationError ? "<ValidationError>" : "ValidationError")}){{{stringRepresentation}}}";\n            return result;\n        }\n        #endregion\n        \n        #region GetHashCode\n        /// <inheritdoc/>\n        public override System.Int32 GetHashCode() => \n        this.__tag switch\n        {\n            __Tag.Success => (System.Collections.Generic.EqualityComparer<UnionTypesDemo.Success>.Default.GetHashCode(((UnionTypesDemo.Success)this.__reference!))),\n            __Tag.ValidationError => (System.Collections.Generic.EqualityComparer<UnionTypesDemo.ValidationError>.Default.GetHashCode(((UnionTypesDemo.ValidationError)this.__reference!))),\n            _ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n        }\n        ;\n        #endregion\n        \n        #region Equality\n        /// <inheritdoc/>\n        public override System.Boolean Equals(System.Object? obj) =>\n            obj is ResultSave union && Equals(union);\n        /// <inheritdoc/>\n        public System.Boolean Equals(ResultSave? other) =>\n            ReferenceEquals(other, this)\n            || other != null\n            && this.__tag == other.__tag\n            && this.__tag switch\n            {\n                __Tag.Success => (System.Collections.Generic.EqualityComparer<UnionTypesDemo.Success>.Default.Equals(((UnionTypesDemo.Success)this.__reference!), ((UnionTypesDemo.Success)other.__reference!))),\n                __Tag.ValidationError => (System.Collections.Generic.EqualityComparer<UnionTypesDemo.ValidationError>.Default.Equals(((UnionTypesDemo.ValidationError)this.__reference!), ((UnionTypesDemo.ValidationError)other.__reference!))),\n                _ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n            }\n            ;\n        \n        #endregion\n        \n        #region Conversions\n        \n        #region Representable Type Conversions\n        \n        /// <summary>\n        /// Converts an instance of the representable type <see cref="UnionTypesDemo.Success"/> to the union type <see cref="UnionTypesDemo.ResultSave"/>.\n        /// </summary>\n        /// <param name="value">\n        /// The value to convert.\n        /// </param>\n        /// <returns>\n        /// The union type instance.\n        /// </returns>\n        public static implicit operator ResultSave(UnionTypesDemo.Success value) => CreateFromSuccess(value);\n        /// <summary>\n        /// Converts an instance of the union type <see cref="UnionTypesDemo.ResultSave"/> to the representable type <see cref="UnionTypesDemo.Success"/>.\n        /// </summary>\n        /// <param name="union">\n        /// The union to convert.\n        /// </param>\n        /// <returns>\n        /// The represented value.\n        /// </returns>\n        public static explicit operator UnionTypesDemo.Success(UnionTypesDemo.ResultSave union) =>union.__tag == __Tag.Success?\n        ((UnionTypesDemo.Success)union.__reference!):throw new System.InvalidOperationException($"Unable to convert from an instance of {typeof(ResultSave)} representing a value of type {union.RepresentedType} to an instance of {typeof(UnionTypesDemo.Success)}.");\n        \n        /// <summary>\n        /// Converts an instance of the representable type <see cref="UnionTypesDemo.ValidationError"/> to the union type <see cref="UnionTypesDemo.ResultSave"/>.\n        /// </summary>\n        /// <param name="value">\n        /// The value to convert.\n        /// </param>\n        /// <returns>\n        /// The union type instance.\n        /// </returns>\n        public static implicit operator ResultSave(UnionTypesDemo.ValidationError value) => CreateFromValidationError(value);\n        /// <summary>\n        /// Converts an instance of the union type <see cref="UnionTypesDemo.ResultSave"/> to the representable type <see cref="UnionTypesDemo.ValidationError"/>.\n        /// </summary>\n        /// <param name="union">\n        /// The union to convert.\n        /// </param>\n        /// <returns>\n        /// The represented value.\n        /// </returns>\n        public static explicit operator UnionTypesDemo.ValidationError(UnionTypesDemo.ResultSave union) =>union.__tag == __Tag.ValidationError?\n        ((UnionTypesDemo.ValidationError)union.__reference!):throw new System.InvalidOperationException($"Unable to convert from an instance of {typeof(ResultSave)} representing a value of type {union.RepresentedType} to an instance of {typeof(UnionTypesDemo.ValidationError)}.");\n        #endregion\n        \n        #region Related Type Conversions\n        #endregion\n        #endregion\n    }\n}\n#endregion\n\n')))),(0,r.kt)("h2",{id:"usefull"},"Usefull"),(0,r.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{target:"_blank",href:t(9226).Z},"Download Example project UnionsGenerator "))),(0,r.kt)("h3",{id:"share-unionsgenerator"},"Share UnionsGenerator"),(0,r.kt)("ul",null,(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator&quote=UnionsGenerator",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator&text=UnionsGenerator:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator&title=UnionsGenerator",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator&title=UnionsGenerator&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/UnionsGenerator"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/UnionsGenerator")),(0,r.kt)("h3",{id:"in-the-same-category-functionalprogramming---15-other-generators"},"In the same category (FunctionalProgramming) - 15 other generators"),(0,r.kt)("h4",{id:"cachesourcegenerator"},(0,r.kt)("a",{parentName:"h4",href:"/docs/cachesourcegenerator"},"cachesourcegenerator")),(0,r.kt)("h4",{id:"dunet"},(0,r.kt)("a",{parentName:"h4",href:"/docs/dunet"},"dunet")),(0,r.kt)("h4",{id:"dusharp"},(0,r.kt)("a",{parentName:"h4",href:"/docs/Dusharp"},"Dusharp")),(0,r.kt)("h4",{id:"funckydiscriminatedunion"},(0,r.kt)("a",{parentName:"h4",href:"/docs/Funcky.DiscriminatedUnion"},"Funcky.DiscriminatedUnion")),(0,r.kt)("h4",{id:"funicularswitch"},(0,r.kt)("a",{parentName:"h4",href:"/docs/FunicularSwitch"},"FunicularSwitch")),(0,r.kt)("h4",{id:"nsourcegeneratorsuniontypes"},(0,r.kt)("a",{parentName:"h4",href:"/docs/N.SourceGenerators.UnionTypes"},"N.SourceGenerators.UnionTypes")),(0,r.kt)("h4",{id:"oneof"},(0,r.kt)("a",{parentName:"h4",href:"/docs/OneOf"},"OneOf")),(0,r.kt)("h4",{id:"partiallyapplied"},(0,r.kt)("a",{parentName:"h4",href:"/docs/PartiallyApplied"},"PartiallyApplied")),(0,r.kt)("h4",{id:"polytype"},(0,r.kt)("a",{parentName:"h4",href:"/docs/polytype"},"polytype")),(0,r.kt)("h4",{id:"rscg_demeter"},(0,r.kt)("a",{parentName:"h4",href:"/docs/rscg_demeter"},"rscg_demeter")),(0,r.kt)("h4",{id:"rscg_queryables"},(0,r.kt)("a",{parentName:"h4",href:"/docs/rscg_queryables"},"rscg_queryables")),(0,r.kt)("h4",{id:"rscg_utils_memo"},(0,r.kt)("a",{parentName:"h4",href:"/docs/RSCG_Utils_Memo"},"RSCG_Utils_Memo")),(0,r.kt)("h4",{id:"seraunion"},(0,r.kt)("a",{parentName:"h4",href:"/docs/Sera.Union"},"Sera.Union")),(0,r.kt)("h4",{id:"typeutilities"},(0,r.kt)("a",{parentName:"h4",href:"/docs/TypeUtilities"},"TypeUtilities")),(0,r.kt)("h4",{id:"uniongen"},(0,r.kt)("a",{parentName:"h4",href:"/docs/UnionGen"},"UnionGen")))}h.isMDXComponent=!0},9226:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/UnionsGenerator-f2b056f28cc1754214c60350f76aeb6d.zip"}}]);