"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[3701],{726:(e,n,o)=>{o.d(n,{A:()=>s});const s=o.p+"assets/files/ConsoleAppFramework-269c8d924f792f32c4465765f5074000.zip"},2339:(e,n,o)=>{o.d(n,{Ay:()=>t,RM:()=>a});var s=o(74848),r=o(28453);const a=[{value:"Category &quot;Console&quot; has the following generators:",id:"category-console-has-the-following-generators",level:3},{value:"See category",id:"see-category",level:3}];function i(e){const n={a:"a",h3:"h3",p:"p",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"category-console-has-the-following-generators",children:'Category "Console" has the following generators:'}),"\n",(0,s.jsxs)(n.p,{children:["1 ",(0,s.jsx)(n.a,{href:"/docs/ConsoleAppFramework",children:"ConsoleAppFramework"})]}),"\n",(0,s.jsxs)(n.p,{children:["2 ",(0,s.jsx)(n.a,{href:"/docs/Figgle",children:"Figgle"})]}),"\n",(0,s.jsx)(n.h3,{id:"see-category",children:"See category"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/docs/Categories/Console",children:"Console"})})]})}function t(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}},66301:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>m,contentTitle:()=>p,default:()=>g,frontMatter:()=>d,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"RSCG-Examples/ConsoleAppFramework","title":"232 - ConsoleAppFramework","description":"Generating console parser for functions","source":"@site/docs/RSCG-Examples/ConsoleAppFramework.md","sourceDirName":"RSCG-Examples","slug":"/ConsoleAppFramework","permalink":"/RSCG_Examples/v2/docs/ConsoleAppFramework","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2320,"frontMatter":{"sidebar_position":2320,"title":"232 - ConsoleAppFramework","description":"Generating console parser for functions","slug":"/ConsoleAppFramework"},"sidebar":"tutorialSidebar","previous":{"title":"231 - kli.Localize","permalink":"/RSCG_Examples/v2/docs/kli.Localize"},"next":{"title":"233 - VYaml","permalink":"/RSCG_Examples/v2/docs/VYaml"}}');var r=o(74848),a=o(28453),i=o(11470),t=o(19365),l=o(14252),c=o(2339);const d={sidebar_position:2320,title:"232 - ConsoleAppFramework",description:"Generating console parser for functions",slug:"/ConsoleAppFramework"},p="ConsoleAppFramework  by Cysharp, Inc.",m={},h=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Author",id:"author",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Option aliases and Help, Version",id:"option-aliases-and-help-version",level:2},{value:"Command",id:"command",level:2},{value:"Nested command",id:"nested-command",level:3},{value:"Register from attribute",id:"register-from-attribute",level:3},{value:"Performance of Commands",id:"performance-of-commands",level:3},{value:"Disable Naming Conversion",id:"disable-naming-conversion",level:2},{value:"Parse and Value Binding",id:"parse-and-value-binding",level:2},{value:"Array",id:"array",level:3},{value:"Object",id:"object",level:3},{value:"Custom Value Converter",id:"custom-value-converter",level:3},{value:"Double-dash escaping",id:"double-dash-escaping",level:3},{value:"Syntax Parsing Policy and Performance",id:"syntax-parsing-policy-and-performance",level:3},{value:"CancellationToken(Gracefully Shutdown) and Timeout",id:"cancellationtokengracefully-shutdown-and-timeout",level:2},{value:"Exit Code",id:"exit-code",level:2},{value:"Attribute based parameters validation",id:"attribute-based-parameters-validation",level:2},{value:"Hide command/parameter help",id:"hide-commandparameter-help",level:2},{value:"Filter(Middleware) Pipeline / ConsoleAppContext",id:"filtermiddleware-pipeline--consoleappcontext",level:2},{value:"Sharing Filters Between Projects",id:"sharing-filters-between-projects",level:3},{value:"Performance of filter",id:"performance-of-filter",level:3},{value:"Dependency Injection(Logging, Configuration, etc...)",id:"dependency-injectionlogging-configuration-etc",level:2},{value:"OpenTelemetry",id:"opentelemetry",level:2},{value:"Prevent ServiceProvider auto dispose",id:"prevent-serviceprovider-auto-dispose",level:2},{value:"Colorize",id:"colorize",level:2},{value:"Publish to executable file",id:"publish-to-executable-file",level:2},{value:"v4 -&gt; v5 Migration Guide",id:"v4---v5-migration-guide",level:2},{value:"License",id:"license",level:2},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example (source csproj, source files)",id:"example-source-csproj-source-files",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C#)",id:"download-example-net--c",level:3},{value:"Share ConsoleAppFramework",id:"share-consoleappframework",level:3},...c.RM];function u(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"consoleappframework--by-cysharp-inc",children:"ConsoleAppFramework  by Cysharp, Inc."})}),"\n",(0,r.jsx)(l.A,{toc:h}),"\n",(0,r.jsx)(n.h2,{id:"nuget--site-data",children:"NuGet / site data"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://www.nuget.org/packages/ConsoleAppFramework/",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/nuget/dt/ConsoleAppFramework?label=ConsoleAppFramework",alt:"Nuget"})}),"\n",(0,r.jsx)(n.a,{href:"https://github.com/Cysharp/ConsoleAppFramework",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/github/last-commit/Cysharp/ConsoleAppFramework?label=updated",alt:"GitHub last commit"})}),"\n",(0,r.jsx)(n.img,{src:"https://img.shields.io/github/stars/Cysharp/ConsoleAppFramework?style=social",alt:"GitHub Repo stars"})]}),"\n",(0,r.jsx)(n.h2,{id:"details",children:"Details"}),"\n",(0,r.jsx)(n.h3,{id:"info",children:"Info"}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:["Name: ",(0,r.jsx)(n.strong,{children:"ConsoleAppFramework"})]}),(0,r.jsx)(n.p,{children:"Micro-framework for console applications."}),(0,r.jsx)(n.p,{children:"Author: Cysharp, Inc."}),(0,r.jsxs)(n.p,{children:["NuGet:\n",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.a,{href:"https://www.nuget.org/packages/ConsoleAppFramework/",children:"https://www.nuget.org/packages/ConsoleAppFramework/"})})]}),(0,r.jsxs)(n.p,{children:["You can find more details at ",(0,r.jsx)(n.a,{href:"https://github.com/Cysharp/ConsoleAppFramework",children:"https://github.com/Cysharp/ConsoleAppFramework"})]}),(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.a,{href:"https://github.com/Cysharp/ConsoleAppFramework",children:"https://github.com/Cysharp/ConsoleAppFramework"})]})]}),"\n",(0,r.jsx)(n.h3,{id:"author",children:"Author"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Cysharp, Inc.\n",(0,r.jsx)(n.img,{src:"https://github.com/Cysharp.png",alt:"Alt text"})]})}),"\n",(0,r.jsx)(n.h3,{id:"original-readme",children:"Original Readme"}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.h1,{id:"consoleappframework",children:"ConsoleAppFramework"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/Cysharp/ConsoleAppFramework/actions",children:(0,r.jsx)(n.img,{src:"https://github.com/Cysharp/ConsoleAppFramework/workflows/Build-Debug/badge.svg",alt:"GitHub Actions"})})," ",(0,r.jsx)(n.a,{href:"https://github.com/Cysharp/ConsoleAppFramework/releases",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/github/release/Cysharp/ConsoleAppFramework.svg",alt:"Releases"})})]}),(0,r.jsxs)(n.p,{children:["ConsoleAppFramework v5 is Zero Dependency, Zero Overhead, Zero Reflection, Zero Allocation, AOT Safe CLI Framework powered by C# Source Generator; achieves exceptionally high performance, fastest start-up time(with NativeAOT) and minimal binary size. Leveraging the latest features of .NET 8 and C# 13 (",(0,r.jsx)(n.a,{href:"https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md",children:"IncrementalGenerator"}),", ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers#function-pointers-1",children:"managed function pointer"}),", ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#input-parameters-of-a-lambda-expression",children:"params arrays and default values lambda expression"}),", ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.ispanparsable-1",children:(0,r.jsx)(n.code,{children:"ISpanParsable<T>"})}),", ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignalregistration",children:(0,r.jsx)(n.code,{children:"PosixSignalRegistration"})}),", etc.), this library ensures maximum performance while maintaining flexibility and extensibility."]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://github.com/Cysharp/ConsoleAppFramework/assets/46207/db4bf599-9fe0-4ce4-801f-0003f44d5628",alt:"image"})}),(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Set ",(0,r.jsx)(n.code,{children:"RunStrategy=ColdStart WarmupCount=0"})," to calculate the cold start benchmark, which is suitable for CLI application."]}),"\n"]}),(0,r.jsx)(n.p,{children:"The magical performance is achieved by statically generating everything and parsing inline. Let's take a look at a minimal example:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using ConsoleAppFramework;\n\n// args: ./cmd --foo 10 --bar 20\nConsoleApp.Run(args, (int foo, int bar) => Console.WriteLine($"Sum: {foo + bar}"));\n'})}),(0,r.jsx)(n.p,{children:"Unlike typical Source Generators that use attributes as keys for generation, ConsoleAppFramework analyzes the provided lambda expressions or method references and generates the actual code body of the Run method."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"internal static partial class ConsoleApp\n{\n    // Generate the Run method itself with arguments and body to match the lambda expression\n    public static void Run(string[] args, Action<int, int> command)\n    {\n        // code body\n    }\n}\n"})}),(0,r.jsx)(s,{children:(0,r.jsx)("summary",{children:"Full generated source code"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'namespace ConsoleAppFramework;\n\ninternal static partial class ConsoleApp\n{\n    public static void Run(string[] args, Action<int, int> command)\n    {\n        if (TryShowHelpOrVersion(args, 2, -1)) return;\n\n        var arg0 = default(int);\n        var arg0Parsed = false;\n        var arg1 = default(int);\n        var arg1Parsed = false;\n\n        try\n        {\n            for (int i = 0; i < args.Length; i++)\n            {\n                var name = args[i];\n\n                switch (name)\n                {\n                    case "--foo":\n                    {\n                        if (!TryIncrementIndex(ref i, args.Length) || !int.TryParse(args[i], out arg0)) \\{ ThrowArgumentParseFailed("foo", args[i]); }\n                        arg0Parsed = true;\n                        break;\n                    }\n                    case "--bar":\n                    {\n                        if (!TryIncrementIndex(ref i, args.Length) || !int.TryParse(args[i], out arg1)) \\{ ThrowArgumentParseFailed("bar", args[i]); }\n                        arg1Parsed = true;\n                        break;\n                    }\n                    default:\n                        if (string.Equals(name, "--foo", StringComparison.OrdinalIgnoreCase))\n                        {\n                            if (!TryIncrementIndex(ref i, args.Length) || !int.TryParse(args[i], out arg0)) \\{ ThrowArgumentParseFailed("foo", args[i]); }\n                            arg0Parsed = true;\n                            break;\n                        }\n                        if (string.Equals(name, "--bar", StringComparison.OrdinalIgnoreCase))\n                        {\n                            if (!TryIncrementIndex(ref i, args.Length) || !int.TryParse(args[i], out arg1)) \\{ ThrowArgumentParseFailed("bar", args[i]); }\n                            arg1Parsed = true;\n                            break;\n                        }\n                        ThrowArgumentNameNotFound(name);\n                        break;\n                }\n            }\n            if (!arg0Parsed) ThrowRequiredArgumentNotParsed("foo");\n            if (!arg1Parsed) ThrowRequiredArgumentNotParsed("bar");\n\n            command(arg0!, arg1!);\n        }\n        catch (Exception ex)\n        {\n            Environment.ExitCode = 1;\n            if (ex is ValidationException or ArgumentParseFailedException)\n            {\n                LogError(ex.Message);\n            }\n            else\n            {\n                LogError(ex.ToString());\n            }\n        }\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    static bool TryIncrementIndex(ref int index, int length)\n    {\n        if (index < length)\n        {\n            index++;\n            return true;\n        }\n        return false;\n    }\n\n    static partial void ShowHelp(int helpId)\n    {\n        Log("""\nUsage: [options...] [-h|--help] [--version]\n\nOptions:\n  --foo <int>     (Required)\n  --bar <int>     (Required)\n""");\n    }\n}\n'})}),(0,r.jsxs)(n.p,{children:["As you can see, the code is straightforward and simple, making it easy to imagine the execution cost of the framework portion. That's right, it's zero. This technique was influenced by Rust's macros. Rust has ",(0,r.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch19-06-macros.html",children:"Attribute-like macros and Function-like macros"}),", and ConsoleAppFramework's generation can be considered as Function-like macros."]}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ConsoleApp"})," class, along with everything else, is generated entirely by the Source Generator, resulting in no dependencies, including ConsoleAppFramework itself. This characteristic should contribute to the small assembly size and ease of handling, including support for Native AOT."]}),(0,r.jsx)(n.p,{children:"Moreover, CLI applications typically involve single-shot execution from a cold start. As a result, common optimization techniques such as dynamic code generation (IL Emit, ExpressionTree.Compile) and caching (ArrayPool) do not work effectively. ConsoleAppFramework generates everything statically in advance, achieving performance equivalent to optimized hand-written code without reflection or boxing."}),(0,r.jsx)(n.p,{children:"ConsoleAppFramework offers a rich set of features as a framework. The Source Generator analyzes which modules are being used and generates the minimal code necessary to implement the desired functionality."}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["SIGINT/SIGTERM(Ctrl+C) handling with gracefully shutdown via ",(0,r.jsx)(n.code,{children:"CancellationToken"})]}),"\n",(0,r.jsx)(n.li,{children:"Filter(middleware) pipeline to intercept before/after execution"}),"\n",(0,r.jsx)(n.li,{children:"Exit code management"}),"\n",(0,r.jsx)(n.li,{children:"Support for async commands"}),"\n",(0,r.jsx)(n.li,{children:"Registration of multiple commands"}),"\n",(0,r.jsx)(n.li,{children:"Registration of nested commands"}),"\n",(0,r.jsx)(n.li,{children:"Setting option aliases and descriptions from code document comment"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"System.ComponentModel.DataAnnotations"})," attribute-based Validation"]}),"\n",(0,r.jsx)(n.li,{children:"Dependency Injection for command registration by type and public methods"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Microsoft.Extensions"}),"(Logging, Configuration, etc...) integration"]}),"\n",(0,r.jsxs)(n.li,{children:["High performance value parsing via ",(0,r.jsx)(n.code,{children:"ISpanParsable<T>"})]}),"\n",(0,r.jsx)(n.li,{children:"Parsing of params arrays"}),"\n",(0,r.jsx)(n.li,{children:"Parsing of JSON arguments"}),"\n",(0,r.jsx)(n.li,{children:"Double-dash escape arguments"}),"\n",(0,r.jsxs)(n.li,{children:["Help(",(0,r.jsx)(n.code,{children:"-h|--help"}),") option builder"]}),"\n",(0,r.jsxs)(n.li,{children:["Default show version(",(0,r.jsx)(n.code,{children:"--version"}),") option"]}),"\n"]}),(0,r.jsx)(n.p,{children:"As you can see from the generated output, the help display is also fast. In typical frameworks, the help string is constructed after the help invocation. However, in ConsoleAppFramework, the help is embedded as string constants, achieving the absolute maximum performance that cannot be surpassed!"}),(0,r.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),(0,r.jsx)(n.p,{children:"This library is distributed via NuGet, minimal requirement is .NET 8 and C# 13."}),(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["dotnet add package ",(0,r.jsx)(n.a,{href:"https://www.nuget.org/packages/ConsoleAppFramework",children:"ConsoleAppFramework"})]}),"\n"]}),(0,r.jsxs)(n.p,{children:["ConsoleAppFramework is an analyzer (Source Generator) and does not have any dll references. When referenced, the entry point class ",(0,r.jsx)(n.code,{children:"ConsoleAppFramework.ConsoleApp"})," is generated internally."]}),(0,r.jsxs)(n.p,{children:["The first argument of ",(0,r.jsx)(n.code,{children:"Run"})," or ",(0,r.jsx)(n.code,{children:"RunAsync"})," can be ",(0,r.jsx)(n.code,{children:"string[] args"}),", and the second argument can be any lambda expression, method, or function reference. Based on the content of the second argument, the corresponding function is automatically generated."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using ConsoleAppFramework;\n\nConsoleApp.Run(args, (string name) => Console.WriteLine($"Hello {name}"));\n'})}),(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"When using .NET 8, you need to explicitly set LangVersion to 13 or above."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:" <PropertyGroup>\n     <TargetFramework>net8.0</TargetFramework>\n     <LangVersion>13</LangVersion>\n </PropertyGroup>\n"})}),"\n"]}),(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:'The latest Visual Studio changed the execution timing of Source Generators to either during save or at compile time. If you encounter unexpected behavior, try compiling once or change the option to "Automatic" under TextEditor -> C# -> Advanced -> Source Generators.'}),"\n"]}),(0,r.jsxs)(n.p,{children:["You can execute command like ",(0,r.jsx)(n.code,{children:'sampletool --name "foo"'}),"."]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The return value can be ",(0,r.jsx)(n.code,{children:"void"}),", ",(0,r.jsx)(n.code,{children:"int"}),", ",(0,r.jsx)(n.code,{children:"Task"}),", or ",(0,r.jsx)(n.code,{children:"Task<int>"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If an ",(0,r.jsx)(n.code,{children:"int"})," is returned, that value will be set to ",(0,r.jsx)(n.code,{children:"Environment.ExitCode"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["By default, option argument names are converted to ",(0,r.jsx)(n.code,{children:"--lower-kebab-case"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For example, ",(0,r.jsx)(n.code,{children:"jsonValue"})," becomes ",(0,r.jsx)(n.code,{children:"--json-value"})]}),"\n",(0,r.jsx)(n.li,{children:"Option argument names are case-insensitive, but lower-case matches faster"}),"\n"]}),"\n"]}),"\n"]}),(0,r.jsx)(n.p,{children:"When passing a method, you can write it as follows:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"ConsoleApp.Run(args, Sum);\n\nvoid Sum(int x, int y) => Console.Write(x + y);\n"})}),(0,r.jsx)(n.p,{children:"Additionally, for static functions, you can pass them as function pointers. In that case, the managed function pointer arguments will be generated, resulting in maximum performance."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"unsafe\n{\n    ConsoleApp.Run(args, &Sum);\n}\n\nstatic void Sum(int x, int y) => Console.Write(x + y);\n"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public static unsafe void Run(string[] args, delegate* managed<int, int, void> command)\n"})}),(0,r.jsxs)(n.p,{children:["Unfortunately, currently ",(0,r.jsx)(n.a,{href:"https://github.com/dotnet/csharplang/discussions/6746",children:"static lambdas cannot be assigned to function pointers"}),", so defining a named function is necessary."]}),(0,r.jsxs)(n.p,{children:["When defining an asynchronous method using a lambda expression, the ",(0,r.jsx)(n.code,{children:"async"})," keyword is required."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// --foo, --bar\nawait ConsoleApp.RunAsync(args, async (int foo, int bar, CancellationToken cancellationToken) =>\n{\n    await Task.Delay(TimeSpan.FromSeconds(5), cancellationToken);\n    Console.WriteLine($"Sum: {foo + bar}");\n});\n'})}),(0,r.jsxs)(n.p,{children:["You can use either the ",(0,r.jsx)(n.code,{children:"Run"})," or ",(0,r.jsx)(n.code,{children:"RunAsync"})," method for invocation. It is optional to use ",(0,r.jsx)(n.code,{children:"CancellationToken"})," as an argument. This becomes a special parameter and is excluded from the command options. Internally, it uses ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignalregistration",children:(0,r.jsx)(n.code,{children:"PosixSignalRegistration"})})," to handle ",(0,r.jsx)(n.code,{children:"SIGINT"}),", ",(0,r.jsx)(n.code,{children:"SIGTERM"}),", and ",(0,r.jsx)(n.code,{children:"SIGKILL"}),". When these signals are invoked (e.g., Ctrl+C), the CancellationToken is set to CancellationRequested. If ",(0,r.jsx)(n.code,{children:"CancellationToken"})," is not used as an argument, these signals will not be handled, and the program will terminate immediately. For more details, refer to the ",(0,r.jsx)(n.a,{href:"#cancellationtokengracefully-shutdown-and-timeout",children:"CancellationToken and Gracefully Shutdown"})," section."]}),(0,r.jsx)(n.h2,{id:"option-aliases-and-help-version",children:"Option aliases and Help, Version"}),(0,r.jsxs)(n.p,{children:["By default, if ",(0,r.jsx)(n.code,{children:"-h"})," or ",(0,r.jsx)(n.code,{children:"--help"})," is provided, or if no arguments are passed, the help display will be invoked."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'ConsoleApp.Run(args, (string message) => Console.Write($"Hello, {message}"));\n'})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-txt",children:"Usage: [options...] [-h|--help] [--version]\n\nOptions:\n  --message <string>     (Required)\n"})}),(0,r.jsx)(n.p,{children:"In ConsoleAppFramework, instead of using attributes, you can provide descriptions and aliases for functions by writing Document Comments. This avoids the common issue in frameworks where arguments become cluttered with attributes, making the code difficult to read. With this approach, a natural writing style is achieved."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'ConsoleApp.Run(args, Commands.Hello);\n\nstatic class Commands\n{\n    /// <summary>\n    /// Display Hello.\n    /// </summary>\n    /// <param name="message">-m, Message to show.</param>\n    public static void Hello(string message) => Console.Write($"Hello, {message}");\n}\n'})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-txt",children:"Usage: [options...] [-h|--help] [--version]\n\nDisplay Hello.\n\nOptions:\n  -m|--message <string>    Message to show. (Required)\n"})}),(0,r.jsxs)(n.p,{children:["To add aliases to parameters, list the aliases separated by ",(0,r.jsx)(n.code,{children:"|"})," before the comma in the comment. For example, if you write a comment like ",(0,r.jsx)(n.code,{children:"-a|-b|--abcde, Description."}),", then ",(0,r.jsx)(n.code,{children:"-a"}),", ",(0,r.jsx)(n.code,{children:"-b"}),", and ",(0,r.jsx)(n.code,{children:"--abcde"})," will be treated as aliases, and ",(0,r.jsx)(n.code,{children:"Description."})," will be the description."]}),(0,r.jsxs)(n.p,{children:["Unfortunately, due to current C# specifications, lambda expressions and ",(0,r.jsx)(n.a,{href:"https://github.com/dotnet/csharplang/issues/2110",children:"local functions do not support document comments"}),", so a class is required."]}),(0,r.jsxs)(n.p,{children:["In addition to ",(0,r.jsx)(n.code,{children:"-h|--help"}),", there is another special built-in option: ",(0,r.jsx)(n.code,{children:"--version"}),". In default, it displays the ",(0,r.jsx)(n.code,{children:"AssemblyInformationalVersion"})," without source revision or ",(0,r.jsx)(n.code,{children:"AssemblyVersion"}),". You can configure version string by ",(0,r.jsx)(n.code,{children:"ConsoleApp.Version"}),", for example ",(0,r.jsx)(n.code,{children:'ConsoleApp.Version = "2001.9.3f14-preview2";'}),"."]}),(0,r.jsx)(n.h2,{id:"command",children:"Command"}),(0,r.jsxs)(n.p,{children:["If you want to register multiple commands or perform complex operations (such as adding filters), instead of using ",(0,r.jsx)(n.code,{children:"Run/RunAsync"}),", obtain the ",(0,r.jsx)(n.code,{children:"ConsoleAppBuilder"})," using ",(0,r.jsx)(n.code,{children:"ConsoleApp.Create()"}),". Call ",(0,r.jsx)(n.code,{children:"Add"}),", ",(0,r.jsx)(n.code,{children:"Add<T>"}),", or ",(0,r.jsx)(n.code,{children:"UseFilter<T>"})," multiple times on the ",(0,r.jsx)(n.code,{children:"ConsoleAppBuilder"})," to register commands and filters, and finally execute the application using ",(0,r.jsx)(n.code,{children:"Run"})," or ",(0,r.jsx)(n.code,{children:"RunAsync"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'var app = ConsoleApp.Create();\n\napp.Add("", (string msg) => Console.WriteLine(msg));\napp.Add("echo", (string msg) => Console.WriteLine(msg));\napp.Add("sum", (int x, int y) => Console.WriteLine(x + y));\n\n// --msg\n// echo --msg\n// sum --x --y\napp.Run(args);\n'})}),(0,r.jsxs)(n.p,{children:["The first argument of ",(0,r.jsx)(n.code,{children:"Add"})," is the command name. If you specify an empty string ",(0,r.jsx)(n.code,{children:'""'}),", it becomes the root command. Unlike parameters, command names are case-sensitive and cannot have multiple names."]}),(0,r.jsxs)(n.p,{children:["With ",(0,r.jsx)(n.code,{children:"Add<T>"}),", you can add multiple commands at once using a class-based approach, where public methods are treated as commands. If you want to write document comments for multiple commands, this approach allows for cleaner code, so it is recommended. Additionally, as mentioned later, you can also write clean code for Dependency Injection (DI) using constructor injection."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'var app = ConsoleApp.Create();\napp.Add<MyCommands>();\napp.Run(args);\n\npublic class MyCommands\n{\n    /// <summary>Root command test.</summary>\n    /// <param name="msg">-m, Message to show.</param>\n    [Command("")]\n    public void Root(string msg) => Console.WriteLine(msg);\n\n    /// <summary>Display message.</summary>\n    /// <param name="msg">Message to show.</param>\n    public void Echo(string msg) => Console.WriteLine(msg);\n\n    /// <summary>Sum parameters.</summary>\n    /// <param name="x">left value.</param>\n    /// <param name="y">right value.</param>\n    public void Sum(int x, int y) => Console.WriteLine(x + y);\n}\n'})}),(0,r.jsxs)(n.p,{children:["When you check the registered commands with ",(0,r.jsx)(n.code,{children:"--help"}),", it will look like this. Note that you can register multiple ",(0,r.jsx)(n.code,{children:"Add<T>"})," and also add commands using ",(0,r.jsx)(n.code,{children:"Add"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-txt",children:"Usage: [command] [options...] [-h|--help] [--version]\n\nRoot command test.\n\nOptions:\n  -m|--msg <string>    Message to show. (Required)\n\nCommands:\n  echo    Display message.\n  sum     Sum parameters.\n"})}),(0,r.jsxs)(n.p,{children:["By default, the command name is derived from the method name converted to ",(0,r.jsx)(n.code,{children:"lower-kebab-case"}),". However, you can change the name to any desired value using the ",(0,r.jsx)(n.code,{children:"[Command(string commandName)]"})," attribute."]}),(0,r.jsxs)(n.p,{children:["If the class implements ",(0,r.jsx)(n.code,{children:"IDisposable"})," or ",(0,r.jsx)(n.code,{children:"IAsyncDisposable"}),", the Dispose or DisposeAsync method will be called after the command execution."]}),(0,r.jsx)(n.h3,{id:"nested-command",children:"Nested command"}),(0,r.jsxs)(n.p,{children:["You can create a deep command hierarchy by adding commands with paths separated by space(",(0,r.jsx)(n.code,{children:" "}),") when registering them. This allows you to add commands at nested levels."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'var app = ConsoleApp.Create();\n\napp.Add("foo", () => \\{ });\napp.Add("foo bar", () => \\{ });\napp.Add("foo bar barbaz", () => \\{ });\napp.Add("foo baz", () => \\{ });\n\n// Commands:\n//   foo\n//   foo bar\n//   foo bar barbaz\n//   foo baz\napp.Run(args);\n'})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Add<T>"})," can also add commands to a hierarchy by passing a ",(0,r.jsx)(n.code,{children:"string commandPath"})," argument."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'var app = ConsoleApp.Create();\napp.Add<MyCommands>("foo");\n\n// Commands:\n//  foo         Root command test.\n//  foo echo    Display message.\n//  foo sum     Sum parameters.\napp.Run(args);\n'})}),(0,r.jsx)(n.h3,{id:"register-from-attribute",children:"Register from attribute"}),(0,r.jsxs)(n.p,{children:["Instead of using ",(0,r.jsx)(n.code,{children:"Add<T>"}),", you can automatically add commands by applying the ",(0,r.jsx)(n.code,{children:"[RegisterCommands]"})," attribute to a class."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'[RegisterCommands]\npublic class Foo\n{\n    public void Baz(int x)\n    {\n        Console.Write(x);\n    }\n}\n\n[RegisterCommands("bar")]\npublic class Bar\n{\n    public void Baz(int x)\n    {\n        Console.Write(x);\n    }\n}\n'})}),(0,r.jsxs)(n.p,{children:["These are automatically added when using ",(0,r.jsx)(n.code,{children:"ConsoleApp.Create()"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"var app = ConsoleApp.Create();\n\n// Commands:\n//   baz\n//   bar baz\napp.Run(args);\n"})}),(0,r.jsxs)(n.p,{children:["You can also combine this with ",(0,r.jsx)(n.code,{children:"Add"})," or ",(0,r.jsx)(n.code,{children:"Add<T>"})," to add more commands."]}),(0,r.jsx)(n.h3,{id:"performance-of-commands",children:"Performance of Commands"}),(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.code,{children:"ConsoleAppFramework"}),", the number and types of registered commands are statically determined at compile time. For example, let's register the following four commands:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'app.Add("foo", () => \\{ });\napp.Add("foo bar", (int x, int y) => \\{ });\napp.Add("foo bar barbaz", (DateTime dateTime) => \\{ });\napp.Add("foo baz", async (string foo = "test", CancellationToken cancellationToken = default) => \\{ });\n'})}),(0,r.jsx)(n.p,{children:"The Source Generator generates four fields and holds them with specific types."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'partial class ConsoleAppBuilder\n{\n    Action command0 = default!;\n    Action<int, int> command1 = default!;\n    Action<global::System.DateTime> command2 = default!;\n    Func<string, global::System.Threading.CancellationToken, Task> command3 = default!;\n\n    partial void AddCore(string commandName, Delegate command)\n    {\n        switch (commandName)\n        {\n            case "foo":\n                this.command0 = Unsafe.As<Action>(command);\n                break;\n            case "foo bar":\n                this.command1 = Unsafe.As<Action<int, int>>(command);\n                break;\n            case "foo bar barbaz":\n                this.command2 = Unsafe.As<Action<global::System.DateTime>>(command);\n                break;\n            case "foo baz":\n                this.command3 = Unsafe.As<Func<string, global::System.Threading.CancellationToken, Task>>(command);\n                break;\n            default:\n                break;\n        }\n    }\n}\n'})}),(0,r.jsx)(n.p,{children:"This ensures the fastest execution speed without any additional unnecessary allocations such as arrays and without any boxing since it holds static delegate types."}),(0,r.jsx)(n.p,{children:"Command routing also generates a switch of nested string constants."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'partial void RunCore(string[] args)\n{\n    if (args.Length == 0)\n    {\n        ShowHelp(-1);\n        return;\n    }\n    switch (args[0])\n    {\n        case "foo":\n            if (args.Length == 1)\n            {\n                RunCommand0(args, args.AsSpan(1), command0);\n                return;\n            }\n            switch (args[1])\n            {\n                case "bar":\n                    if (args.Length == 2)\n                    {\n                        RunCommand1(args, args.AsSpan(2), command1);\n                        return;\n                    }\n                    switch (args[2])\n                    {\n                        case "barbaz":\n                            RunCommand2(args, args.AsSpan(3), command2);\n                            break;\n                        default:\n                            RunCommand1(args, args.AsSpan(2), command1);\n                            break;\n                    }\n                    break;\n                case "baz":\n                    RunCommand3(args, args.AsSpan(2), command3);\n                    break;\n                default:\n                    RunCommand0(args, args.AsSpan(1), command0);\n                    break;\n            }\n            break;\n        default:\n            ShowHelp(-1);\n            break;\n    }\n}\n'})}),(0,r.jsx)(n.p,{children:"The C# compiler performs complex generation for string constant switches, making them extremely fast, and it would be difficult to achieve faster routing than this."}),(0,r.jsx)(n.h2,{id:"disable-naming-conversion",children:"Disable Naming Conversion"}),(0,r.jsx)(n.p,{children:"Command names and option names are automatically converted to kebab-case by default. While this follows standard command-line tool naming conventions, you might find this conversion inconvenient when creating batch files for internal applications. Therefore, it's possible to disable this conversion at the assembly level."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using ConsoleAppFramework;\n\n[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]\n\nvar app = ConsoleApp.Create();\napp.Add<MyProjectCommand>();\napp.Run(args);\n\npublic class MyProjectCommand\n{\n    public void ExecuteCommand(string fooBarBaz)\n    {\n        Console.WriteLine(fooBarBaz);\n    }\n}\n"})}),(0,r.jsxs)(n.p,{children:["You can disable automatic conversion by using ",(0,r.jsx)(n.code,{children:"[assembly: ConsoleAppFrameworkGeneratorOptions(DisableNamingConversion = true)]"}),". In this case, the command would be ",(0,r.jsx)(n.code,{children:"ExecuteCommand --fooBarBaz"}),"."]}),(0,r.jsx)(n.h2,{id:"parse-and-value-binding",children:"Parse and Value Binding"}),(0,r.jsxs)(n.p,{children:["The method parameter names and types determine how to parse and bind values from the command-line arguments. When using lambda expressions, optional values and ",(0,r.jsx)(n.code,{children:"params"})," arrays supported from C# 12 are also supported."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'ConsoleApp.Run(args, (\n    [Argument]DateTime dateTime,  // Argument\n    [Argument]Guid guidvalue,     // \n    int intVar,                   // required\n    bool boolFlag,                // flag\n    MyEnum enumValue,             // enum\n    int[] array,                  // array\n    MyClass obj,                  // object\n    string optional = "abcde",    // optional\n    double? nullableValue = null, // nullable\n    params string[] paramsArray   // params\n    ) => \\{ });\n'})}),(0,r.jsxs)(n.p,{children:["When using ",(0,r.jsx)(n.code,{children:"ConsoleApp.Run"}),", you can check the syntax of the command line in the tooltip to see how it is generated."]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://github.com/Cysharp/ConsoleAppFramework/assets/46207/af480566-adac-4767-bd5e-af89ab6d71f1",alt:"image"})}),(0,r.jsxs)(n.p,{children:["For the rules on converting parameter names to option names, aliases, and how to set documentation, refer to the ",(0,r.jsx)(n.a,{href:"#option-aliases-and-help-version",children:"Option aliases"})," section."]}),(0,r.jsxs)(n.p,{children:["Parameters marked with the ",(0,r.jsx)(n.code,{children:"[Argument]"})," attribute receive values in order without parameter names. This attribute can only be set on sequential parameters from the beginning."]}),(0,r.jsxs)(n.p,{children:["To convert from string arguments to various types, basic primitive types (",(0,r.jsx)(n.code,{children:"string"}),", ",(0,r.jsx)(n.code,{children:"char"}),", ",(0,r.jsx)(n.code,{children:"sbyte"}),", ",(0,r.jsx)(n.code,{children:"byte"}),", ",(0,r.jsx)(n.code,{children:"short"}),", ",(0,r.jsx)(n.code,{children:"int"}),", ",(0,r.jsx)(n.code,{children:"long"}),", ",(0,r.jsx)(n.code,{children:"uint"}),", ",(0,r.jsx)(n.code,{children:"ushort"}),", ",(0,r.jsx)(n.code,{children:"ulong"}),", ",(0,r.jsx)(n.code,{children:"decimal"}),", ",(0,r.jsx)(n.code,{children:"float"}),", ",(0,r.jsx)(n.code,{children:"double"}),") use ",(0,r.jsx)(n.code,{children:"TryParse"}),". For types that implement ",(0,r.jsx)(n.code,{children:"ISpanParsable<T>"})," (",(0,r.jsx)(n.code,{children:"DateTime"}),", ",(0,r.jsx)(n.code,{children:"DateTimeOffset"}),", ",(0,r.jsx)(n.code,{children:"Guid"}),", ",(0,r.jsx)(n.code,{children:"BigInteger"}),", ",(0,r.jsx)(n.code,{children:"Complex"}),", ",(0,r.jsx)(n.code,{children:"Half"}),", ",(0,r.jsx)(n.code,{children:"Int128"}),", etc.), ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.iparsable-1.tryparse?view=net-8.0#system-ispanparsable-1-tryparse(system-readonlyspan((system-char))-system-iformatprovider-0@)",children:"IParsable<TSelf>.TryParse"})," or ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.ispanparsable-1.tryparse?view=net-8.0#system-ispanparsable-1-tryparse(system-readonlyspan((system-char))-system-iformatprovider-0@)",children:"ISpanParsable<TSelf>.TryParse"})," is used."]}),(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(n.code,{children:"enum"}),", it is parsed using ",(0,r.jsx)(n.code,{children:"Enum.TryParse(ignoreCase: true)"}),"."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"bool"})," is treated as a flag and is always optional. It becomes ",(0,r.jsx)(n.code,{children:"true"})," when the parameter name is passed."]}),(0,r.jsx)(n.h3,{id:"array",children:"Array"}),(0,r.jsx)(n.p,{children:"Array parsing has three special patterns."}),(0,r.jsxs)(n.p,{children:["For a regular ",(0,r.jsx)(n.code,{children:"T[]"}),", if the value starts with ",(0,r.jsx)(n.code,{children:"["}),", it is parsed using ",(0,r.jsx)(n.code,{children:"JsonSerializer.Deserialize"}),". Otherwise, it is parsed as comma-separated values. For example, ",(0,r.jsx)(n.code,{children:"[1,2,3]"})," or ",(0,r.jsx)(n.code,{children:"1,2,3"})," are allowed as values. To set an empty array, pass ",(0,r.jsx)(n.code,{children:"[]"}),"."]}),(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(n.code,{children:"params T[]"}),", all subsequent arguments become the values of the array. For example, if there is an input like ",(0,r.jsx)(n.code,{children:"--paramsArray foo bar baz"}),", it will be bound to a value like ",(0,r.jsx)(n.code,{children:'["foo", "bar", "baz"]'}),"."]}),(0,r.jsx)(n.h3,{id:"object",children:"Object"}),(0,r.jsxs)(n.p,{children:["If none of the above cases apply, ",(0,r.jsx)(n.code,{children:"JsonSerializer.Deserialize<T>"})," is used to perform binding as JSON. However, ",(0,r.jsx)(n.code,{children:"CancellationToken"})," and ",(0,r.jsx)(n.code,{children:"ConsoleAppContext"})," are treated as special types and excluded from binding. Also, parameters with the ",(0,r.jsx)(n.code,{children:"[FromServices]"})," attribute are not subject to binding."]}),(0,r.jsxs)(n.p,{children:["If you want to change the deserialization options, you can set ",(0,r.jsx)(n.code,{children:"JsonSerializerOptions"})," to ",(0,r.jsx)(n.code,{children:"ConsoleApp.JsonSerializerOptions"}),"."]}),(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"NOTE: If they are not set when NativeAOT is used, a runtime exception may occur. If they are included in the parsing process, be sure to set source generated options."}),"\n"]}),(0,r.jsx)(n.h3,{id:"custom-value-converter",children:"Custom Value Converter"}),(0,r.jsxs)(n.p,{children:["To perform custom binding to existing types that do not support ",(0,r.jsx)(n.code,{children:"ISpanParsable<T>"}),", you can create and set up a custom parser. For example, if you want to pass ",(0,r.jsx)(n.code,{children:"System.Numerics.Vector3"})," as a comma-separated string like ",(0,r.jsx)(n.code,{children:"1.3,4.12,5.947"})," and parse it, you can create an ",(0,r.jsx)(n.code,{children:"Attribute"})," with ",(0,r.jsx)(n.code,{children:"AttributeTargets.Parameter"})," that implements ",(0,r.jsx)(n.code,{children:"IArgumentParser<T>"}),"'s ",(0,r.jsx)(n.code,{children:"static bool TryParse(ReadOnlySpan<char> s, out Vector3 result)"})," as follows:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"[AttributeUsage(AttributeTargets.Parameter)]\npublic class Vector3ParserAttribute : Attribute, IArgumentParser<Vector3>\n{\n    public static bool TryParse(ReadOnlySpan<char> s, out Vector3 result)\n    {\n        Span<Range> ranges = stackalloc Range[3];\n        var splitCount = s.Split(ranges, ',');\n        if (splitCount != 3)\n        {\n            result = default;\n            return false;\n        }\n\n        float x;\n        float y;\n        float z;\n        if (float.TryParse(s[ranges[0]], out x) && float.TryParse(s[ranges[1]], out y) && float.TryParse(s[ranges[2]], out z))\n        {\n            result = new Vector3(x, y, z);\n            return true;\n        }\n\n        result = default;\n        return false;\n    }\n}\n"})}),(0,r.jsx)(n.p,{children:"By setting this attribute on a parameter, the custom parser will be called when parsing the args."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"ConsoleApp.Run(args, ([Vector3Parser] Vector3 position) => Console.WriteLine(position));\n"})}),(0,r.jsx)(n.h3,{id:"double-dash-escaping",children:"Double-dash escaping"}),(0,r.jsxs)(n.p,{children:["Arguments after double-dash (",(0,r.jsx)(n.code,{children:"--"}),") can be received as escaped arguments without being parsed. This is useful when creating commands like ",(0,r.jsx)(n.code,{children:"dotnet run"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// dotnet run --project foo.csproj -- --foo 100 --bar bazbaz\nvar app = ConsoleApp.Create();\napp.Add("run", (string project, ConsoleAppContext context) =>\n{\n    // run --project foo.csproj -- --foo 100 --bar bazbaz\n    Console.WriteLine(string.Join(" ", context.Arguments));\n    // --project foo.csproj\n    Console.WriteLine(string.Join(" ", context.CommandArguments!));\n    // --foo 100 --bar bazbaz\n    Console.WriteLine(string.Join(" ", context.EscapedArguments!));\n});\napp.Run(args);\n'})}),(0,r.jsxs)(n.p,{children:["You can get the escaped arguments using ",(0,r.jsx)(n.code,{children:"ConsoleAppContext.EscapedArguments"}),". From ",(0,r.jsx)(n.code,{children:"ConsoleAppContext"}),", you can also get ",(0,r.jsx)(n.code,{children:"Arguments"})," which contains all arguments passed to ",(0,r.jsx)(n.code,{children:"Run/RunAsync"}),", and ",(0,r.jsx)(n.code,{children:"CommandArguments"})," which contains the arguments used for command execution."]}),(0,r.jsx)(n.h3,{id:"syntax-parsing-policy-and-performance",children:"Syntax Parsing Policy and Performance"}),(0,r.jsxs)(n.p,{children:["While there are some standards for command-line arguments, such as UNIX tools and POSIX, there is no absolute specification. The ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/standard/commandline/syntax",children:"Command-line syntax overview for System.CommandLine"})," provides an explanation of the specifications adopted by System.CommandLine. However, ConsoleAppFramework, while referring to these specifications to some extent, does not necessarily aim to fully comply with them."]}),(0,r.jsxs)(n.p,{children:["For example, specifications that change behavior based on ",(0,r.jsx)(n.code,{children:"-x"})," and ",(0,r.jsx)(n.code,{children:"-X"})," or allow bundling ",(0,r.jsx)(n.code,{children:"-f -d -x"})," as ",(0,r.jsx)(n.code,{children:"-fdx"})," are not easy to understand and also take time to parse. The poor performance of System.CommandLine may be influenced by its adherence to complex grammar. Therefore, ConsoleAppFramework prioritizes performance and clear rules. It uses lower-kebab-case as the basis while allowing case-insensitive matching. It does not support ambiguous grammar that cannot be processed in a single pass or takes time to parse."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/dotnet/command-line-api/issues/2338",children:"System.CommandLine seems to be aiming for a new direction in .NET 9 and .NET 10"}),", but from a performance perspective, it will never surpass ConsoleAppFramework."]}),(0,r.jsx)(n.h2,{id:"cancellationtokengracefully-shutdown-and-timeout",children:"CancellationToken(Gracefully Shutdown) and Timeout"}),(0,r.jsxs)(n.p,{children:["In ConsoleAppFramework, when you pass a ",(0,r.jsx)(n.code,{children:"CancellationToken"})," as an argument, it can be used to check for interruption commands (SIGINT/SIGTERM/SIGKILL - Ctrl+C) rather than being treated as a parameter. For handling this, ConsoleAppFramework performs special code generation when a ",(0,r.jsx)(n.code,{children:"CancellationToken"})," is included in the parameters."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using var posixSignalHandler = PosixSignalHandler.Register(ConsoleApp.Timeout);\nvar arg0 = posixSignalHandler.Token;\n\nawait Task.Run(() => command(arg0!)).WaitAsync(posixSignalHandler.TimeoutToken);\n"})}),(0,r.jsxs)(n.p,{children:["If a CancellationToken is not passed, the application is immediately forced to terminate when an interruption command (Ctrl+C) is received. However, if a CancellationToken is present, it internally uses ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignalregistration",children:(0,r.jsx)(n.code,{children:"PosixSignalRegistration"})})," to hook SIGINT/SIGTERM/SIGKILL and sets the CancellationToken to a canceled state. Additionally, it prevents forced termination to allow for a graceful shutdown."]}),(0,r.jsx)(n.p,{children:"If the CancellationToken is handled correctly, the application can perform proper termination processing based on the application's handling. However, if the CancellationToken is mishandled, the application may not terminate even when an interruption command is received. To avoid this, a timeout timer starts after the interruption command, and the application is forcibly terminated again after the specified time."}),(0,r.jsxs)(n.p,{children:["The default timeout is 5 seconds, but it can be changed using ",(0,r.jsx)(n.code,{children:"ConsoleApp.Timeout"}),". For example, setting it to ",(0,r.jsx)(n.code,{children:"ConsoleApp.Timeout = Timeout.InfiniteTimeSpan;"})," disables the forced termination caused by the timeout."]}),(0,r.jsxs)(n.p,{children:["The hooking behavior using ",(0,r.jsx)(n.code,{children:"PosixSignalRegistration"})," is determined by the presence of a ",(0,r.jsx)(n.code,{children:"CancellationToken"})," (or always takes effect if a filter is set). Therefore, even for synchronous methods, it is possible to change the behavior by including a ",(0,r.jsx)(n.code,{children:"CancellationToken"})," as an argument."]}),(0,r.jsxs)(n.p,{children:["In the case of ",(0,r.jsx)(n.code,{children:"Run/RunAsync"})," from ",(0,r.jsx)(n.code,{children:"ConsoleAppBuilder"}),", you can also pass a CancellationToken. This is combined with PosixSignalRegistration and passed to each method. This makes it possible to cancel at any arbitrary timing."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'var cancellationTokenSource = new CancellationTokenSource();\n\nvar app = ConsoleApp.Create();\n\napp.Add("", (CancellationToken cancellationToken) =>\n{\n    // do anything...\n});\n\nawait app.RunAsync(args, cancellationTokenSource.Token); // pass external CancellationToken\n'})}),(0,r.jsx)(n.h2,{id:"exit-code",children:"Exit Code"}),(0,r.jsxs)(n.p,{children:["If the method returns ",(0,r.jsx)(n.code,{children:"int"})," or ",(0,r.jsx)(n.code,{children:"Task<int>"}),", ",(0,r.jsx)(n.code,{children:"ConsoleAppFramework"})," will set the return value to the exit code. Due to the nature of code generation, when writing lambda expressions, you need to explicitly specify either ",(0,r.jsx)(n.code,{children:"int"})," or ",(0,r.jsx)(n.code,{children:"Task<int>"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// return Random ExitCode...\nConsoleApp.Run(args, int () => Random.Shared.Next());\n"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// return StatusCode\nawait ConsoleApp.RunAsync(args, async Task<int> (string url, CancellationToken cancellationToken) =>\n{\n    using var client = new HttpClient();\n    var response = await client.GetAsync(url, cancellationToken);\n    return (int)response.StatusCode;\n});\n"})}),(0,r.jsxs)(n.p,{children:["If the method throws an unhandled exception, ConsoleAppFramework always set ",(0,r.jsx)(n.code,{children:"1"})," to the exit code. Also, in that case, output ",(0,r.jsx)(n.code,{children:"Exception.ToString"})," to ",(0,r.jsx)(n.code,{children:"ConsoleApp.LogError"})," (the default is ",(0,r.jsx)(n.code,{children:"Console.WriteLine"}),"). If you want to modify this code, please create a custom filter. For more details, refer to the ",(0,r.jsx)(n.a,{href:"#filtermiddleware-pipline--consoleappcontext",children:"Filter"})," section."]}),(0,r.jsx)(n.h2,{id:"attribute-based-parameters-validation",children:"Attribute based parameters validation"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ConsoleAppFramework"})," performs validation when the parameters are marked with attributes for validation from ",(0,r.jsx)(n.code,{children:"System.ComponentModel.DataAnnotations"})," (more precisely, attributes that implement ",(0,r.jsx)(n.code,{children:"ValidationAttribute"}),"). The validation occurs after parameter binding and before command execution. If the validation fails, it throws a ",(0,r.jsx)(n.code,{children:"ValidationException"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"ConsoleApp.Run(args, ([EmailAddress] string firstArg, [Range(0, 2)] int secondArg) => \\{ });\n"})}),(0,r.jsxs)(n.p,{children:["For example, if you pass arguments like ",(0,r.jsx)(n.code,{children:"args = \"--first-arg invalid.email --second-arg 10\".Split(' ');"}),", you will see validation failure messages such as:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-txt",children:"The firstArg field is not a valid e-mail address.\nThe field secondArg must be between 0 and 2.\n"})}),(0,r.jsx)(n.p,{children:"By default, the ExitCode is set to 1 in this case."}),(0,r.jsx)(n.h2,{id:"hide-commandparameter-help",children:"Hide command/parameter help"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ConsoleAppFramework"})," supports ",(0,r.jsx)(n.code,{children:"HiddenAttribute"})," which is used to hide specific help for a command/parameter."]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["When",(0,r.jsx)(n.code,{children:"HiddenAttribute"})," is set to command, it hides command from command list."]}),"\n",(0,r.jsxs)(n.li,{children:["When",(0,r.jsx)(n.code,{children:"HiddenAttribute"})," is set to parameter, it hides parameter from command help."]}),"\n"]}),(0,r.jsx)(n.h2,{id:"filtermiddleware-pipeline--consoleappcontext",children:"Filter(Middleware) Pipeline / ConsoleAppContext"}),(0,r.jsxs)(n.p,{children:["Filters are provided as a mechanism to hook into the execution before and after. To use filters, define an ",(0,r.jsx)(n.code,{children:"internal class"})," that implements ",(0,r.jsx)(n.code,{children:"ConsoleAppFilter"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"internal class NopFilter(ConsoleAppFilter next) : ConsoleAppFilter(next) // ctor needs `ConsoleAppFilter next` and call base(next)\n{\n    // implement InvokeAsync as filter body\n    public override async Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)\n    {\n        try\n        {\n            /* on before */\n            await Next.InvokeAsync(context, cancellationToken); // invoke next filter or command body\n            /* on after */\n        }\n        catch\n        {\n            /* on error */\n            throw;\n        }\n        finally\n        {\n            /* on finally */\n        }\n    }\n}\n"})}),(0,r.jsxs)(n.p,{children:['Filters can be attached multiple times to "global", "class", or "method" using ',(0,r.jsx)(n.code,{children:"UseFilter<T>"})," or ",(0,r.jsx)(n.code,{children:"[ConsoleAppFilter<T>]"}),". The order of filters is global \u2192 class \u2192 method, and the execution order is determined by the definition order from top to bottom."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"var app = ConsoleApp.Create();\n\n// global filters\napp.UseFilter<NopFilter>(); //order 1\napp.UseFilter<NopFilter>(); //order 2\n\napp.Add<MyCommand>();\napp.Run(args);\n\n// per class filters\n[ConsoleAppFilter<NopFilter>] // order 3\n[ConsoleAppFilter<NopFilter>] // order 4\npublic class MyCommand\n{\n    // per method filters\n    [ConsoleAppFilter<NopFilter>] // order 5\n    [ConsoleAppFilter<NopFilter>] // order 6\n    public void Echo(string msg) => Console.WriteLine(msg);\n}\n"})}),(0,r.jsx)(n.p,{children:"Filters allow various processes to be shared. For example, the process of measuring execution time can be written as follows:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'internal class LogRunningTimeFilter(ConsoleAppFilter next) : ConsoleAppFilter(next)\n{\n    public override async Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)\n    {\n        var startTime = Stopwatch.GetTimestamp();\n        ConsoleApp.Log($"Execute command at {DateTime.UtcNow.ToLocalTime()}"); // LocalTime for human readable time\n        try\n        {\n            await Next.InvokeAsync(context, cancellationToken);\n            ConsoleApp.Log($"Command execute successfully at {DateTime.UtcNow.ToLocalTime()}, Elapsed: " + (Stopwatch.GetElapsedTime(startTime)));\n        }\n        catch\n        {\n            ConsoleApp.Log($"Command execute failed at {DateTime.UtcNow.ToLocalTime()}, Elapsed: " + (Stopwatch.GetElapsedTime(startTime)));\n            throw;\n        }\n    }\n}\n'})}),(0,r.jsxs)(n.p,{children:["In case of an exception, the ",(0,r.jsx)(n.code,{children:"ExitCode"})," is usually ",(0,r.jsx)(n.code,{children:"1"}),", and the stack trace is also displayed. However, by applying an exception handling filter, the behavior can be changed."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"internal class ChangeExitCodeFilter(ConsoleAppFilter next) : ConsoleAppFilter(next)\n{\n    public override async Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)\n    {\n        try\n        {\n            await Next.InvokeAsync(context, cancellationToken);\n        }\n        catch (Exception ex)\n        {\n            if (ex is OperationCanceledException) return;\n\n            Environment.ExitCode = 9999; // change custom exit code\n            ConsoleApp.LogError(ex.Message); // .ToString() shows stacktrace, .Message can avoid showing stacktrace to user.\n        }\n    }\n}\n"})}),(0,r.jsxs)(n.p,{children:["Filters are executed after the command name routing is completed. If you want to prohibit multiple executions for each command name, you can use ",(0,r.jsx)(n.code,{children:"ConsoleAppContext.CommandName"})," as the key."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'internal class PreventMultipleSameCommandInvokeFilter(ConsoleAppFilter next) : ConsoleAppFilter(next)\n{\n    public override async Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)\n    {\n        var basePath = Assembly.GetEntryAssembly()?.Location.Replace(Path.DirectorySeparatorChar, \'_\');\n        var mutexKey = $"{basePath}$$${context.CommandName}"; // lock per command-name\n\n        using var mutex = new Mutex(true, mutexKey, out var createdNew);\n        if (!createdNew)\n        {\n            throw new Exception($"already running command:{context.CommandName} in another process.");\n        }\n\n        await Next.InvokeAsync(context, cancellationToken);\n    }\n}\n'})}),(0,r.jsxs)(n.p,{children:["If you want to pass values between filters or to commands, you can use ",(0,r.jsx)(n.code,{children:"ConsoleAppContext.State"}),". For example, if you want to perform authentication processing and pass around the ID, you can write code like the following. Since ",(0,r.jsx)(n.code,{children:"ConsoleAppContext"})," is an immutable record, you need to pass the rewritten context to Next using the ",(0,r.jsx)(n.code,{children:"with"})," syntax."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"internal class AuthenticationFilter(ConsoleAppFilter next) : ConsoleAppFilter(next)\n{\n    public override async Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)\n    {\n        var requestId = Guid.NewGuid();\n        var userId = await GetUserIdAsync();\n\n        // setup new state to context\n        var authedContext = context with \\{ State = new ApplicationContext(requestId, userId) };\n        await Next.InvokeAsync(authedContext, cancellationToken);\n    }\n\n    // get user-id from DB/auth saas/others\n    async Task<int> GetUserIdAsync()\n    {\n        await Task.Delay(TimeSpan.FromSeconds(1));\n        return 1999;\n    }\n}\n\nrecord class ApplicationContext(Guid RequiestId, int UserId);\n"})}),(0,r.jsxs)(n.p,{children:["Commands can accept ",(0,r.jsx)(n.code,{children:"ConsoleAppContext"})," as an argument. This allows using the values processed by filters."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'var app = ConsoleApp.Create();\n\napp.UseFilter<AuthenticationFilter>();\n\napp.Add("", (int x, int y, ConsoleAppContext context) =>\n{\n    var appContext = (ApplicationContext)context.State!;\n    var requestId = appContext.RequiestId;\n    var userId = appContext.UserId;\n\n    Console.WriteLine($"Request:{requestId} User:{userId} Sum:{x + y}");\n});\n\napp.Run(args);\n'})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ConsoleAppContext"})," also has a ",(0,r.jsx)(n.code,{children:"ConsoleAppContext.Arguments"})," property that allows you to obtain the (",(0,r.jsx)(n.code,{children:"string[] args"}),") passed to Run/RunAsync."]}),(0,r.jsx)(n.h3,{id:"sharing-filters-between-projects",children:"Sharing Filters Between Projects"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ConsoleAppFilter"})," is defined as ",(0,r.jsx)(n.code,{children:"internal"})," for each project by the Source Generator. Therefore, an additional library is provided for referencing common filter definitions across projects."]}),(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["PM> Install-Package ",(0,r.jsx)(n.a,{href:"https://www.nuget.org/packages/ConsoleAppFramework.Abstractions",children:"ConsoleAppFramework.Abstractions"})]}),"\n"]}),(0,r.jsx)(n.p,{children:"This library includes the following classes:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"IArgumentParser<T>"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"ConsoleAppContext"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"ConsoleAppFilter"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"ConsoleAppFilterAttribute<T>"})}),"\n"]}),(0,r.jsxs)(n.p,{children:["Internally, when referencing ",(0,r.jsx)(n.code,{children:"ConsoleAppFramework.Abstractions"}),", the ",(0,r.jsx)(n.code,{children:"USE_EXTERNAL_CONSOLEAPP_ABSTRACTIONS"})," compilation symbol is added. This disables the above classes generated by the Source Generator, and prioritizes using the classes within the library."]}),(0,r.jsx)(n.h3,{id:"performance-of-filter",children:"Performance of filter"}),(0,r.jsx)(n.p,{children:"In general frameworks, filters are dynamically added at runtime, resulting in a variable number of filters. Therefore, they need to be allocated using a dynamic array. In ConsoleAppFramework, the number of filters is statically determined at compile time, eliminating the need for any additional allocations such as arrays or lambda expression captures. The allocation amount is equal to the number of filter classes being used plus 1 (for wrapping the command method), resulting in the shortest execution path."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"app.UseFilter<NopFilter>();\napp.UseFilter<NopFilter>();\napp.UseFilter<NopFilter>();\napp.UseFilter<NopFilter>();\napp.UseFilter<NopFilter>();\n\n// The above code will generate the following code:\n\nsealed class Command0Invoker(string[] args, Action command) : ConsoleAppFilter(null!)\n{\n    public ConsoleAppFilter BuildFilter()\n    {\n        var filter0 = new NopFilter(this);\n        var filter1 = new NopFilter(filter0);\n        var filter2 = new NopFilter(filter1);\n        var filter3 = new NopFilter(filter2);\n        var filter4 = new NopFilter(filter3);\n        return filter4;\n    }\n\n    public override Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)\n    {\n        return RunCommand0Async(context.Arguments, args, command, context, cancellationToken);\n    }\n}\n"})}),(0,r.jsxs)(n.p,{children:["When an ",(0,r.jsx)(n.code,{children:"async Task"})," completes synchronously, it returns the equivalent of ",(0,r.jsx)(n.code,{children:"Task.CompletedTask"}),", so ",(0,r.jsx)(n.code,{children:"ValueTask"})," is not necessary."]}),(0,r.jsx)(n.h2,{id:"dependency-injectionlogging-configuration-etc",children:"Dependency Injection(Logging, Configuration, etc...)"}),(0,r.jsxs)(n.p,{children:["The execution processing of ",(0,r.jsx)(n.code,{children:"ConsoleAppFramework"})," fully supports ",(0,r.jsx)(n.code,{children:"DI"}),". When you want to use a logger, read a configuration, or share processing with an ASP.NET project, using ",(0,r.jsx)(n.code,{children:"Microsoft.Extensions.DependencyInjection"})," or other DI libraries can make processing convenient."]}),(0,r.jsxs)(n.p,{children:["If you are referencing ",(0,r.jsx)(n.code,{children:"Microsoft.Extensions.DependencyInjection"}),", you can call the ",(0,r.jsx)(n.code,{children:"ConfigureServices"})," method from ",(0,r.jsx)(n.code,{children:"ConsoleApp.ConsoleAppBuilder"})," (ConsoleAppFramework adds methods based on your project's reference status)."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'var app = ConsoleApp.Create()\n    .ConfigureServices(service =>\n    {\n        service.AddTransient<MyService>();\n    });\n\napp.Add("", ([FromServices] MyService service, int x, int y) => Console.WriteLine(x + y));\n\napp.Run(args);\n'})}),(0,r.jsxs)(n.p,{children:["When passing to a lambda expression or method, the ",(0,r.jsx)(n.code,{children:"[FromServices]"})," attribute is used to distinguish it from command parameters. When passing a class, Constructor Injection can be used, resulting in a simpler appearance. Lambda, method, constructor, filter, etc, all DI supported parameter also supports ",(0,r.jsx)(n.code,{children:"[FromKeyedServices]"}),"."]}),(0,r.jsxs)(n.p,{children:["Let's try injecting a logger and enabling output to a file. The libraries used are Microsoft.Extensions.Logging and ",(0,r.jsx)(n.a,{href:"https://github.com/Cysharp/ZLogger/",children:"Cysharp/ZLogger"})," (a high-performance logger built on top of MS.E.Logging). If you are referencing ",(0,r.jsx)(n.code,{children:"Microsoft.Extensions.Logging"}),", you can call ",(0,r.jsx)(n.code,{children:"ConfigureLogging"})," from ",(0,r.jsx)(n.code,{children:"ConsoleAppBuilder"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Package Import: ZLogger\nvar app = ConsoleApp.Create()\n    .ConfigureLogging(x =>\n    {\n        x.ClearProviders();\n        x.SetMinimumLevel(LogLevel.Trace);\n        x.AddZLoggerConsole();\n        x.AddZLoggerFile("log.txt");\n    });\n\napp.Add<MyCommand>();\napp.Run(args);\n\n// inject logger to constructor\npublic class MyCommand(ILogger<MyCommand> logger)\n{\n    public void Echo(string msg)\n    {\n        logger.ZLogInformation($"Message is {msg}");\n    }\n}\n'})}),(0,r.jsxs)(n.p,{children:["For building an ",(0,r.jsx)(n.code,{children:"IServiceProvider"}),", ",(0,r.jsx)(n.code,{children:"ConfigureServices/ConfigureLogging"})," uses ",(0,r.jsx)(n.code,{children:"Microsoft.Extensions.DependencyInjection.ServiceCollection"}),". If you want to set a custom ServiceProvider or a ServiceProvider built from Host, or if you want to execute DI with ",(0,r.jsx)(n.code,{children:"ConsoleApp.Run"}),", set it to ",(0,r.jsx)(n.code,{children:"ConsoleApp.ServiceProvider"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Microsoft.Extensions.DependencyInjection\nvar services = new ServiceCollection();\nservices.AddTransient<MyService>();\n\nusing var serviceProvider = services.BuildServiceProvider();\n\n// Any DI library can be used as long as it can create an IServiceProvider\nConsoleApp.ServiceProvider = serviceProvider;\n\n// When passing to a lambda expression/method, using [FromServices] indicates that it is passed via DI, not as a parameter\nConsoleApp.Run(args, ([FromServices]MyService service, int x, int y) => Console.WriteLine(x + y));\n"})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ConsoleApp"})," has replaceable default logging methods ",(0,r.jsx)(n.code,{children:"ConsoleApp.Log"})," and ",(0,r.jsx)(n.code,{children:"ConsoleApp.LogError"})," used for Help display and exception handling. If using ",(0,r.jsx)(n.code,{children:"ILogger<T>"}),", it's better to replace these as well."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"app.UseFilter<ReplaceLogFilter>();\n\n// inject logger to filter\ninternal sealed class ReplaceLogFilter(ConsoleAppFilter next, ILogger<Program> logger)\n    : ConsoleAppFilter(next)\n{\n    public override Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)\n    {\n        ConsoleApp.Log = msg => logger.LogInformation(msg);\n        ConsoleApp.LogError = msg => logger.LogError(msg);\n\n        return Next.InvokeAsync(context, cancellationToken);\n    }\n}\n"})}),(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["I don't recommend using ",(0,r.jsx)(n.code,{children:"ConsoleApp.Log"})," and ",(0,r.jsx)(n.code,{children:"ConsoleApp.LogError"})," directly as an application logging method, as they are intended to be used as output destinations for internal framework output.\nFor error handling, it would be better to define your own custom filters for error handling, which would allow you to record more details when handling errors."]}),"\n"]}),(0,r.jsxs)(n.p,{children:["DI can also be effectively used when reading application configuration from ",(0,r.jsx)(n.code,{children:"appsettings.json"}),". For example, suppose you have the following JSON file."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "Position": {\n    "Title": "Editor",\n    "Name": "Joe Smith"\n  },\n  "MyKey": "My appsettings.json Value",\n  "AllowedHosts": "*"\n}\n'})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<ItemGroup>\n    <None Update="appsettings.json">\n        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n</ItemGroup>\n'})}),(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"Microsoft.Extensions.Configuration.Json"}),", reading, binding, and registering with DI can be done as follows."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// Package Import: Microsoft.Extensions.Configuration.Json\nvar app = ConsoleApp.Create()\n    .ConfigureDefaultConfiguration()\n    .ConfigureServices((configuration, services) =>\n    {\n        // Package Import: Microsoft.Extensions.Options.ConfigurationExtensions\n        services.Configure<PositionOptions>(configuration.GetSection("Position"));\n    });\n\napp.Add<MyCommand>();\napp.Run(args);\n\n// inject options\npublic class MyCommand(IOptions<PositionOptions> options)\n{\n    public void Echo(string msg)\n    {\n        ConsoleApp.Log($"Binded Option: {options.Value.Title} {options.Value.Name}");\n    }\n}\n\npublic class PositionOptions\n{\n    public string Title \\{ get; set; \\} = "";\n    public string Name \\{ get; set; \\} = "";\n}\n'})}),(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"Microsoft.Extensions.Configuration"})," is imported, ",(0,r.jsx)(n.code,{children:"ConfigureEmptyConfiguration"})," becomes available to call. Additionally, when ",(0,r.jsx)(n.code,{children:"Microsoft.Extensions.Configuration.Json"})," is imported, ",(0,r.jsx)(n.code,{children:"ConfigureDefaultConfiguration"})," becomes available to call. In DefaultConfiguration, ",(0,r.jsx)(n.code,{children:"SetBasePath(System.IO.Directory.GetCurrentDirectory())"})," and ",(0,r.jsx)(n.code,{children:'AddJsonFile("appsettings.json", optional: true)'})," are executed before calling ",(0,r.jsx)(n.code,{children:"Action<IConfigurationBuilder> configure"}),"."]}),(0,r.jsxs)(n.p,{children:["Furthermore, overloads of ",(0,r.jsx)(n.code,{children:"Action<IConfiguration, IServiceCollection> configure"})," and ",(0,r.jsx)(n.code,{children:"Action<IConfiguration, ILoggingBuilder> configure"})," are added to ",(0,r.jsx)(n.code,{children:"ConfigureServices"})," and ",(0,r.jsx)(n.code,{children:"ConfigureLogging"}),", allowing you to retrieve the Configuration when executing the delegate."]}),(0,r.jsx)(n.p,{children:"without Hosting dependency, I've preferred these import packages."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<ItemGroup>\n\t<PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="9.0.0" />\n\t<PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="9.0.0" />\n\t<PackageReference Include="ZLogger" Version="2.5.9" />\n</ItemGroup>\n'})}),(0,r.jsxs)(n.p,{children:["As it is, the DI scope is not set, but by using a global filter, you can add a scope for each command execution. ",(0,r.jsx)(n.code,{children:"ConsoleAppFilter"})," can also inject services via constructor injection, so let's get the ",(0,r.jsx)(n.code,{children:"IServiceProvider"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"app.UseFilter<ServiceProviderScopeFilter>();\n\ninternal class ServiceProviderScopeFilter(IServiceProvider serviceProvider, ConsoleAppFilter next) : ConsoleAppFilter(next)\n{\n    public override async Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)\n    {\n        // create Microsoft.Extensions.DependencyInjection scope\n        await using var scope = serviceProvider.CreateAsyncScope();\n\n        var originalServiceProvider = ConsoleApp.ServiceProvider;\n        ConsoleApp.ServiceProvider = scope.ServiceProvider;\n        try\n        {\n            await Next.InvokeAsync(context, cancellationToken);\n        }\n        finally\n        {\n            ConsoleApp.ServiceProvider = originalServiceProvider;\n        }\n    }\n}\n"})}),(0,r.jsx)(n.p,{children:"However, since the construction of the filters is performed before execution, automatic injection using scopes is only effective for the command body itself."}),(0,r.jsxs)(n.p,{children:["If you have other applications such as ASP.NET in the entire project and want to use common DI and configuration set up using ",(0,r.jsx)(n.code,{children:"Microsoft.Extensions.Hosting"}),", you can call ",(0,r.jsx)(n.code,{children:"ToConsoleAppBuilder"})," from ",(0,r.jsx)(n.code,{children:"IHostBuilder"})," or ",(0,r.jsx)(n.code,{children:"HostApplicationBuilder"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// Package Import: Microsoft.Extensions.Hosting\nvar app = Host.CreateApplicationBuilder()\n    .ToConsoleAppBuilder();\n"})}),(0,r.jsx)(n.p,{children:"In this case, it builds the HostBuilder, creates a Scope for the ServiceProvider, and disposes of all of them after execution."}),(0,r.jsxs)(n.p,{children:["ConsoleAppFramework has its own lifetime management (see the ",(0,r.jsx)(n.a,{href:"#cancellationtokengracefully-shutdown-and-timeout",children:"CancellationToken(Gracefully Shutdown) and Timeout"})," section), therefore it is handled correctly even without using ",(0,r.jsx)(n.code,{children:"ConsoleLifetime"}),"."]}),(0,r.jsx)(n.h2,{id:"opentelemetry",children:"OpenTelemetry"}),(0,r.jsx)(n.p,{children:"It's important to be conscious of observability in console applications as well. Visualizing not just logging but also traces will be helpful for performance tuning and troubleshooting. In ConsoleAppFramework, you can use this smoothly by utilizing the OpenTelemetry support of HostApplicationBuilder."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- csproj, reference OpenTelemetry packages --\x3e\n<ItemGroup>\n    <PackageReference Include="Microsoft.Extensions.Hosting" Version="9.0.6" />\n    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.9.0" />\n    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.9.0" />\n    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" Version="1.9.0" />\n    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.9.0" />\n</ItemGroup>\n'})}),(0,r.jsx)(n.p,{children:"For command tracing, you can set up the trace root by preparing a filter like the following. Also, when using multiple filters in an application, if you start all activities, it becomes very convenient as you can visualize the execution status of the filters."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public static class ConsoleAppFrameworkSampleActivitySource\n{\n    public const string Name = "ConsoleAppFrameworkSample";\n\n    public static ActivitySource Instance \\{ get; \\} = new ActivitySource(Name);\n}\n\npublic class CommandTracingFilter(ConsoleAppFilter next) : ConsoleAppFilter(next)\n{\n    public override async Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)\n    {\n        using var activity = ConsoleAppFrameworkSampleActivitySource.Instance.StartActivity("CommandStart");\n\n        if (activity == null) // Telemtry is not listened\n        {\n            await Next.InvokeAsync(context, cancellationToken);\n        }\n        else\n        {\n            activity.SetTag("console_app.command_name", context.CommandName);\n            activity.SetTag("console_app.command_args", string.Join(" ", context.EscapedArguments));\n\n            try\n            {\n                await Next.InvokeAsync(context, cancellationToken);\n                activity.SetStatus(ActivityStatusCode.Ok);\n            }\n            catch (Exception ex)\n            {\n                if (ex is OperationCanceledException)\n                {\n                    activity.SetStatus(ActivityStatusCode.Error, "Canceled");\n                }\n                else\n                {\n                    activity.AddException(ex);\n                    activity.SetStatus(ActivityStatusCode.Error);\n                }\n                throw;\n            }\n        }\n    }\n}\n'})}),(0,r.jsxs)(n.p,{children:["For visualization, if your solution includes a web application, using .NET Aspire would be convenient during development. For production environments, there are solutions like Datadog and New Relic, as well as OSS tools from Grafana Labs. However, especially for local development, I think OpenTelemetry native all-in-one solutions are convenient. Here, let's look at tracing using the OSS ",(0,r.jsx)(n.a,{href:"https://signoz.io/",children:"SigNoz"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'// git clone https://github.com/SigNoz/signoz.git\n// cd signoz/deploy/docker\n// docker compose up\nEnvironment.SetEnvironmentVariable("OTEL_EXPORTER_OTLP_ENDPOINT", "http://localhost:4317"); // 4317 or 4318\n\n// crate builder from Microsoft.Extensions.Hosting.Host\nvar builder = Host.CreateApplicationBuilder(args);\n\nbuilder.Logging.AddOpenTelemetry(logging =>\n{\n    logging.IncludeFormattedMessage = true;\n    logging.IncludeScopes = true;\n});\n\nbuilder.Services.AddOpenTelemetry()\n    .UseOtlpExporter()\n    .ConfigureResource(resource =>\n    {\n        resource.AddService("ConsoleAppFramework Telemetry Sample");\n    })\n    .WithMetrics(metrics =>\n    {\n        // configure for metrics\n        metrics.AddRuntimeInstrumentation()\n            .AddHttpClientInstrumentation();\n    })\n    .WithTracing(tracing =>\n    {\n        // configure for tracing\n        tracing.SetSampler(new AlwaysOnSampler())\n            .AddHttpClientInstrumentation()\n            .AddSource(ConsoleAppFrameworkSampleActivitySource.Name);\n    })\n    .WithLogging(logging =>\n    {\n        // configure for logging\n    });\n\nvar app = builder.ToConsoleAppBuilder();\n\napp.Add<SampleCommand>();\n\n// setup filter\napp.UseFilter<CommandTracingFilter>();\n\nawait app.RunAsync(args); // Run\n\npublic class SampleCommand(ILogger<SampleCommand> logger)\n{\n    [Command("")]\n    public async Task Run(CancellationToken cancellationToken)\n    {\n        using var httpClient = new HttpClient();\n\n        var ms = await httpClient.GetStringAsync("https://www.microsoft.com", cancellationToken);\n        var google = await httpClient.GetStringAsync("https://www.google.com", cancellationToken);\n\n        logger.LogInformation("Sequential Query done.");\n\n        var ms2 = httpClient.GetStringAsync("https://www.microsoft.com", cancellationToken);\n        var google2 = httpClient.GetStringAsync("https://www.google.com", cancellationToken);\n        var apple2 = httpClient.GetStringAsync("https://www.apple.com", cancellationToken);\n        await Task.WhenAll(ms2, google2, apple2);\n\n        logger.LogInformation("Parallel Query done.");\n    }\n}\n'})}),(0,r.jsxs)(n.p,{children:["When you launch ",(0,r.jsx)(n.code,{children:"SigNoz"})," with docker, the view will be available at ",(0,r.jsx)(n.code,{children:"http://localhost:8080/"})," and the collector at ",(0,r.jsx)(n.code,{children:"http://localhost:4317"}),"."]}),(0,r.jsxs)(n.p,{children:["If you configure OpenTelemetry-related settings with ",(0,r.jsx)(n.code,{children:"Host.CreateApplicationBuilder"})," and convert it with ",(0,r.jsx)(n.code,{children:"ToConsoleAppBuilder"}),", ",(0,r.jsx)(n.code,{children:"ConsoleAppFramework"})," will naturally support OpenTelemetry. In the example above, HTTP communications are performed sequentially, then executed in 3 parallel operations."]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://github.com/user-attachments/assets/51009748-28f1-46c6-a70a-7300e825ae5e",alt:""})}),(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.code,{children:"SigNoz"}),", besides Trace, Logs and Metrics can also be visualized in an easy-to-read manner."]}),(0,r.jsx)(n.h2,{id:"prevent-serviceprovider-auto-dispose",children:"Prevent ServiceProvider auto dispose"}),(0,r.jsxs)(n.p,{children:["When executing commands with ",(0,r.jsx)(n.code,{children:"Run/RunAsync"}),", the ServiceProvider is automatically disposed. This becomes a problem when executing commands multiple times or when you want to use the ServiceProvider after the command finishes. In Run/RunAsync from ConsoleAppBuilder, you can stop the automatic disposal of ServiceProvider by setting ",(0,r.jsx)(n.code,{children:"bool disposeServiceProvider"})," to ",(0,r.jsx)(n.code,{children:"false"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"var app = ConsoleApp.Create();\nawait app.RunAsync(args, disposeServiceProvider: false); // default is true\n"})}),(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"Microsoft.Extensions.Hosting"})," is referenced, ",(0,r.jsx)(n.code,{children:"bool startHost, bool stopHost, bool disposeServiceProvider"})," become controllable. The defaults are all ",(0,r.jsx)(n.code,{children:"true"}),"."]}),(0,r.jsx)(n.h2,{id:"colorize",children:"Colorize"}),(0,r.jsxs)(n.p,{children:["The framework doesn't support colorization directly; however, utilities like ",(0,r.jsx)(n.a,{href:"https://github.com/Cysharp/Kokuban",children:"Cysharp/Kokuban"})," make console colorization easy. Additionally, if you need spinners or updates single-line displays, you can also use it in combination with ",(0,r.jsx)(n.a,{href:"https://github.com/mayuki/Kurukuru",children:"mayuki/Kurukuru"}),"."]}),(0,r.jsx)(n.h2,{id:"publish-to-executable-file",children:"Publish to executable file"}),(0,r.jsx)(n.p,{children:"There are multiple ways to run a CLI application in .NET:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-run",children:"dotnet run"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build",children:"dotnet build"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-publish",children:"dotnet publish"})}),"\n"]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"run"})," is convenient when you want to execute the ",(0,r.jsx)(n.code,{children:"csproj"})," directly, such as for starting command tools in CI. ",(0,r.jsx)(n.code,{children:"build"})," and ",(0,r.jsx)(n.code,{children:"publish"})," are quite similar, so it's possible to discuss them in general terms, but it's a bit difficult to talk about the precise differences. For more details, it's a good idea to check out ",(0,r.jsxs)(n.a,{href:"https://github.com/dotnet/sdk/issues/26247",children:[(0,r.jsx)(n.code,{children:"build"})," vs ",(0,r.jsx)(n.code,{children:"publish"})," -- can they be friends? \xb7 Issue #26247 \xb7 dotnet/sdk"]}),"."]}),(0,r.jsxs)(n.p,{children:["Also, to run with Native AOT, please refer to the ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/",children:"Native AOT deployment overview"}),". In any case, ConsoleAppFramework thoroughly implements a dependency-free and reflection-free approach, so it shouldn't be an obstacle to execution."]}),(0,r.jsx)(n.h2,{id:"v4---v5-migration-guide",children:"v4 -> v5 Migration Guide"}),(0,r.jsxs)(n.p,{children:["v4 was running on top of ",(0,r.jsx)(n.code,{children:"Microsoft.Extensions.Hosting"}),", so build a Host in the same way and need to convert ConsoleAppBuilder."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"var app = Host.CreateApplicationBuilder()\n    .ToConsoleAppBuilder();\n"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"var app = ConsoleApp.Create(args); app.Run();"})," -> ",(0,r.jsx)(n.code,{children:"var app = ConsoleApp.Create(); app.Run(args);"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"app.AddCommand/AddSubCommand"})," -> ",(0,r.jsx)(n.code,{children:"app.Add(string commandName)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"app.AddRootCommand"})," -> ",(0,r.jsx)(n.code,{children:'app.Add("")'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"app.AddCommands<T>"})," -> ",(0,r.jsx)(n.code,{children:"app.Add<T>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"app.AddSubCommands<T>"})," -> ",(0,r.jsx)(n.code,{children:"app.Add<T>(string commandPath)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"app.AddAllCommandType"})," -> ",(0,r.jsx)(n.code,{children:"NotSupported"}),"(use ",(0,r.jsx)(n.code,{children:"Add<T>"})," manually)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"[Option(int index)]"})," -> ",(0,r.jsx)(n.code,{children:"[Argument]"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"[Option(string shortName, string description)]"})," -> ",(0,r.jsx)(n.code,{children:"Xml Document Comment"}),"(Define short names as parameter aliases in the ",(0,r.jsx)(n.code,{children:"<param>"})," description)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ConsoleAppFilter.Order"})," -> ",(0,r.jsx)(n.code,{children:"NotSupported"}),"(global -> class -> method declarative order)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ConsoleAppOptions.GlobalFilters"})," -> ",(0,r.jsx)(n.code,{children:"app.UseFilter<T>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ConsoleAppBase"})," -> inject ",(0,r.jsx)(n.code,{children:"ConsoleAppContext"}),", ",(0,r.jsx)(n.code,{children:"CancellationToken"})," to method"]}),"\n"]}),(0,r.jsx)(n.h2,{id:"license",children:"License"}),(0,r.jsx)(n.p,{children:"This library is under the MIT License."})]}),"\n",(0,r.jsx)(n.h3,{id:"about",children:"About"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Generating console parser for functions"})}),"\n",(0,r.jsx)(n.h2,{id:"how-to-use",children:"How to use"}),"\n",(0,r.jsx)(n.h3,{id:"example-source-csproj-source-files",children:"Example (source csproj, source files)"}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsxs)(t.A,{value:"csproj",label:"CSharp Project",children:[(0,r.jsxs)(n.p,{children:["This is the CSharp Project that references ",(0,r.jsx)(n.strong,{children:"ConsoleAppFramework"})]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",metastring:"showLineNumbers {14}",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net9.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\t<PropertyGroup>\n\t\t<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n\t\t<CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n\t</PropertyGroup>\n\t<ItemGroup>\n\t  <PackageReference Include="ConsoleAppFramework" Version="5.6.1">\n\t    <PrivateAssets>all</PrivateAssets>\n\t    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n\t  </PackageReference>\n\t</ItemGroup>\n</Project>\n\n'})})]}),(0,r.jsxs)(t.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\ConsoleAppFramework\\src\\ConsoleDemo\\Program.cs",label:"Program.cs",children:[(0,r.jsxs)(n.p,{children:["This is the use of ",(0,r.jsx)(n.strong,{children:"ConsoleAppFramework"})," in ",(0,r.jsx)(n.em,{children:"Program.cs"})]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'var app = ConsoleAppFramework.ConsoleApp.Create();\n\napp.Add("", (string msg) => Console.WriteLine(msg));\napp.Add("echo", (string msg) => Console.WriteLine(msg));\napp.Add("sum", (int x, int y) => Console.WriteLine(x + y));\n\n// --help\n// --msg Andrei\n// echo --msg Andrei\n// sum --x 55 --y 0\napp.Run(args);\n'})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"generated-files",children:"Generated Files"}),"\n",(0,r.jsx)(n.p,{children:"Those are taken from $(BaseIntermediateOutputPath)\\GX"}),"\n",(0,r.jsxs)(i.A,{children:[(0,r.jsx)(t.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\ConsoleAppFramework\\src\\ConsoleDemo\\obj\\GX\\ConsoleAppFramework\\ConsoleAppFramework.ConsoleAppGenerator\\ConsoleApp.Builder.g.cs",label:"ConsoleApp.Builder.g.cs",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated/>\n#nullable enable\n#pragma warning disable\n\nnamespace ConsoleAppFramework;\n\nusing System;\nusing System.Text;\nusing System.Reflection;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Runtime.InteropServices;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics.CodeAnalysis;\nusing System.ComponentModel.DataAnnotations;\n\ninternal static partial class ConsoleApp\n{\n    partial class ConsoleAppBuilder\n    {\n        Action<string> command0 = default!;\n        Action<string> command1 = default!;\n        Action<int, int> command2 = default!;\n\n        partial void AddCore(string commandName, Delegate command)\n        {\n            switch (commandName)\n            {\n                case "":\n                    this.command0 = Unsafe.As<Action<string>>(command);\n                    break;\n                case "echo":\n                    this.command1 = Unsafe.As<Action<string>>(command);\n                    break;\n                case "sum":\n                    this.command2 = Unsafe.As<Action<int, int>>(command);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        partial void RunCore(string[] args, CancellationToken cancellationToken)\n        {\n            if (args.Length == 1 && args[0] is "--help" or "-h")\n            {\n                ShowHelp(-1);\n                return;\n            }\n            if (args.Length == 0)\n            {\n                RunCommand0(args, 0, args.AsSpan().IndexOf("--"), command0, cancellationToken);\n                return;\n            }\n            switch (args[0])\n            {\n                case "echo":\n                    RunCommand1(args, 1, args.AsSpan().IndexOf("--"), command1, cancellationToken);\n                    break;\n                case "sum":\n                    RunCommand2(args, 1, args.AsSpan().IndexOf("--"), command2, cancellationToken);\n                    break;\n                default:\n                    RunCommand0(args, 0, args.AsSpan().IndexOf("--"), command0, cancellationToken);\n                    break;\n            }\n        }\n\n        private static void RunCommand0(string[] args, int commandDepth, int escapeIndex, Action<string> command, CancellationToken __ExternalCancellationToken__)\n        {\n            var commandArgs = (escapeIndex == -1) ? args.AsSpan(commandDepth) : args.AsSpan(commandDepth, escapeIndex - commandDepth);\n            if (TryShowHelpOrVersion(commandArgs, 1, 0)) return;\n\n            var arg0 = default(string);\n            var arg0Parsed = false;\n\n            try\n            {\n                for (int i = 0; i < commandArgs.Length; i++)\n                {\n                    var name = commandArgs[i];\n\n                    switch (name)\n                    {\n                        case "--msg":\n                        {\n                            if (!TryIncrementIndex(ref i, commandArgs.Length)) \\{ ThrowArgumentParseFailed("msg", commandArgs[i]); \\} else \\{ arg0 = commandArgs[i]; }\n                            arg0Parsed = true;\n                            break;\n                        }\n                        default:\n                            if (string.Equals(name, "--msg", StringComparison.OrdinalIgnoreCase))\n                            {\n                                if (!TryIncrementIndex(ref i, commandArgs.Length)) \\{ ThrowArgumentParseFailed("msg", commandArgs[i]); \\} else \\{ arg0 = commandArgs[i]; }\n                                arg0Parsed = true;\n                                break;\n                            }\n                            ThrowArgumentNameNotFound(name);\n                            break;\n                    }\n                }\n                if (!arg0Parsed) ThrowRequiredArgumentNotParsed("msg");\n\n                command(arg0!);\n            }\n            catch (Exception ex)\n            {\n                Environment.ExitCode = 1;\n                if (ex is ValidationException or ArgumentParseFailedException)\n                {\n                    LogError(ex.Message);\n                }\n                else\n                {\n                    LogError(ex.ToString());\n                }\n            }\n        }\n        private static void RunCommand1(string[] args, int commandDepth, int escapeIndex, Action<string> command, CancellationToken __ExternalCancellationToken__)\n        {\n            var commandArgs = (escapeIndex == -1) ? args.AsSpan(commandDepth) : args.AsSpan(commandDepth, escapeIndex - commandDepth);\n            if (TryShowHelpOrVersion(commandArgs, 1, 1)) return;\n\n            var arg0 = default(string);\n            var arg0Parsed = false;\n\n            try\n            {\n                for (int i = 0; i < commandArgs.Length; i++)\n                {\n                    var name = commandArgs[i];\n\n                    switch (name)\n                    {\n                        case "--msg":\n                        {\n                            if (!TryIncrementIndex(ref i, commandArgs.Length)) \\{ ThrowArgumentParseFailed("msg", commandArgs[i]); \\} else \\{ arg0 = commandArgs[i]; }\n                            arg0Parsed = true;\n                            break;\n                        }\n                        default:\n                            if (string.Equals(name, "--msg", StringComparison.OrdinalIgnoreCase))\n                            {\n                                if (!TryIncrementIndex(ref i, commandArgs.Length)) \\{ ThrowArgumentParseFailed("msg", commandArgs[i]); \\} else \\{ arg0 = commandArgs[i]; }\n                                arg0Parsed = true;\n                                break;\n                            }\n                            ThrowArgumentNameNotFound(name);\n                            break;\n                    }\n                }\n                if (!arg0Parsed) ThrowRequiredArgumentNotParsed("msg");\n\n                command(arg0!);\n            }\n            catch (Exception ex)\n            {\n                Environment.ExitCode = 1;\n                if (ex is ValidationException or ArgumentParseFailedException)\n                {\n                    LogError(ex.Message);\n                }\n                else\n                {\n                    LogError(ex.ToString());\n                }\n            }\n        }\n        private static void RunCommand2(string[] args, int commandDepth, int escapeIndex, Action<int, int> command, CancellationToken __ExternalCancellationToken__)\n        {\n            var commandArgs = (escapeIndex == -1) ? args.AsSpan(commandDepth) : args.AsSpan(commandDepth, escapeIndex - commandDepth);\n            if (TryShowHelpOrVersion(commandArgs, 2, 2)) return;\n\n            var arg0 = default(int);\n            var arg0Parsed = false;\n            var arg1 = default(int);\n            var arg1Parsed = false;\n\n            try\n            {\n                for (int i = 0; i < commandArgs.Length; i++)\n                {\n                    var name = commandArgs[i];\n\n                    switch (name)\n                    {\n                        case "--x":\n                        {\n                            if (!TryIncrementIndex(ref i, commandArgs.Length) || !int.TryParse(commandArgs[i], out arg0)) \\{ ThrowArgumentParseFailed("x", commandArgs[i]); }\n                            arg0Parsed = true;\n                            break;\n                        }\n                        case "--y":\n                        {\n                            if (!TryIncrementIndex(ref i, commandArgs.Length) || !int.TryParse(commandArgs[i], out arg1)) \\{ ThrowArgumentParseFailed("y", commandArgs[i]); }\n                            arg1Parsed = true;\n                            break;\n                        }\n                        default:\n                            if (string.Equals(name, "--x", StringComparison.OrdinalIgnoreCase))\n                            {\n                                if (!TryIncrementIndex(ref i, commandArgs.Length) || !int.TryParse(commandArgs[i], out arg0)) \\{ ThrowArgumentParseFailed("x", commandArgs[i]); }\n                                arg0Parsed = true;\n                                break;\n                            }\n                            if (string.Equals(name, "--y", StringComparison.OrdinalIgnoreCase))\n                            {\n                                if (!TryIncrementIndex(ref i, commandArgs.Length) || !int.TryParse(commandArgs[i], out arg1)) \\{ ThrowArgumentParseFailed("y", commandArgs[i]); }\n                                arg1Parsed = true;\n                                break;\n                            }\n                            ThrowArgumentNameNotFound(name);\n                            break;\n                    }\n                }\n                if (!arg0Parsed) ThrowRequiredArgumentNotParsed("x");\n                if (!arg1Parsed) ThrowRequiredArgumentNotParsed("y");\n\n                command(arg0!, arg1!);\n            }\n            catch (Exception ex)\n            {\n                Environment.ExitCode = 1;\n                if (ex is ValidationException or ArgumentParseFailedException)\n                {\n                    LogError(ex.Message);\n                }\n                else\n                {\n                    LogError(ex.ToString());\n                }\n            }\n        }\n    }\n}\n\n'})})}),(0,r.jsx)(t.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\ConsoleAppFramework\\src\\ConsoleDemo\\obj\\GX\\ConsoleAppFramework\\ConsoleAppFramework.ConsoleAppGenerator\\ConsoleApp.Builder.Help.g.cs",label:"ConsoleApp.Builder.Help.g.cs",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated/>\n#nullable enable\n#pragma warning disable\n\nnamespace ConsoleAppFramework;\n\nusing System;\nusing System.Text;\nusing System.Reflection;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Runtime.InteropServices;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics.CodeAnalysis;\nusing System.ComponentModel.DataAnnotations;\n\ninternal static partial class ConsoleApp\n{\n    internal partial class ConsoleAppBuilder\n    {\n        static partial void ShowHelp(int helpId)\n        {\n            switch (helpId)\n            {\n                case 0:\n                    Log("""\nUsage: [options...] [-h|--help] [--version]\n\nOptions:\n  --msg <string>     (Required)\n""");\n                    break;\n                case 1:\n                    Log("""\nUsage: echo [options...] [-h|--help] [--version]\n\nOptions:\n  --msg <string>     (Required)\n""");\n                    break;\n                case 2:\n                    Log("""\nUsage: sum [options...] [-h|--help] [--version]\n\nOptions:\n  --x <int>     (Required)\n  --y <int>     (Required)\n""");\n                    break;\n                default:\n                    Log("""\nUsage: [command] [options...] [-h|--help] [--version]\n\nOptions:\n  --msg <string>     (Required)\n\nCommands:\n  echo\n  sum\n""");\n                    break;\n            }\n        }\n    }\n}\n\n'})})}),(0,r.jsx)(t.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\ConsoleAppFramework\\src\\ConsoleDemo\\obj\\GX\\ConsoleAppFramework\\ConsoleAppFramework.ConsoleAppGenerator\\ConsoleApp.Builder.Run.g.cs",label:"ConsoleApp.Builder.Run.g.cs",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"// <auto-generated/>\n#nullable enable\n#pragma warning disable\n\nnamespace ConsoleAppFramework;\n\nusing System;\nusing System.Text;\nusing System.Reflection;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Runtime.InteropServices;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics.CodeAnalysis;\nusing System.ComponentModel.DataAnnotations;\n\ninternal static partial class ConsoleApp\n{\n    internal partial class ConsoleAppBuilder\n    {\n        public void Run(string[] args) => Run(args, true);\n        public void Run(string[] args, CancellationToken cancellationToken) => Run(args, true, cancellationToken);\n\n        public void Run(string[] args, bool disposeServiceProvider, CancellationToken cancellationToken = default)\n        {\n            BuildAndSetServiceProvider();\n            try\n            {\n                RunCore(args, cancellationToken);\n            }\n            finally\n            {\n                if (disposeServiceProvider)\n                {\n                    if (ServiceProvider is IDisposable d)\n                    {\n                        d.Dispose();\n                    }\n                }\n            }\n        }\n\n        public Task RunAsync(string[] args) => RunAsync(args, true);\n        public Task RunAsync(string[] args, CancellationToken cancellationToken) => RunAsync(args, true, cancellationToken);\n\n        public async Task RunAsync(string[] args, bool disposeServiceProvider, CancellationToken cancellationToken = default)\n        {\n            BuildAndSetServiceProvider();\n            try\n            {\n                Task? task = null;\n                RunAsyncCore(args, cancellationToken, ref task!);\n                if (task != null)\n                {\n                    await task;\n                }\n            }\n            finally\n            {\n                if (disposeServiceProvider)\n                {\n                    if (ServiceProvider is IAsyncDisposable ad)\n                    {\n                        await ad.DisposeAsync();\n                    }\n                    else if (ServiceProvider is IDisposable d)\n                    {\n                        d.Dispose();\n                    }\n                }\n            }\n        }\n    }\n}\n"})})}),(0,r.jsx)(t.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\ConsoleAppFramework\\src\\ConsoleDemo\\obj\\GX\\ConsoleAppFramework\\ConsoleAppFramework.ConsoleAppGenerator\\ConsoleApp.g.cs",label:"ConsoleApp.g.cs",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated/>\n#nullable enable\n#pragma warning disable\n\nnamespace ConsoleAppFramework;\n\nusing System;\nusing System.Text;\nusing System.Reflection;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Runtime.InteropServices;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics.CodeAnalysis;\nusing System.ComponentModel.DataAnnotations;\n\n#if !USE_EXTERNAL_CONSOLEAPP_ABSTRACTIONS\n\ninternal interface IArgumentParser<T>\n{\n    static abstract bool TryParse(ReadOnlySpan<char> s, out T result);\n}\n\ninternal record ConsoleAppContext\n{\n    public string CommandName \\{ get; init; }\n    public string[] Arguments \\{ get; init; }\n    public object? State \\{ get; init; }\n    internal int CommandDepth \\{ get; }\n    internal int EscapeIndex  \\{ get; }\n\n    public ReadOnlySpan<string> CommandArguments\n    {\n        get => (EscapeIndex == -1)\n            ? Arguments.AsSpan(CommandDepth)\n            : Arguments.AsSpan(CommandDepth, EscapeIndex - CommandDepth);\n    }\n\n    public ReadOnlySpan<string> EscapedArguments\n    {\n        get => (EscapeIndex == -1)\n            ? Array.Empty<string>()\n            : Arguments.AsSpan(EscapeIndex + 1);\n    }\n\n    public ConsoleAppContext(string commandName, string[] arguments, object? state, int commandDepth, int escapeIndex)\n    {\n        this.CommandName = commandName;\n        this.Arguments = arguments;\n        this.State = state;\n        this.CommandDepth = commandDepth;\n        this.EscapeIndex = escapeIndex;\n    }\n\n    public override string ToString()\n    {\n        return string.Join(" ", Arguments);\n    }\n}\n\ninternal abstract class ConsoleAppFilter(ConsoleAppFilter next)\n{\n    protected readonly ConsoleAppFilter Next = next;\n\n    public abstract Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken);\n}\n\n[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = false)]\ninternal sealed class ConsoleAppFilterAttribute<T> : Attribute\n    where T : ConsoleAppFilter\n{\n}\n\ninternal sealed class ArgumentParseFailedException(string message) : Exception(message)\n{\n}\n\n#endif\n\n[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\ninternal sealed class FromServicesAttribute : Attribute\n{\n}\n\n[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\ninternal sealed class ArgumentAttribute : Attribute\n{\n}\n\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]\ninternal sealed class CommandAttribute : Attribute\n{\n    public string Command \\{ get; }\n\n    public CommandAttribute(string command)\n    {\n        this.Command = command;\n    }\n}\n\n[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\ninternal sealed class HiddenAttribute : Attribute\n{\n}\n\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]\ninternal sealed class RegisterCommandsAttribute : Attribute\n{\n    public string CommandPath \\{ get; }\n\n    public RegisterCommandsAttribute()\n    {\n        this.CommandPath = "";\n    }\n\n    public RegisterCommandsAttribute(string commandPath)\n    {\n        this.CommandPath = commandPath;\n    }\n}\n\n[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)]\npublic class ConsoleAppFrameworkGeneratorOptionsAttribute : Attribute\n{\n    public bool DisableNamingConversion \\{ get; set; }\n}\n\n[UnconditionalSuppressMessage("Trimming", "IL2026")]\n[UnconditionalSuppressMessage("AOT", "IL3050")]\ninternal static partial class ConsoleApp\n{\n    public static IServiceProvider? ServiceProvider \\{ get; set; }\n    public static TimeSpan Timeout \\{ get; set; \\} = TimeSpan.FromSeconds(5);\n    public static System.Text.Json.JsonSerializerOptions? JsonSerializerOptions \\{ get; set; }\n    public static string? Version \\{ get; set; }\n\n    static Action<string>? logAction;\n    public static Action<string> Log\n    {\n        get => logAction ??= Console.WriteLine;\n        set => logAction = value;\n    }\n\n    static Action<string>? logErrorAction;\n    public static Action<string> LogError\n    {\n        get => logErrorAction ??= (static msg => Log(msg));\n        set => logErrorAction = value;\n    }\n\n    /// <summary>\n    /// <para>You can pass second argument that generates new Run overload.</para>\n    /// ConsoleApp.Run(args, (int x, int y) => \\{ });<br/>\n    /// ConsoleApp.Run(args, Foo);<br/>\n    /// ConsoleApp.Run(args, &amp;Foo);<br/>\n    /// </summary>\n    public static void Run(string[] args)\n    {\n    }\n\n    /// <summary>\n    /// <para>You can pass second argument that generates new RunAsync overload.</para>\n    /// ConsoleApp.RunAsync(args, (int x, int y) => \\{ });<br/>\n    /// ConsoleApp.RunAsync(args, Foo);<br/>\n    /// ConsoleApp.RunAsync(args, &amp;Foo);<br/>\n    /// </summary>\n    public static Task RunAsync(string[] args)\n    {\n        return Task.CompletedTask;\n    }\n\n    public static ConsoleAppBuilder Create() => new ConsoleAppBuilder();\n\n    static void ThrowArgumentParseFailed(string argumentName, string value)\n    {\n        throw new ArgumentParseFailedException($"Argument \'{argumentName}\' failed to parse, provided value: {value}");\n    }\n\n    static void ThrowRequiredArgumentNotParsed(string name)\n    {\n        throw new ArgumentParseFailedException($"Required argument \'{name}\' was not specified.");\n    }\n\n    static void ThrowArgumentNameNotFound(string argumentName)\n    {\n        throw new ArgumentParseFailedException($"Argument \'{argumentName}\' is not recognized.");\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    static bool TryIncrementIndex(ref int index, int length)\n    {\n        if ((index + 1) < length)\n        {\n            index += 1;\n            return true;\n        }\n        return false;\n    }\n\n    static bool TryParseParamsArray<T>(ReadOnlySpan<string> args, ref T[] result, ref int i)\n       where T : IParsable<T>\n    {\n        result = new T[args.Length - i];\n        var resultIndex = 0;\n        for (; i < args.Length; i++)\n        {\n            if (!T.TryParse(args[i], null, out result[resultIndex++]!)) return false;\n        }\n        return true;\n    }\n\n    static bool TrySplitParse<T>(ReadOnlySpan<char> s, out T[] result)\n       where T : ISpanParsable<T>\n    {\n        if (s.StartsWith("["))\n        {\n            try\n            {\n                result = System.Text.Json.JsonSerializer.Deserialize<T[]>(s, JsonSerializerOptions)!;\n                return true;\n            }\n            catch\n            {\n                result = default!;\n                return false;\n            }\n        }\n\n        var count = s.Count(\',\') + 1;\n        result = new T[count];\n\n        var source = s;\n        var destination = result.AsSpan();\n        Span<Range> ranges = stackalloc Range[Math.Min(count, 128)];\n\n        while (true)\n        {\n            var splitCount = source.Split(ranges, \',\');\n            var parseTo = splitCount;\n            if (splitCount == 128 && source[ranges[^1]].Contains(\',\'))\n            {\n                parseTo = splitCount - 1;\n            }\n\n            for (int i = 0; i < parseTo; i++)\n            {\n                if (!T.TryParse(source[ranges[i]], null, out destination[i]!))\n                {\n                    return false;\n                }\n            }\n            destination = destination.Slice(parseTo);\n\n            if (destination.Length != 0)\n            {\n                source = source[ranges[^1]];\n                continue;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    static void ValidateParameter(object? value, ParameterInfo parameter, ValidationContext validationContext, ref StringBuilder? errorMessages)\n    {\n        validationContext.DisplayName = parameter.Name ?? "";\n        validationContext.Items.Clear();\n\n        foreach (var validator in parameter.GetCustomAttributes<ValidationAttribute>(false))\n        {\n            var result = validator.GetValidationResult(value, validationContext);\n            if (result != null)\n            {\n                if (errorMessages == null)\n                {\n                    errorMessages = new StringBuilder();\n                }\n                errorMessages.AppendLine(result.ErrorMessage);\n            }\n        }\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    static bool TryShowHelpOrVersion(ReadOnlySpan<string> args, int requiredParameterCount, int helpId)\n    {\n        if (args.Length == 0)\n        {\n            if (requiredParameterCount == 0) return false;\n\n            ShowHelp(helpId);\n            return true;\n        }\n\n        if (args.Length == 1)\n        {\n            switch (args[0])\n            {\n                case "--version":\n                    ShowVersion();\n                    return true;\n                case "-h":\n                case "--help":\n                    ShowHelp(helpId);\n                    return true;\n                default:\n                    break;\n            }\n        }\n\n        return false;\n    }\n\n    static void ShowVersion()\n    {\n        if (Version != null)\n        {\n            Log(Version);\n            return;\n        }\n\n        var asm = Assembly.GetEntryAssembly();\n        var version = "1.0.0";\n        var infoVersion = asm!.GetCustomAttribute<AssemblyInformationalVersionAttribute>();\n        if (infoVersion != null)\n        {\n            version = infoVersion.InformationalVersion;\n            var i = version.IndexOf(\'+\');\n            if (i != -1)\n            {\n                version = version.Substring(0, i);\n            }\n        }\n        else\n        {\n            var asmVersion = asm!.GetCustomAttribute<AssemblyVersionAttribute>();\n            if (asmVersion != null)\n            {\n                version = asmVersion.Version;\n            }\n        }\n        Log(version);\n    }\n\n    static partial void ShowHelp(int helpId);\n\n    static async Task RunWithFilterAsync(string commandName, string[] args, int commandDepth, int escapeIndex, ConsoleAppFilter invoker, CancellationToken cancellationToken)\n    {\n        using var posixSignalHandler = PosixSignalHandler.Register(Timeout, cancellationToken);\n        try\n        {\n            await Task.Run(() => invoker.InvokeAsync(new ConsoleAppContext(commandName, args, null, commandDepth, escapeIndex), posixSignalHandler.Token)).WaitAsync(posixSignalHandler.TimeoutToken);\n        }\n        catch (Exception ex)\n        {\n            if (ex is OperationCanceledException)\n            {\n                Environment.ExitCode = 130;\n                return;\n            }\n\n            Environment.ExitCode = 1;\n            if (ex is ValidationException or ArgumentParseFailedException)\n            {\n                LogError(ex.Message);\n            }\n            else\n            {\n                LogError(ex.ToString());\n            }\n        }\n    }\n\n    sealed class PosixSignalHandler : IDisposable\n    {\n        public CancellationToken Token => cancellationTokenSource.Token;\n        public CancellationToken TimeoutToken => timeoutCancellationTokenSource.Token;\n\n        CancellationTokenSource cancellationTokenSource;\n        CancellationTokenSource timeoutCancellationTokenSource;\n        TimeSpan timeout;\n\n        PosixSignalRegistration? sigInt;\n        PosixSignalRegistration? sigQuit;\n        PosixSignalRegistration? sigTerm;\n\n        PosixSignalHandler(TimeSpan timeout, CancellationToken cancellationToken)\n        {\n            this.cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\n            this.timeoutCancellationTokenSource = new CancellationTokenSource();\n            this.timeout = timeout;\n        }\n\n        public static PosixSignalHandler Register(TimeSpan timeout, CancellationToken cancellationToken)\n        {\n            var handler = new PosixSignalHandler(timeout, cancellationToken);\n\n            Action<PosixSignalContext> handleSignal = handler.HandlePosixSignal;\n\n            handler.sigInt = PosixSignalRegistration.Create(PosixSignal.SIGINT, handleSignal);\n            handler.sigQuit = PosixSignalRegistration.Create(PosixSignal.SIGQUIT, handleSignal);\n            handler.sigTerm = PosixSignalRegistration.Create(PosixSignal.SIGTERM, handleSignal);\n\n            return handler;\n        }\n\n        void HandlePosixSignal(PosixSignalContext context)\n        {\n            context.Cancel = true;\n            cancellationTokenSource.Cancel();\n            timeoutCancellationTokenSource.CancelAfter(timeout);\n        }\n\n        public void Dispose()\n        {\n            sigInt?.Dispose();\n            sigQuit?.Dispose();\n            sigTerm?.Dispose();\n            cancellationTokenSource.Dispose();\n            timeoutCancellationTokenSource.Dispose();\n        }\n    }\n\n    struct SyncAsyncDisposeWrapper<T>(T value) : IDisposable\n        where T : IAsyncDisposable\n    {\n        public readonly T Value => value;\n\n        public void Dispose()\n        {\n            value.DisposeAsync().AsTask().GetAwaiter().GetResult();\n        }\n    }\n\n    internal partial class ConsoleAppBuilder\n    {\n        public ConsoleAppBuilder()\n        {\n        }\n\n        public void Add(string commandName, Delegate command)\n        {\n            AddCore(commandName, command);\n        }\n\n        [System.Diagnostics.Conditional("DEBUG")]\n        public void Add<T>() \\{ }\n\n        [System.Diagnostics.Conditional("DEBUG")]\n        public void Add<T>(string commandPath) \\{ }\n\n        [System.Diagnostics.Conditional("DEBUG")]\n        public void UseFilter<T>() where T : ConsoleAppFilter \\{ }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        partial void AddCore(string commandName, Delegate command);\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        partial void RunCore(string[] args, CancellationToken cancellationToken);\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        partial void RunAsyncCore(string[] args, CancellationToken cancellationToken, ref Task result);\n\n        partial void BuildAndSetServiceProvider();\n\n        static partial void ShowHelp(int helpId);\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static bool TryShowHelpOrVersion(ReadOnlySpan<string> args, int requiredParameterCount, int helpId)\n        {\n            if (args.Length == 0)\n            {\n                if (requiredParameterCount == 0) return false;\n\n                ShowHelp(helpId);\n                return true;\n            }\n\n            if (args.Length == 1)\n            {\n                switch (args[0])\n                {\n                    case "--version":\n                        ShowVersion();\n                        return true;\n                    case "-h":\n                    case "--help":\n                        ShowHelp(helpId);\n                        return true;\n                    default:\n                        break;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"useful",children:"Useful"}),"\n",(0,r.jsx)(n.h3,{id:"download-example-net--c",children:"Download Example (.NET  C#)"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:o(726).A+"",children:"Download Example project ConsoleAppFramework "})})}),"\n",(0,r.jsx)(n.h3,{id:"share-consoleappframework",children:"Share ConsoleAppFramework"}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FConsoleAppFramework&quote=ConsoleAppFramework",title:"Share on Facebook",target:"_blank",children:"Share on Facebook"})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FConsoleAppFramework&text=ConsoleAppFramework:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FConsoleAppFramework",target:"_blank",title:"Tweet",children:"Share in Twitter"})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FConsoleAppFramework&title=ConsoleAppFramework",target:"_blank",title:"Submit to Reddit",children:"Share on Reddit"})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FConsoleAppFramework&title=ConsoleAppFramework&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FConsoleAppFramework",target:"_blank",title:"Share on LinkedIn",children:"Share on Linkedin"})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/ConsoleAppFramework",children:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/ConsoleAppFramework"})}),"\n",(0,r.jsx)(c.Ay,{})]})}function g(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);