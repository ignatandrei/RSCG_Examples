"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[9982],{18978:(e,t,n)=>{n.d(t,{Ay:()=>o,RM:()=>s});var r=n(74848),a=n(28453);const s=[{value:"Category &quot;FunctionalProgramming&quot; has the following generators:",id:"category-functionalprogramming-has-the-following-generators",level:3},{value:"See category",id:"see-category",level:3}];function i(e){const t={a:"a",h3:"h3",p:"p",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h3,{id:"category-functionalprogramming-has-the-following-generators",children:'Category "FunctionalProgramming" has the following generators:'}),"\n",(0,r.jsxs)(t.p,{children:["1 ",(0,r.jsx)(t.a,{href:"/docs/cachesourcegenerator",children:"cachesourcegenerator"})]}),"\n",(0,r.jsxs)(t.p,{children:["2 ",(0,r.jsx)(t.a,{href:"/docs/dunet",children:"dunet"})]}),"\n",(0,r.jsxs)(t.p,{children:["3 ",(0,r.jsx)(t.a,{href:"/docs/Dusharp",children:"Dusharp"})]}),"\n",(0,r.jsxs)(t.p,{children:["4 ",(0,r.jsx)(t.a,{href:"/docs/Funcky.DiscriminatedUnion",children:"Funcky.DiscriminatedUnion"})]}),"\n",(0,r.jsxs)(t.p,{children:["5 ",(0,r.jsx)(t.a,{href:"/docs/FunicularSwitch",children:"FunicularSwitch"})]}),"\n",(0,r.jsxs)(t.p,{children:["6 ",(0,r.jsx)(t.a,{href:"/docs/N.SourceGenerators.UnionTypes",children:"N.SourceGenerators.UnionTypes"})]}),"\n",(0,r.jsxs)(t.p,{children:["7 ",(0,r.jsx)(t.a,{href:"/docs/OneOf",children:"OneOf"})]}),"\n",(0,r.jsxs)(t.p,{children:["8 ",(0,r.jsx)(t.a,{href:"/docs/PartiallyApplied",children:"PartiallyApplied"})]}),"\n",(0,r.jsxs)(t.p,{children:["9 ",(0,r.jsx)(t.a,{href:"/docs/polytype",children:"polytype"})]}),"\n",(0,r.jsxs)(t.p,{children:["10 ",(0,r.jsx)(t.a,{href:"/docs/rscg_demeter",children:"rscg_demeter"})]}),"\n",(0,r.jsxs)(t.p,{children:["11 ",(0,r.jsx)(t.a,{href:"/docs/rscg_queryables",children:"rscg_queryables"})]}),"\n",(0,r.jsxs)(t.p,{children:["12 ",(0,r.jsx)(t.a,{href:"/docs/RSCG_Utils_Memo",children:"RSCG_Utils_Memo"})]}),"\n",(0,r.jsxs)(t.p,{children:["13 ",(0,r.jsx)(t.a,{href:"/docs/Sera.Union",children:"Sera.Union"})]}),"\n",(0,r.jsxs)(t.p,{children:["14 ",(0,r.jsx)(t.a,{href:"/docs/TypeUtilities",children:"TypeUtilities"})]}),"\n",(0,r.jsxs)(t.p,{children:["15 ",(0,r.jsx)(t.a,{href:"/docs/UnionGen",children:"UnionGen"})]}),"\n",(0,r.jsxs)(t.p,{children:["16 ",(0,r.jsx)(t.a,{href:"/docs/UnionsGenerator",children:"UnionsGenerator"})]}),"\n",(0,r.jsx)(t.h3,{id:"see-category",children:"See category"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"/docs/Categories/FunctionalProgramming",children:"FunctionalProgramming"})})]})}function o(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}},19505:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/files/UnionsGenerator-f2b056f28cc1754214c60350f76aeb6d.zip"},43510:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>m,default:()=>h,frontMatter:()=>u,metadata:()=>r,toc:()=>y});const r=JSON.parse('{"id":"RSCG-Examples/UnionsGenerator","title":"115 - UnionsGenerator","description":"Generating Union types for C#","source":"@site/docs/RSCG-Examples/UnionsGenerator.md","sourceDirName":"RSCG-Examples","slug":"/UnionsGenerator","permalink":"/RSCG_Examples/v2/docs/UnionsGenerator","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1150,"frontMatter":{"sidebar_position":1150,"title":"115 - UnionsGenerator","description":"Generating Union types for C#","slug":"/UnionsGenerator"},"sidebar":"tutorialSidebar","previous":{"title":"114 - corecraft","permalink":"/RSCG_Examples/v2/docs/corecraft"},"next":{"title":"116 - CopyTo","permalink":"/RSCG_Examples/v2/docs/CopyTo"}}');var a=n(74848),s=n(28453),i=n(11470),o=n(19365),l=n(14252),p=n(18978);const u={sidebar_position:1150,title:"115 - UnionsGenerator",description:"Generating Union types for C#",slug:"/UnionsGenerator"},m="UnionsGenerator  by Paul Braetz",c={},y=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example (source csproj, source files)",id:"example-source-csproj-source-files",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C#)",id:"download-example-net--c",level:3},{value:"Share UnionsGenerator",id:"share-unionsgenerator",level:3},...p.RM];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"unionsgenerator--by-paul-braetz",children:"UnionsGenerator  by Paul Braetz"})}),"\n",(0,a.jsx)(l.A,{toc:y}),"\n",(0,a.jsx)(t.h2,{id:"nuget--site-data",children:"NuGet / site data"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://www.nuget.org/packages/RhoMicro.CodeAnalysis.UnionsGenerator",children:(0,a.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/RhoMicro.CodeAnalysis.UnionsGenerator?label=RhoMicro.CodeAnalysis.UnionsGenerator",alt:"Nuget"})}),"\n",(0,a.jsx)(t.a,{href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/",children:(0,a.jsx)(t.img,{src:"https://img.shields.io/github/last-commit/PaulBraetz/RhoMicro.CodeAnalysis?label=updated",alt:"GitHub last commit"})}),"\n",(0,a.jsx)(t.img,{src:"https://img.shields.io/github/stars/PaulBraetz/RhoMicro.CodeAnalysis?style=social",alt:"GitHub Repo stars"})]}),"\n",(0,a.jsx)(t.h2,{id:"details",children:"Details"}),"\n",(0,a.jsx)(t.h3,{id:"info",children:"Info"}),"\n",(0,a.jsxs)(t.admonition,{type:"info",children:[(0,a.jsxs)(t.p,{children:["Name: ",(0,a.jsx)(t.strong,{children:"UnionsGenerator"})]}),(0,a.jsx)(t.p,{children:"Generate hybrid (tagged/type) union types."}),(0,a.jsx)(t.p,{children:"Author: Paul Braetz"}),(0,a.jsxs)(t.p,{children:["NuGet:\n",(0,a.jsx)(t.em,{children:(0,a.jsx)(t.a,{href:"https://www.nuget.org/packages/RhoMicro.CodeAnalysis.UnionsGenerator",children:"https://www.nuget.org/packages/RhoMicro.CodeAnalysis.UnionsGenerator"})})]}),(0,a.jsxs)(t.p,{children:["You can find more details at ",(0,a.jsx)(t.a,{href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/",children:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/"})]}),(0,a.jsxs)(t.p,{children:["Source: ",(0,a.jsx)(t.a,{href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/",children:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/"})]})]}),"\n",(0,a.jsx)(t.h3,{id:"original-readme",children:"Original Readme"}),"\n",(0,a.jsxs)(t.admonition,{type:"note",children:[(0,a.jsx)(t.h1,{id:"rhomicrocodeanalysis",children:"Rhomicro.CodeAnalysis"}),(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis/actions/workflows/buildPublish.yml/badge.svg",alt:"Build"})}),(0,a.jsx)(t.p,{children:"This repository contains my explorations on c# source code generation and analysis."}),(0,a.jsxs)(t.p,{children:["The [UnionsGenerator](",(0,a.jsx)(t.a,{href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//UnionsGenerator",children:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//UnionsGenerator"})," generator enables the use of union types in C#."]}),(0,a.jsxs)(t.p,{children:["The [UtilityGenerators](",(0,a.jsx)(t.a,{href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//UtilityGenerators",children:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//UtilityGenerators"})," generator helps you write code generators and analyzers."]}),(0,a.jsxs)(t.p,{children:["The [CopyTo](",(0,a.jsx)(t.a,{href:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//CopyTo",children:"https://github.com/PaulBraetz/RhoMicro.CodeAnalysis//CopyTo"})," generator generates methods to copy the contents of one instance to another. I created this generator for a friend, so it is not as feature rich as it could be."]})]}),"\n",(0,a.jsx)(t.h3,{id:"about",children:"About"}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"Generating Union types for C#"})}),"\n",(0,a.jsx)(t.h2,{id:"how-to-use",children:"How to use"}),"\n",(0,a.jsx)(t.h3,{id:"example-source-csproj-source-files",children:"Example (source csproj, source files)"}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsxs)(o.A,{value:"csproj",label:"CSharp Project",children:[(0,a.jsxs)(t.p,{children:["This is the CSharp Project that references ",(0,a.jsx)(t.strong,{children:"UnionsGenerator"})]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-xml",metastring:"showLineNumbers {16}",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n\t<PropertyGroup>\n\t\t<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n\t\t<CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n\t</PropertyGroup>\n\n\t<ItemGroup>\n\t  <PackageReference Include="RhoMicro.CodeAnalysis.UnionsGenerator" Version="14.0.2">\n\t    <PrivateAssets>all</PrivateAssets>\n\t    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n\t  </PackageReference>\n\t</ItemGroup>\n</Project>\n\n'})})]}),(0,a.jsxs)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\Program.cs",label:"Program.cs",children:[(0,a.jsxs)(t.p,{children:["This is the use of ",(0,a.jsx)(t.strong,{children:"UnionsGenerator"})," in ",(0,a.jsx)(t.em,{children:"Program.cs"})]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'using UnionTypesDemo;\n\nConsole.WriteLine("Save or not");\nvar data = SaveToDatabase.Save(0);\nConsole.WriteLine(data.IsValidationError);\ndata = SaveToDatabase.Save(1);\nConsole.WriteLine(data.IsSuccess);\n\n'})})]}),(0,a.jsxs)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\ResultSave.cs",label:"ResultSave.cs",children:[(0,a.jsxs)(t.p,{children:["This is the use of ",(0,a.jsx)(t.strong,{children:"UnionsGenerator"})," in ",(0,a.jsx)(t.em,{children:"ResultSave.cs"})]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"using RhoMicro.CodeAnalysis;\nnamespace UnionTypesDemo;\npublic record Success(int Value);\npublic record ValidationError(string Message);\n\n[UnionType<Success>]\n[UnionTypeAttribute<ValidationError>]\npublic partial class ResultSave\n{\n}\n\n\n\n"})})]}),(0,a.jsxs)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\SaveToDatabase.cs",label:"SaveToDatabase.cs",children:[(0,a.jsxs)(t.p,{children:["This is the use of ",(0,a.jsx)(t.strong,{children:"UnionsGenerator"})," in ",(0,a.jsx)(t.em,{children:"SaveToDatabase.cs"})]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'namespace UnionTypesDemo;\n\npublic class SaveToDatabase\n{\n    public static ResultSave Save(int i)\n    {\n        if(i ==0)\n        {\n            return new ValidationError(" cannot save 0");\n        }\n        return new Success(i);\n    }\n}\n\n\n\n'})})]})]}),"\n",(0,a.jsx)(t.h3,{id:"generated-files",children:"Generated Files"}),"\n",(0,a.jsx)(t.p,{children:"Those are taken from $(BaseIntermediateOutputPath)\\GX"}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\RhoMicro_CodeAnalysis_RelationTypeAttribute.g.cs",label:"RhoMicro_CodeAnalysis_RelationTypeAttribute.g.cs",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated>\n// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#nullable enable\n#pragma warning disable\n\nnamespace RhoMicro.CodeAnalysis\n{\n    using System;\n\n    /// <summary>\n    /// Marks the target type to be related to another union type.\n    /// </summary>\n    /// <typeparam name="T0">The type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n#if UNIONS_GENERATOR\n    [GenerateFactory(OmitTypeCheck = true)]\n#endif\n    sealed partial class RelationAttribute<T0> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T3">The fourth type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2, T3> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T3">The fourth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T4">The fifth type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2, T3, T4> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T3">The fourth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T4">The fifth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T5">The sixth type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2, T3, T4, T5> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T3">The fourth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T4">The fifth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T5">The sixth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T6">The seventh type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2, T3, T4, T5, T6> : Attribute\n    { }\n    /// <summary>\n    /// Marks the target type to be related to other union types.\n    /// </summary>\n    /// <typeparam name="T0">The first type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T1">The second type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T2">The third type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T3">The fourth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T4">The fifth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T5">The sixth type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T6">The seventh type to register as related to the target union type.</typeparam>\n    /// <typeparam name="T7">The eighth type to register as related to the target union type.</typeparam>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class RelationAttribute<T0, T1, T2, T3, T4, T5, T6, T7> : Attribute\n    { }\n}\n\n'})})}),(0,a.jsx)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\RhoMicro_CodeAnalysis_UnionFactoryAttribute.g.cs",label:"RhoMicro_CodeAnalysis_UnionFactoryAttribute.g.cs",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"// <auto-generated>\n// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#nullable enable\n#pragma warning disable\n\nnamespace RhoMicro.CodeAnalysis\n{\n    using System;\n\n    /// <summary>\n    /// Marks the target method as the factory method to use when instantiating \n    /// an instance of the union type representing a value of the annotated parameter.\n    /// Factory methods must be static, have no type parameters and only have one \n    /// parameter of a type representable by the union type. \n    /// Factory polymorphism is not yet supported.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\n#if UNIONS_GENERATOR\n    [GenerateFactory]\n#endif\n    sealed partial class UnionTypeFactoryAttribute : Attribute\n    { }\n}\n\n"})})}),(0,a.jsx)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\RhoMicro_CodeAnalysis_UnionsGenerator_Generated_Util.g.cs",label:"RhoMicro_CodeAnalysis_UnionsGenerator_Generated_Util.g.cs",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated>\n// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#nullable enable\n#pragma warning disable\n\nnamespace RhoMicro.CodeAnalysis.UnionsGenerator.Generated\n{\n    using System.Collections.Concurrent;\n    using System.Collections.Generic;\n    using System.Text;\n    using System.Linq;\n    using System;\n\n    [System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n    internal static class Util\n    {\n        private readonly static ConcurrentDictionary<Type, String> _cache = new();\n        internal static String GetFullString(Type type) => _cache.GetOrAdd(type, ValueFactory);\n        static String ValueFactory(Type type)\n        {\n            var result = getString(type, new());\n\n            return result;\n\n            static String getString(Type type, StringBuilder builder)\n            {\n                var unboundTransitiveParameters = 0;\n                var transitiveParameters = new List<(String Format, Type? Argument)>();\n                append(type, builder, transitiveParameters, ref unboundTransitiveParameters);\n                var result = builder.ToString();\n\n                for(var i = 0; i < transitiveParameters.Count; i++)\n                {\n                    _ = builder.Clear();\n                    var (format, argument) = transitiveParameters[i];\n                    var replacement = getString(argument!, builder);\n                    result = result.Replace(format, replacement);\n                }\n\n                return result;\n\n                static void append(\n                    Type type,\n                    StringBuilder builder,\n                    List<(String Format, Type? Argument)> transitiveArgumentsMap,\n                    ref Int32 unboundTransitiveParameters)\n                {\n#if NETSTANDARD2_0\n                        if(type.IsGenericParameter && type.DeclaringMethod is null)\n#else\n                    if(type.IsGenericTypeParameter)\n#endif\n                    {\n                        var format = $"{Guid.NewGuid()}";\n                        _ = builder.Append(format);\n                        transitiveArgumentsMap.Add((format, null));\n                        unboundTransitiveParameters++;\n                        return;\n                    } else if(type.DeclaringType != null)\n                    {\n                        append(type.DeclaringType, builder, transitiveArgumentsMap, ref unboundTransitiveParameters);\n                        _ = builder.Append(\'.\');\n                    } else if(type.Namespace != null)\n                    {\n                        _ = builder.Append(type.Namespace)\n                                .Append(\'.\');\n                    }\n\n                    var tickIndex = type.Name.IndexOf(\'`\');\n                    _ = tickIndex != -1 ?\n#if NETSTANDARD2_0\n                            builder.Append(type.Name.Substring(0, tickIndex)) :\n#else\n                        builder.Append(type.Name.AsSpan(0, tickIndex)) :\n#endif\n                        builder.Append(type.Name);\n\n                    var arguments = type.GetGenericArguments();\n                    var inflectionPoint = unboundTransitiveParameters;\n                    if(arguments.Length > 0 && unboundTransitiveParameters > 0)\n                    {\n                        for(; unboundTransitiveParameters > 0;)\n                        {\n                            unboundTransitiveParameters--;\n                            var (format, _) = transitiveArgumentsMap[unboundTransitiveParameters];\n                            transitiveArgumentsMap[unboundTransitiveParameters] = (format, arguments[unboundTransitiveParameters]);\n                        }\n                    }\n\n                    if(arguments.Length > inflectionPoint)\n                    {\n                        _ = builder.Append(\'<\');\n                        append(arguments[inflectionPoint], builder, transitiveArgumentsMap, ref unboundTransitiveParameters);\n\n                        for(var i = inflectionPoint + 1; i < type.GenericTypeArguments.Length; i++)\n                        {\n                            _ = builder.Append(", ");\n                            append(arguments[i], builder, transitiveArgumentsMap, ref unboundTransitiveParameters);\n                        }\n\n                        _ = builder.Append(\'>\');\n                    }\n                }\n            }\n        }\n        \n        internal static System.Boolean IsMarked(Type type) =>\n            type.CustomAttributes.Any(a => a.AttributeType.FullName == "RhoMicro.CodeAnalysis.UnionTypeAttribute") ||\n            type.GenericTypeArguments.Any(t => t.CustomAttributes.Any(a => \n                a.AttributeType.FullName.StartsWith("RhoMicro.CodeAnalysis.UnionTypeAttribute`") \n                && a.AttributeType.GenericTypeArguments.Length < 255));\n\n        private static readonly System.Collections.Concurrent.ConcurrentDictionary<(Type, Type), Object> _conversionImplementations = new();\n        internal static TTo UnsafeConvert<TFrom, TTo>(in TFrom from)\n        {\n            var impl = (System.Func<TFrom, TTo>)_conversionImplementations.GetOrAdd((typeof(TFrom), typeof(TTo)), k =>\n            {\n                var param = System.Linq.Expressions.Expression.Parameter(k.Item1);\n                var castExpr = System.Linq.Expressions.Expression.Convert(param, k.Item2);\n                var lambda = System.Linq.Expressions.Expression.Lambda(castExpr, param).Compile();\n\n                return lambda;\n            });\n            var result = impl.Invoke(from);\n\n            return result;\n        }\n    }\n}\n'})})}),(0,a.jsx)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\RhoMicro_CodeAnalysis_UnionTypeAttribute.g.cs",label:"RhoMicro_CodeAnalysis_UnionTypeAttribute.g.cs",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated>\n// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#nullable enable\n#pragma warning disable\n\nnamespace RhoMicro.CodeAnalysis\n{\n    using System;\n    using System.Collections.Generic;\n\n    /// <summary>\n    /// Defines options for generating union types.\n    /// </summary>\n    [Flags]\n    enum UnionTypeOptions\n    {\n        /// <summary>\n        /// The default options.\n        /// </summary>\n        Default = ImplicitConversionIfSolitary,\n        /// <summary>\n        /// </summary>\n        None = 0x00,\n        /// <summary>\n        /// Instructs the generator to emit an implicit conversion to the representable type if it is the only one.\n        /// In effect, this option will enable the union type to act as an alias wrapper for the representable type.\n        /// </summary>\n        ImplicitConversionIfSolitary = 0x01,\n        /// <summary>\n        /// Instructs the generator to emit a superset conversion operator implementation even though\n        /// the representable type is a generic type parameter. By default, it is omitted because of possible\n        /// unification for certain generic arguments.\n        /// </summary>\n        //SupersetOfParameter = 0x02,\n        /// <summary>\n        /// Instructs the generator to treat the representable reference type \n        /// as nullable, allowing for <see langword="null"/> \n        /// arguments in factories, conversions etc.\n        /// </summary>\n        Nullable = 0x04\n    }\n\n    /// <summary>\n    /// Defines options for the storage implementation of a representable type.\n    /// In order for the generator to generate an efficient storage implementation, \n    /// consumers should communicate whether the representable type is known to\n    /// be a struct, class or of unknown nature. This is mostly relevant for generic\n    /// type parameters, however an explicit strategy may be selected for any representable\n    /// type. Whether or not generic type parameters are known to be reference\n    /// or value types depends on their constraints. Parameters constrained to \n    /// <see langword="struct"/> will be assumed to be value types. Conversely,\n    /// parameters constrained to <see langword="class"/> will be assumed to be reference types.\n    /// </summary>\n    /*\n               | box |value| auto | field\n        struct | rc! | vc  | vc   | cc\n        class  | rc  | rc! | rc   | cc\n        none   | rc! | vc! | rc!  | cc\n    */\n    enum StorageOption\n    {\n        /// <summary>\n        /// The generator will automatically decide on a storage strategy.\n        /// <para>\n        /// If the representable type is <b>known to be a value type</b>,\n        /// this will store values of that type inside a shared value type container.\n        /// <b>Boxing will not occur.</b>\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>known to be a reference type</b>,\n        /// this will store values of that type inside a shared reference type container.\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>neither known to be a reference type\n        /// nor a value type</b>, this option will cause values of that type to \n        /// be stored inside a shared reference type container.\n        /// <b>If the representable type is a generic type parameter,\n        /// boxing will occur for value type arguments to that parameter.</b>\n        /// </para>\n        /// </summary>\n        Auto,\n\n        /// <summary>\n        /// The generator will always store values of the representable type\n        /// inside a shared reference type container.\n        /// <para>\n        /// If the representable type is <b>known to be a value type</b>,\n        /// <b>boxing will occur</b>.\n        /// </para>\n        /// <para>\n        /// If the representable type is a <b>generic type parameter</b>,\n        /// <b>boxing will occur for value type arguments</b> to that parameter.\n        /// </para>\n        /// </summary>\n        Reference,\n\n        /// <summary>\n        /// The generator will attempt to store values of the representable type\n        /// inside a value type container.\n        /// <para>\n        /// If the representable type is <b>known to be a value type</b>,\n        /// this will store values of that type inside a shared value type container.\n        /// <b>Boxing will not occur.</b>\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>known to be a reference type</b>,\n        /// this will store values of that type inside a shared reference type container.\n        /// <b>Boxing will not occur.</b>\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>neither known to be a reference type\n        /// nor a value type</b>, this option will cause values of that type to \n        /// be stored inside a shared value type container.\n        /// <b>If the representable type is a generic type parameter,\n        /// an exception of type <see cref="TypeLoadException"/> will occur for\n        /// reference type arguments to that parameter.</b>\n        /// </para>\n        /// </summary>\n        Value,\n\n        /// <summary>\n        /// The generator will attempt to store values of the representable type\n        /// inside a dedicated container for that type.\n        /// <para>\n        /// If the representable type is <b>known to be a value type</b>,\n        /// this will store values of that type inside a dedicated \n        /// value type container.\n        /// <b>Boxing will not occur.</b>\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>known to be a reference type</b>,\n        /// this will store values of that type inside a \n        /// dedicated reference type container.\n        /// </para>\n        /// <para>\n        /// If the representable type is <b>neither known to be a reference type\n        /// nor a value type</b>, this option will cause values of that type to \n        /// be stored inside a dedicated strongly typed container.\n        /// <b>Boxing will not occur.</b>\n        /// </para>\n        /// </summary>\n        Field\n    }\n\n    /// <summary>\n    /// Marks the target type as a union type being able to represent the type passed to the constructor.\n    /// </summary>\n    [AttributeUsage(( (AttributeTargets)( -1 ) ))]\n    partial class UnionTypeBaseAttribute : Attribute\n    {\n        /// <summary>\n        /// Gets or sets the alias groups that the representable type is to be a part of. \n        /// Represnetable types that share a group may be checked for using unified methods \n        /// and properties like <c>IsGroup</c> where <c>Group</c> is the name of the group\n        /// that the representable type is a part of.\n        /// </summary>\n        public virtual String[] Groups { get; set; } = Array.Empty<String>();\n\n        /// <summary>\n        /// Gets or sets the generator options to use.\n        /// </summary>\n        public virtual UnionTypeOptions Options { get; set; } = UnionTypeOptions.Default;\n\n        /// <summary>\n        /// Gets or sets the option defining storage generation.\n        /// </summary>\n        public virtual StorageOption Storage { get; set; }\n    }\n    [AttributeUsage(( (AttributeTargets)( -1 ) ))]\n#if UNIONS_GENERATOR\n    [GenerateFactory(OmitTypeCheck = true)]\n#endif\n    partial class AliasedUnionTypeBaseAttribute : UnionTypeBaseAttribute\n    {\n        /// <summary>\n        /// Gets or sets the alias to use for members representing the type represented by the union.\n        /// For example, the represented type <see cref="List{T}"/> would be represented using names like\n        /// <c>list_of_T</c>. Setting this property to <c>yourAlias</c> will instruct the generator to use\n        /// member names like <c>yourAlias</c> instead of <c>list_of_T</c>. Use this property to avoid\n        /// name collisions in generated code. Since the alias will be used for member names, it will\n        /// only be taken into account if it is a valid identifier name.\n        /// </summary>\n        public String? Alias { get; set; }\n        /// <inheritdoc/>\n        public override String[] Groups { get => base.Groups; set => base.Groups = value; }\n        /// <inheritdoc/>\n        public override UnionTypeOptions Options { get => base.Options; set => base.Options = value; }\n        /// <inheritdoc/>\n        public override StorageOption Storage { get => base.Storage; set => base.Storage = value; }\n    }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent <typeparamref name="T0"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0> : AliasedUnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>\n    /// and <typeparamref name="T1"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>\n    /// and <typeparamref name="T2"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>,\n    /// <typeparamref name="T2"/>\n    /// and <typeparamref name="T3"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2, T3> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>,\n    /// <typeparamref name="T2"/>,\n    /// <typeparamref name="T3"/>\n    /// and <typeparamref name="T4"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>,\n    /// <typeparamref name="T2"/>,\n    /// <typeparamref name="T3"/>,\n    /// <typeparamref name="T4"/>\n    /// and <typeparamref name="T5"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4, T5> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>,\n    /// <typeparamref name="T2"/>,\n    /// <typeparamref name="T3"/>,\n    /// <typeparamref name="T4"/>,\n    /// <typeparamref name="T5"/>\n    /// and <typeparamref name="T6"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4, T5, T6> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent \n    /// <typeparamref name="T0"/>,\n    /// <typeparamref name="T1"/>,\n    /// <typeparamref name="T2"/>,\n    /// <typeparamref name="T3"/>,\n    /// <typeparamref name="T4"/>,\n    /// <typeparamref name="T5"/>,\n    /// <typeparamref name="T6"/>\n    /// and <typeparamref name="T7"/>.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\n    sealed partial class UnionTypeAttribute<T0, T1, T2, T3, T4, T5, T6, T7> : UnionTypeBaseAttribute\n    { }\n    /// <summary>\n    /// Marks the target type as a union type being able to represent the annotated type parameter.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]\n    sealed partial class UnionTypeAttribute : AliasedUnionTypeBaseAttribute\n    { }\n}\n'})})}),(0,a.jsx)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\RhoMicro_CodeAnalysis_UnionTypeSettingsAttribute.g.cs",label:"RhoMicro_CodeAnalysis_UnionTypeSettingsAttribute.g.cs",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated>\n// This file was generated by RhoMicro.CodeAnalysis.UnionsGenerator\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#nullable enable\n#pragma warning disable\n\nnamespace RhoMicro.CodeAnalysis;\n\nusing System;\n\n#region Setting Enums\n/// <summary>\n/// Defines settings for generating an implementation of <see cref="Object.ToString"/>.\n/// </summary>\nenum ToStringSetting\n{\n    /// <summary>\n    /// The generator will emit an implementation that returns detailed information, including:\n    /// <list type="bullet">\n    /// <item><description>the name of the union type</description></item>\n    /// <item><description>a list of types representable by the union type</description></item>\n    /// <item><description>an indication of which type is being represented by the instance</description></item>\n    /// <item><description>the value currently being represented by the instance</description></item>\n    /// </list>\n    /// </summary>\n    Detailed,\n    /// <summary>\n    /// The generator will not generate an implementation of <see cref="Object.ToString"/>.\n    /// </summary>\n    None,\n    /// <summary>\n    /// The generator will generate an implementation that returns the result of calling <see cref="Object.ToString"/> on the currently represented value.\n    /// </summary>\n    Simple\n}\n/// <summary>\n/// Defines settings for annotating the target with an instance of <see cref="System.Runtime.InteropServices.StructLayoutAttribute"/>.\n/// </summary>\nenum LayoutSetting\n{\n    /// <summary>\n    /// Generate an annotation optimized for size.\n    /// </summary>\n    Small,\n    /// <summary>\n    /// Do not generate any annotations.\n    /// </summary>\n    Auto\n}\n/// <summary>\n/// Defines settings for controlling the accessibility of generated constructors.\n/// </summary>\nenum ConstructorAccessibilitySetting\n{\n    /// <summary>\n    /// Generated constructors should always be private, unless\n    /// no conversion operators are generated for the type they\n    /// accept. This would be the case for interface types or\n    /// supertypes of the target union.\n    /// </summary>\n    PublicIfInconvertible,\n    /// <summary>\n    /// Generated constructors should always be private.\n    /// </summary>\n    Private,\n    /// <summary>\n    /// Generated constructors should always be public\n    /// </summary>\n    Public\n}\n/// <summary>\n/// Defines settings on how to implement interfaces that all representable\n/// types implement.\n/// </summary>\nenum InterfaceMatchSetting\n{\n    /// <summary>\n    /// Generated interface implementations should be explicit if at least\n    /// one of the representable types implements the interface explicitly;\n    /// otherwise, interface implementations should be implicit.\n    /// </summary>\n    Auto,\n    /// <summary>\n    /// Generated interface implementations should always be explicit.\n    /// </summary>\n    Explicit,\n    /// <summary>\n    /// Generated interface implementations should always be implicit.\n    /// </summary>\n    Implicit,\n    /// <summary>\n    /// No interfaces implementations should be generated.\n    /// </summary>\n    Omit\n}\n/// <summary>\n/// Defines settings for the kind of diagnostics to report.\n/// </summary>\n[Flags]\nenum DiagnosticsLevelSettings\n{\n    /// <summary>\n    /// Instructs the analyzer not to emit diagnostics\n    /// </summary>\n    None = 0x00,\n    /// <summary>\n    /// Instructs the analyzer to report info diagnostics.\n    /// </summary>\n    Info = 0x01,\n    /// <summary>\n    /// Instructs the analyzer to report warning diagnostics.\n    /// </summary>\n    Warning = 0x02,\n    /// <summary>\n    /// Instructs the analyzer to report error diagnostics.\n    /// </summary>\n    Error = 0x04,\n    /// <summary>\n    /// Instructs the analyzer to report all diagnostics.\n    /// </summary>\n    All = Info | Warning | Error\n}\n/// <summary>\n/// Defines miscellaneous settings.\n/// </summary>\n[Flags]\nenum MiscellaneousSettings\n{\n    /// <summary>\n    /// </summary>\n    None = 0x00,\n    /// <summary>\n    /// The default settings.\n    /// </summary>\n    Default = None,\n    /// <summary>\n    /// Indicates whether the generated source code should be available as a string constant on the union type itself.\n    /// This setting is generally only useful if the generated implementation should be emitted from another generator.\n    /// </summary>\n    EmitGeneratedSourceCode = 0x01,\n    /// <summary>\n    /// Indicates whether to generate a custom converter type \n    /// for <c>System.Text.Json</c> deserialization. If set, this will also cause\n    /// the union type to be annotated with an appropriate <c>JsonConverter</c> attribute.\n    /// </summary>\n    GenerateJsonConverter = 0x02,\n    /// <summary>\n    /// Indicates that the generator should emit a comment detailing the structure of the union type.\n    /// </summary>\n    EmitStructuralRepresentation = 0x04\n}\n\n/// <summary>\n/// Defines settings pertaining to equality operator implementations.\n/// </summary>\nenum EqualityOperatorsSetting\n{\n    /// <summary>\n    /// Equality operators will be emitted only if the target union type is a value type.\n    /// </summary>\n    EmitOperatorsIfValueType,\n    /// <summary>\n    /// Equality operators will be emitted.\n    /// </summary>\n    EmitOperators,\n    /// <summary>\n    /// Equality operators will be omitted.\n    /// </summary>\n    OmitOperators\n}\n\n#endregion\n#region Attribute Declaration\n/// <summary>\n/// Supplies the generator with additional settings on how to generate a targeted union type.\n/// If the target member is an assembly, the attribute supplies default values for any union \n/// type setting not defined.\n/// </summary>\n[AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class | AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)]\n#if UNIONS_GENERATOR\n[GenerateFactory]\n#endif\nsealed partial class UnionTypeSettingsAttribute : Attribute\n{\n    #region Settings\n    /// <summary>\n    /// Defines how to generate an implementation <see cref="Object.ToString"/>.\n    /// </summary>\n    public ToStringSetting ToStringSetting { get; set; } = ToStringSetting.Detailed;\n    /// <summary>\n    /// Defines whether to generate a size optimizing annotation.\n    /// </summary>\n    public LayoutSetting Layout { get; set; } = LayoutSetting.Auto;\n    /// <summary>\n    /// The level of diagnostics to be reported by the analyzer.\n    /// </summary>\n    public DiagnosticsLevelSettings DiagnosticsLevel { get; set; } = DiagnosticsLevelSettings.All;\n    /// <summary>\n    /// The desired accessibility of generated constructors.\n    /// </summary>\n    public ConstructorAccessibilitySetting ConstructorAccessibility { get; set; } = ConstructorAccessibilitySetting.Private;\n    /// <summary>\n    /// Indicates how to generate implementations for\n    /// interfaces implemented by all representable types. Implementations will \n    /// map calls to interface instance methods and properties onto the represented\n    /// value. \n    /// <para>\n    /// Please note that currently, only fully bound and constructed interface implementations are supported.\n    /// </para>\n    /// </summary>\n    public InterfaceMatchSetting InterfaceMatchSetting { get; set; } = InterfaceMatchSetting.Auto;\n    /// <summary>\n    /// Indicates how to generate equality operators.\n    /// By default, equality operators will only be emitted for value types, so as to preserve\n    /// reference equality for comparing reference union types via <c>==</c> or <c>!=</c>.\n    /// </summary>\n    public EqualityOperatorsSetting EqualityOperatorsSetting { get; set; } = EqualityOperatorsSetting.EmitOperatorsIfValueType;\n    /// <summary>\n    /// Gets or sets miscellaneous settings.\n    /// </summary>\n    public MiscellaneousSettings Miscellaneous { get; set; } = MiscellaneousSettings.Default;\n    #endregion\n    #region Strings\n    /// <summary>\n    /// A raw code preface to prepend before the generated type declaration.\n    /// </summary>\n    public String TypeDeclarationPreface { get; set; } = "";\n    /// <summary>\n    /// The name of the generic parameter for generic <c>Is</c>, <c>As</c> and factory methods. \n    /// Set this property in order to avoid name collisions with generic union type parameters\n    /// </summary>\n    public String GenericTValueName { get; set; } = "TValue";\n    /// <summary>\n    /// The name of the generic parameter for the <c>TryConvert</c> method. \n    /// Set this property in order to avoid name collisions with generic union type parameters\n    /// </summary>\n    public String TryConvertTypeName { get; set; } = "TUnion";\n    /// <summary>\n    /// The name of the generic parameter for the <c>Match</c> method. \n    /// Set this property in order to avoid name collisions with generic union type parameters\n    /// </summary>\n    public String MatchTypeName { get; set; } = "TMatchResult";\n    /// <summary>\n    /// The name to use for the discriminating tag type.\n    /// </summary>\n    public String TagTypeName { get; set; } = "__Tag";\n    /// <summary>\n    /// The name to use for the container type containing value types.\n    /// </summary>\n    public String ValueTypeContainerTypeName { get; set; } = "__ValueTypeContainer";\n    /// <summary>\n    /// The name to use for the field containing value types.\n    /// </summary>\n    public String ValueTypeContainerName { get; set; } = "__value";\n    /// <summary>\n    /// The name to use for the field containing reference types.\n    /// </summary>\n    public String ReferenceTypeContainerName { get; set; } = "__reference";\n    /// <summary>\n    /// The name to use for the field containing the discriminating tag.\n    /// </summary>\n    public String TagFieldName { get; set; } = "__tag";\n    /// <summary>\n    /// The name to use for the default (uninitialized) tag value.\n    /// </summary>\n    public String TagNoneName { get; set; } = "__None";\n    /// <summary>\n    /// The name of the generated json converter type.\n    /// </summary>\n    public String JsonConverterTypeName { get; set; } = "JsonConverter";\n    #endregion\n}\n#endregion\n'})})}),(0,a.jsx)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnionsGenerator\\src\\UnionTypesDemo\\obj\\GX\\RhoMicro.CodeAnalysis.UnionsGenerator.14.0.2\\RhoMicro.CodeAnalysis.UnionsGenerator.Generators.UnionsGenerator\\UnionTypesDemo_ResultSave.g.cs",label:"UnionTypesDemo_ResultSave.g.cs",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated>\n// This file was last generated by RhoMicro.CodeAnalysis.UnionsGenerator at 7/24/2025 7:41:48 AM +03:00\n// The tool used to generate this code may be subject to license terms;\n// this generated code is however not subject to those terms, instead it is\n// subject to the license (if any) applied to the containing project.\n// </auto-generated>\n#pragma warning disable\n#nullable enable\n#region Implementation of UnionTypesDemo.ResultSave\nnamespace UnionTypesDemo\n{\n\tusing System.Linq;\n\t\n\t#region Scoped Data\n\tfile static class UnionTypesDemo_ResultSave_ScopedData\n\t{\n\t\tpublic static System.Collections.Concurrent.ConcurrentDictionary<System.Type, System.Object> Cache { get; } = new();\n\t\tpublic static System.Collections.Generic.HashSet<System.Type> RepresentableTypes { get; } = \n\t\tnew ()\n\t\t{\n\t\t\ttypeof(UnionTypesDemo.Success),\n\t\t\ttypeof(UnionTypesDemo.ValidationError)\n\t\t}\n\t\t;\n\t}\n\t#endregion\n\tpartial class ResultSave : System.IEquatable<ResultSave?>\n\t{\n\t\t\n\t\t#region Nested Types\n\t\t#region Value Type Container\n\t\t#endregion\n\t\t#region Tag Type\n\t\t/// <summary>\n\t\t/// Defines tags to discriminate between representable types.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// This member is not intended for use by user code inside of or any code outside of <see cref="UnionTypesDemo.ResultSave"/>.\n\t\t/// </remarks>\n\t\t[System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n\t\t[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n\t\tprivate enum __Tag : System.Byte\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// Used when not representing any type due to e.g. incorrect or missing initialization.\n\t\t\t/// </summary>\n\t\t\t__None,\n\n\t\t\t\n\t\t\t/// <summary>\n\t\t\t/// Used when representing an instance of <see cref="UnionTypesDemo.Success"/>.\n\t\t\t/// </summary>\n\t\t\tSuccess,\n\t\t\t\n\t\t\t/// <summary>\n\t\t\t/// Used when representing an instance of <see cref="UnionTypesDemo.ValidationError"/>.\n\t\t\t/// </summary>\n\t\t\tValidationError\n\t\t}\n\t\t#endregion\n\t\t#endregion\n\t\t\n\t\t#region Constructors\n\t\t\n\t\t/// <summary>\n\t\t/// Creates a new instance of <see cref="UnionTypesDemo.ResultSave"/>representing an instance of <see cref="UnionTypesDemo.Success"/>.\n\t\t/// </summary>\n\t\t[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n\t\t[System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n\t\tprivate ResultSave(UnionTypesDemo.Success value)\n\t\t{\n\t\t\t__tag = __Tag.Success;\n\t\t\tthis.__reference = value;\n\t\t}\n\t\t\n\t\t\n\t\t/// <summary>\n\t\t/// Creates a new instance of <see cref="UnionTypesDemo.ResultSave"/>representing an instance of <see cref="UnionTypesDemo.ValidationError"/>.\n\t\t/// </summary>\n\t\t[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n\t\t[System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n\t\tprivate ResultSave(UnionTypesDemo.ValidationError value)\n\t\t{\n\t\t\t__tag = __Tag.ValidationError;\n\t\t\tthis.__reference = value;\n\t\t}\n\t\t#endregion\n\t\t\n\t\t#region Fields\n\t\t\n\t\t/// <summary>\n\t\t/// Contains the value of instances of <see cref="UnionTypesDemo.ResultSave"/> representing one of these types:\n\t\t/// <list type="bullet">\n\t\t/// <item>\n\t\t/// <see cref="UnionTypesDemo.Success"/>\n\t\t/// </item>\n\t\t/// <item>\n\t\t/// <see cref="UnionTypesDemo.ValidationError"/>\n\t\t/// </item>\n\t\t/// </list>\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// This member is not intended for use by user code inside of or any code outside of <see cref="UnionTypesDemo.ResultSave"/>.\n\t\t/// </remarks>\n\t\t[System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n\t\t[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n\t\tprivate readonly System.Object? __reference;\n\t\t\n\t\t/// <summary>\n\t\t/// Used to determine the currently represented type and value.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// This member is not intended for use by user code inside of or any code outside of <see cref="UnionTypesDemo.ResultSave"/>.\n\t\t/// </remarks>\n\t\t[System.CodeDom.Compiler.GeneratedCodeAttribute("RhoMicro.CodeAnalysis.UnionsGenerator", "14.0.2.0")]\n\t\t[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\n\t\tprivate readonly __Tag __tag;\n\t\t#endregion\n\t\t\n\t\t#region Factories\n\t\t\n\t\t/// <summary>\n\t\t/// Creates a new instance of <see cref="UnionTypesDemo.ResultSave"/> representing an instance of <see cref="UnionTypesDemo.Success"/>.\n\t\t/// </summary>\n\t\t/// <param name="value">\n\t\t/// The value to be represented by the new instance of <see cref="UnionTypesDemo.ResultSave"/>.\n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// A new instance of <see cref="UnionTypesDemo.ResultSave"/> representing <paramref name="value"/>.\n\t\t/// </returns>\n\t\tpublic static ResultSave CreateFromSuccess([RhoMicro.CodeAnalysis.UnionTypeFactory]UnionTypesDemo.Success value) => new(value);\n\t\t\n\t\t/// <summary>\n\t\t/// Creates a new instance of <see cref="UnionTypesDemo.ResultSave"/> representing an instance of <see cref="UnionTypesDemo.ValidationError"/>.\n\t\t/// </summary>\n\t\t/// <param name="value">\n\t\t/// The value to be represented by the new instance of <see cref="UnionTypesDemo.ResultSave"/>.\n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// A new instance of <see cref="UnionTypesDemo.ResultSave"/> representing <paramref name="value"/>.\n\t\t/// </returns>\n\t\tpublic static ResultSave CreateFromValidationError([RhoMicro.CodeAnalysis.UnionTypeFactory]UnionTypesDemo.ValidationError value) => new(value);\n\t\t/// <summary>\n\t\t/// Attempts to create an instance of <see cref="UnionTypesDemo.ResultSave"/> from an instance of <typeparamref name="TValue"/>.\n\t\t/// </summary>\n\t\t/// <param name="value">\n\t\t/// The value from which to attempt to create an instance of <see cref="UnionTypesDemo.ResultSave"/>.\n\t\t/// </param>\n\t\t/// <param name="result">\n\t\t/// If an instance of <see cref="UnionTypesDemo.ResultSave"/> could successfully be created, this parameter will contain the newly created instance; otherwise, <see langword="default"/>.\n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// <see langword="true"/> if an instance of <see cref="UnionTypesDemo.ResultSave"/> could successfully be created; otherwise, <see langword="false"/>.\n\t\t/// </returns>\n\t\tpublic static System.Boolean TryCreate<TValue>(TValue value, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out ResultSave? result)\n\t\t{\n\t\t\tvar metadataName = RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.GetFullString(typeof(TValue));\n\t\t\tswitch(metadataName)\n\t\t\t{\n\t\t\t\tcase "UnionTypesDemo.Success":\n\t\t\t\t{\n\t\t\t\t\tresult = CreateFromSuccess((RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<TValue, UnionTypesDemo.Success>(value)));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcase "UnionTypesDemo.ValidationError":\n\t\t\t\t{\n\t\t\t\t\tresult = CreateFromValidationError((RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<TValue, UnionTypesDemo.ValidationError>(value)));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sourceType = typeof(TValue);\n\t\t\t\t\t\tif(!UnionTypesDemo_ResultSave_ScopedData.Cache.TryGetValue(sourceType, out var weakMatch))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.IsMarked(sourceType))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tresult = default;\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tweakMatch = UnionTypesDemo_ResultSave_ScopedData.Cache.GetOrAdd(sourceType, t =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar tupleType = typeof(System.ValueTuple<System.Boolean, ResultSave>);\n\t\t\t\t\t\t\t\tvar matchMethod = sourceType.GetMethod(nameof(Match), System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public)\n\t\t\t\t\t\t\t\t\t?.MakeGenericMethod(tupleType) ??\n\t\t\t\t\t\t\t\t\tthrow new System.InvalidOperationException("Unable to locate match function on source union type. This indicates a bug in the marker detection algorithm.");\n\t\t\t\t\t\t\t\tvar targetFactoryMap = typeof(UnionTypesDemo.ResultSave).GetMethods()\n\t\t\t\t\t\t\t\t\t.Where(c => c.CustomAttributes.Any(a => a.AttributeType.FullName == "RhoMicro.CodeAnalysis.UnionTypeFactoryAttribute"))\n\t\t\t\t\t\t\t\t\t.ToDictionary(c => c.GetParameters()[0].ParameterType);\n\t\t\t\t\t\t\t\tvar handlers = matchMethod.GetParameters()\n\t\t\t\t\t\t\t\t\t.Select(p => p.ParameterType.GenericTypeArguments[0])\n\t\t\t\t\t\t\t\t\t.Select(t => (ParameterExpr: System.Linq.Expressions.Expression.Parameter(t), ParameterExprType: t))\n\t\t\t\t\t\t\t\t\t.Select(t =>\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar delegateType = typeof(System.Func<,>).MakeGenericType(t.ParameterExprType, tupleType);\n\t\t\t\t\t\t\t\t\t\tSystem.Linq.Expressions.Expression expression = targetFactoryMap.TryGetValue(t.ParameterExprType, out var factory)\n\t\t\t\t\t\t\t\t\t\t\t? System.Linq.Expressions.Expression.New(tupleType.GetConstructors()[0], System.Linq.Expressions.Expression.Constant(true), System.Linq.Expressions.Expression.Call(factory, t.ParameterExpr))\n\t\t\t\t\t\t\t\t\t\t\t: System.Linq.Expressions.Expression.Default(tupleType);\n\t\t\t\t\t\t\t\t\t\treturn System.Linq.Expressions.Expression.Lambda(delegateType, expression, t.ParameterExpr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);var paramExpr = System.Linq.Expressions.Expression.Parameter(sourceType);\n\t\t\t\t\t\t\t\tvar callExpr = System.Linq.Expressions.Expression.Call(paramExpr, matchMethod, handlers);\n\t\t\t\t\t\t\t\tvar lambdaExpr = System.Linq.Expressions.Expression.Lambda(callExpr, paramExpr);\n\t\t\t\t\t\t\t\tvar result = lambdaExpr.Compile();\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar match = (System.Func<TValue, (System.Boolean, UnionTypesDemo.ResultSave)>)weakMatch;\n\t\t\t\t\t\tvar matchResult = match.Invoke(value);\n\t\t\t\t\t\tif(!matchResult.Item1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = default;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = matchResult.Item2;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/// <summary>\n\t\t/// Creates an instance of <see cref="UnionTypesDemo.ResultSave"/> from an instance of <typeparamref name="TValue"/>.\n\t\t/// </summary>\n\t\t/// <param name="value">\n\t\t/// The value from which to create an instance of <see cref="UnionTypesDemo.ResultSave"/>.\n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// A new instance of <see cref="UnionTypesDemo.ResultSave"/> representing <paramref name="value"/>.\n\t\t/// </returns>\n\t\tpublic static ResultSave Create<TValue>(TValue value)\n\t\t{\n\t\t\tvar metadataName = RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.GetFullString(typeof(TValue));\n\t\t\tswitch(metadataName)\n\t\t\t{\n\t\t\t\tcase "UnionTypesDemo.Success":\n\t\t\t\t{\n\t\t\t\t\treturn CreateFromSuccess((RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<TValue, UnionTypesDemo.Success>(value)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcase "UnionTypesDemo.ValidationError":\n\t\t\t\t{\n\t\t\t\t\treturn CreateFromValidationError((RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<TValue, UnionTypesDemo.ValidationError>(value)));\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sourceType = typeof(TValue);\n\t\t\t\t\t\tif(!UnionTypesDemo_ResultSave_ScopedData.Cache.TryGetValue(sourceType, out var weakMatch))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.IsMarked(sourceType))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow new System.InvalidOperationException($"Unable to create an instance of UnionTypesDemo.ResultSave from an instance of {typeof(TValue)}.");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tweakMatch = UnionTypesDemo_ResultSave_ScopedData.Cache.GetOrAdd(sourceType, t =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar tupleType = typeof(System.ValueTuple<System.Boolean, ResultSave>);\n\t\t\t\t\t\t\t\tvar matchMethod = sourceType.GetMethod(nameof(Match), System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public)\n\t\t\t\t\t\t\t\t\t?.MakeGenericMethod(tupleType) ??\n\t\t\t\t\t\t\t\t\tthrow new System.InvalidOperationException("Unable to locate match function on source union type. This indicates a bug in the marker detection algorithm.");\n\t\t\t\t\t\t\t\tvar targetFactoryMap = typeof(UnionTypesDemo.ResultSave).GetMethods()\n\t\t\t\t\t\t\t\t\t.Where(c => c.CustomAttributes.Any(a => a.AttributeType.FullName == "RhoMicro.CodeAnalysis.UnionTypeFactoryAttribute"))\n\t\t\t\t\t\t\t\t\t.ToDictionary(c => c.GetParameters()[0].ParameterType);\n\t\t\t\t\t\t\t\tvar handlers = matchMethod.GetParameters()\n\t\t\t\t\t\t\t\t\t.Select(p => p.ParameterType.GenericTypeArguments[0])\n\t\t\t\t\t\t\t\t\t.Select(t => (ParameterExpr: System.Linq.Expressions.Expression.Parameter(t), ParameterExprType: t))\n\t\t\t\t\t\t\t\t\t.Select(t =>\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar delegateType = typeof(System.Func<,>).MakeGenericType(t.ParameterExprType, tupleType);\n\t\t\t\t\t\t\t\t\t\tSystem.Linq.Expressions.Expression expression = targetFactoryMap.TryGetValue(t.ParameterExprType, out var factory)\n\t\t\t\t\t\t\t\t\t\t\t? System.Linq.Expressions.Expression.New(tupleType.GetConstructors()[0], System.Linq.Expressions.Expression.Constant(true), System.Linq.Expressions.Expression.Call(factory, t.ParameterExpr))\n\t\t\t\t\t\t\t\t\t\t\t: System.Linq.Expressions.Expression.Default(tupleType);\n\t\t\t\t\t\t\t\t\t\treturn System.Linq.Expressions.Expression.Lambda(delegateType, expression, t.ParameterExpr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);var paramExpr = System.Linq.Expressions.Expression.Parameter(sourceType);\n\t\t\t\t\t\t\t\tvar callExpr = System.Linq.Expressions.Expression.Call(paramExpr, matchMethod, handlers);\n\t\t\t\t\t\t\t\tvar lambdaExpr = System.Linq.Expressions.Expression.Lambda(callExpr, paramExpr);\n\t\t\t\t\t\t\t\tvar result = lambdaExpr.Compile();\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar match = (System.Func<TValue, (System.Boolean, UnionTypesDemo.ResultSave)>)weakMatch;\n\t\t\t\t\t\tvar matchResult = match.Invoke(value);\n\t\t\t\t\t\tif(!matchResult.Item1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new System.InvalidOperationException($"Unable to create an instance of UnionTypesDemo.ResultSave from an instance of {typeof(TValue)}.");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn matchResult.Item2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#endregion\n\t\t\n\t\t#region Switch\n\t\t/// <summary>\n\t\t/// Invokes a handler based on the type of value being represented.\n\t\t/// </summary>\n\t\t/// <param name="onSuccess">\n\t\t/// The handler to invoke if the union is currently representing an instance of <see cref="UnionTypesDemo.Success"/>.\n\t\t/// </param>\n\t\t/// <param name="onValidationError">\n\t\t/// The handler to invoke if the union is currently representing an instance of <see cref="UnionTypesDemo.ValidationError"/>.\n\t\t/// </param>\n\t\tpublic void Switch(\n\t\t\tSystem.Action<UnionTypesDemo.Success> onSuccess,\n\t\t\tSystem.Action<UnionTypesDemo.ValidationError> onValidationError)\n\t\t{\n\t\t\tswitch(this.__tag)\n\t\t\t{\n\t\t\t\tcase __Tag.Success:\n\t\t\t\t{\n\t\t\t\t\tonSuccess.Invoke(((UnionTypesDemo.Success)this.__reference!));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcase __Tag.ValidationError:\n\t\t\t\t{\n\t\t\t\t\tonValidationError.Invoke(((UnionTypesDemo.ValidationError)this.__reference!));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tthrow new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#endregion\n\t\t\n\t\t#region Match\n\t\t/// <summary>\n\t\t/// Invokes a projection based on the type of value being represented.\n\t\t/// </summary>\n\t\t/// <param name="onSuccess">\n\t\t/// The projection to invoke if the union is currently representing an instance of <see cref="UnionTypesDemo.Success"/>.\n\t\t/// </param>\n\t\t/// <param name="onValidationError">\n\t\t/// The projection to invoke if the union is currently representing an instance of <see cref="UnionTypesDemo.ValidationError"/>.\n\t\t/// </param>\n\t\t/// <typeparam name="TMatchResult">\n\t\t/// The type of value produced by the projections passed.\n\t\t/// </typeparam>\n\t\t/// <returns>\n\t\t/// The projected value.\n\t\t/// </returns>\n\t\tpublic TMatchResult Match<TMatchResult>(\n\t\t\tSystem.Func<UnionTypesDemo.Success, TMatchResult> onSuccess,\n\t\t\tSystem.Func<UnionTypesDemo.ValidationError, TMatchResult> onValidationError) =>\n\t\tthis.__tag switch\n\t\t{\n\t\t\t__Tag.Success => onSuccess.Invoke(((UnionTypesDemo.Success)this.__reference!))\n\t\t\t,\n\t\t\t__Tag.ValidationError => onValidationError.Invoke(((UnionTypesDemo.ValidationError)this.__reference!))\n\t\t\t,\n\t\t\t_ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n\t\t}\n\t\t;\n\t\t#endregion\n\t\t\n\t\t#region Represented Type\n\t\t/// <summary>\n\t\t/// Gets the types of value this union type can represent.\n\t\t/// </summary>\n\t\tpublic static System.Collections.Generic.IReadOnlyCollection<System.Type> RepresentableTypes { get; } = \n\t\t\tUnionTypesDemo_ResultSave_ScopedData.RepresentableTypes;\n\t\t/// <summary>\n\t\t/// Gets the type of value represented by this instance.\n\t\t/// </summary>\n\t\tpublic System.Type RepresentedType => \n\t\tthis.__tag switch\n\t\t{\n\t\t\t__Tag.Success => typeof(UnionTypesDemo.Success),\n\t\t\t__Tag.ValidationError => typeof(UnionTypesDemo.ValidationError),\n\t\t\t_ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n\t\t}\n\t\t;\n\t\t#endregion\n\t\t\n\t\t#region Is/As Properties\n\t\t\n\t\t/// <summary>\n\t\t/// Gets a value indicating whether this instance is representing a value of type <see cref="UnionTypesDemo.Success"/>.\n\t\t/// </summary>\n\t\tpublic System.Boolean IsSuccess => __tag == __Tag.Success;\n\t\t\n\t\t/// <summary>\n\t\t/// Gets a value indicating whether this instance is representing a value of type <see cref="UnionTypesDemo.ValidationError"/>.\n\t\t/// </summary>\n\t\tpublic System.Boolean IsValidationError => __tag == __Tag.ValidationError;\n\t\t\n\t\t/// <summary>\n\t\t/// Retrieves the value represented by this instance as a <see cref="UnionTypesDemo.Success"/>.\n\t\t/// </summary>\n\t\tpublic UnionTypesDemo.Success? AsSuccess => __tag == __Tag.Success\n\t\t? ((UnionTypesDemo.Success)this.__reference!)\n\t\t: null;\n\t\t\n\t\t/// <summary>\n\t\t/// Retrieves the value represented by this instance as a <see cref="UnionTypesDemo.ValidationError"/>.\n\t\t/// </summary>\n\t\tpublic UnionTypesDemo.ValidationError? AsValidationError => __tag == __Tag.ValidationError\n\t\t? ((UnionTypesDemo.ValidationError)this.__reference!)\n\t\t: null;\n\t\t#endregion\n\t\t\n\t\t#region Is Group Properties\n\t\t\n\t\t#endregion\n\t\t\n\t\t#region Is/As Functions\n\t\t\n\t\t/// <summary>\n\t\t/// Determines whether this instance is representing a value of type <see cref="UnionTypesDemo.Success"/>.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// <see langword="true"/> if this instance is representing a value of type <see cref="UnionTypesDemo.Success"/>; otherwise, <see langword="false"/>.\n\t\t/// </returns>\n\t\t/// <param name="value">\n\t\t/// If this instance is representing a value of type <see cref="UnionTypesDemo.Success"/>, this parameter will contain that value; otherwise, <see langword="default"/>.\n\t\t/// </param>\n\t\tpublic System.Boolean TryAsSuccess([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out UnionTypesDemo.Success value)\n\t\t{\n\t\t\tif(this.__tag == __Tag.Success)\n\t\t\t{\n\t\t\t\tvalue = ((UnionTypesDemo.Success)this.__reference!);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvalue = default;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t/// <summary>\n\t\t/// Determines whether this instance is representing a value of type <see cref="UnionTypesDemo.ValidationError"/>.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// <see langword="true"/> if this instance is representing a value of type <see cref="UnionTypesDemo.ValidationError"/>; otherwise, <see langword="false"/>.\n\t\t/// </returns>\n\t\t/// <param name="value">\n\t\t/// If this instance is representing a value of type <see cref="UnionTypesDemo.ValidationError"/>, this parameter will contain that value; otherwise, <see langword="default"/>.\n\t\t/// </param>\n\t\tpublic System.Boolean TryAsValidationError([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out UnionTypesDemo.ValidationError value)\n\t\t{\n\t\t\tif(this.__tag == __Tag.ValidationError)\n\t\t\t{\n\t\t\t\tvalue = ((UnionTypesDemo.ValidationError)this.__reference!);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvalue = default;\n\t\t\treturn false;\n\t\t}\n\t\t/// <summary>\n\t\t/// Determines whether this instance is representing a value of type <typeparamref name="TValue"/>.\n\t\t/// </summary>\n\t\t/// <typeparam name="TValue">\n\t\t/// The type whose representation in this instance to determine.\n\t\t/// </typeparam>\n\t\t/// <returns>\n\t\t/// <see langword="true"/> if this instance is representing a value of type <typeparamref name="TValue"/>; otherwise, <see langword="false"/>.\n\t\t/// </returns>\n\t\tpublic System.Boolean Is<TValue>() =>typeof(TValue) ==this.__tag switch\n\t\t{\n\t\t\t__Tag.Success => typeof(UnionTypesDemo.Success),\n\t\t\t__Tag.ValidationError => typeof(UnionTypesDemo.ValidationError),\n\t\t\t_ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n\t\t}\n\t\t;\n\t\t/// <summary>\n\t\t/// Determines whether this instance is representing a value of type <typeparamref name="TValue"/>.\n\t\t/// </summary>\n\t\t/// <param name="value">\n\t\t/// If this instance is representing a value of type <typeparamref name="TValue"/>, this parameter will contain that value; otherwise, <see langword="default"/>.\n\t\t/// </param>\n\t\t/// <typeparam name="TValue">\n\t\t/// The type whose representation in this instance to determine.\n\t\t/// </typeparam>\n\t\t/// <returns>\n\t\t/// <see langword="true"/> if this instance is representing a value of type <typeparamref name="TValue"/>; otherwise, <see langword="false"/>.\n\t\t/// </returns>\n\t\tpublic System.Boolean Is<TValue>(out TValue? value)\n\t\t{\n\t\t\tvar metadataName = RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.GetFullString(typeof(TValue));\n\t\t\tswitch(metadataName)\n\t\t\t{\n\t\t\t\tcase "UnionTypesDemo.Success":\n\t\t\t\t{\n\t\t\t\t\tvalue = (RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<UnionTypesDemo.Success, TValue>((UnionTypesDemo.Success)this.__reference!));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcase "UnionTypesDemo.ValidationError":\n\t\t\t\t{\n\t\t\t\t\tvalue = (RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<UnionTypesDemo.ValidationError, TValue>((UnionTypesDemo.ValidationError)this.__reference!));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue = default;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/// <summary>\n\t\t/// Determines whether this instance is representing an instance of <paramref name="type"/>.\n\t\t/// </summary>\n\t\t/// <param name="type">\n\t\t/// The type whose representation in this instance to determine.\n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// <see langword="true"/> if this instance is representing an instance of <paramref name="type"/>; otherwise, <see langword="false"/>.\n\t\t/// </returns>\n\t\tpublic System.Boolean Is(System.Type type) =>\n\t\ttype == this.__tag switch\n\t\t{\n\t\t\t__Tag.Success => typeof(UnionTypesDemo.Success),\n\t\t\t__Tag.ValidationError => typeof(UnionTypesDemo.ValidationError),\n\t\t\t_ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n\t\t}\n\t\t;\n\t\t/// <summary>\n\t\t/// Retrieves the value represented by this instance as an instance of <typeparamref name="TValue"/>.\n\t\t/// </summary>\n\t\t/// <typeparam name="TValue">\n\t\t/// The type to retrieve the represented value as.\n\t\t/// </typeparam>\n\t\t/// <returns>\n\t\t/// The currently represented value as an instance of <typeparamref name="TValue"/>.\n\t\t/// </returns>\n\t\tpublic TValue As<TValue>() =>\n\t\tthis.__tag switch\n\t\t{\n\t\t\t__Tag.Success => typeof(TValue) == typeof(UnionTypesDemo.Success)\n\t\t\t? (RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<UnionTypesDemo.Success, TValue>((UnionTypesDemo.Success)this.__reference!))\n\t\t\t: throw new System.InvalidOperationException($"Unable to convert from an instance of {typeof(UnionTypesDemo.ResultSave)} representing a value of type {this.RepresentedType} to an instance of {typeof(TValue)}."),\n\t\t\t__Tag.ValidationError => typeof(TValue) == typeof(UnionTypesDemo.ValidationError)\n\t\t\t? (RhoMicro.CodeAnalysis.UnionsGenerator.Generated.Util.UnsafeConvert<UnionTypesDemo.ValidationError, TValue>((UnionTypesDemo.ValidationError)this.__reference!))\n\t\t\t: throw new System.InvalidOperationException($"Unable to convert from an instance of {typeof(UnionTypesDemo.ResultSave)} representing a value of type {this.RepresentedType} to an instance of {typeof(TValue)}."),\n\t\t\t_ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n\t\t}\n\t\t;\n\t\t#endregion\n\t\t\n\t\t#region ToString\n\t\t/// <inheritdoc/>\n\t\tpublic override System.String ToString()\n\t\t{\n\t\t\tvar stringRepresentation = this.__tag switch\n\t\t\t{\n\t\t\t\t__Tag.Success => ((this.__reference!)?.ToString() ?? System.String.Empty),\n\t\t\t\t__Tag.ValidationError => ((this.__reference!)?.ToString() ?? System.String.Empty),\n\t\t\t\t_ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n\t\t\t}\n\t\t\t;\n\t\t\tvar result = $"ResultSave({(__tag == __Tag.Success ? "<Success>" : "Success")}|{(__tag == __Tag.ValidationError ? "<ValidationError>" : "ValidationError")}){{{stringRepresentation}}}";\n\t\t\treturn result;\n\t\t}\n\t\t#endregion\n\t\t\n\t\t#region GetHashCode\n\t\t/// <inheritdoc/>\n\t\tpublic override System.Int32 GetHashCode() => \n\t\tthis.__tag switch\n\t\t{\n\t\t\t__Tag.Success => (System.Collections.Generic.EqualityComparer<UnionTypesDemo.Success>.Default.GetHashCode(((UnionTypesDemo.Success)this.__reference!))),\n\t\t\t__Tag.ValidationError => (System.Collections.Generic.EqualityComparer<UnionTypesDemo.ValidationError>.Default.GetHashCode(((UnionTypesDemo.ValidationError)this.__reference!))),\n\t\t\t_ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n\t\t}\n\t\t;\n\t\t#endregion\n\t\t\n\t\t#region Equality\n\t\t/// <inheritdoc/>\n\t\tpublic override System.Boolean Equals(System.Object? obj) =>\n\t\t\tobj is ResultSave union && Equals(union);\n\t\t/// <inheritdoc/>\n\t\tpublic System.Boolean Equals(ResultSave? other) =>\n\t\t\tReferenceEquals(other, this)\n\t\t\t|| other != null\n\t\t\t&& this.__tag == other.__tag\n\t\t\t&& this.__tag switch\n\t\t\t{\n\t\t\t\t__Tag.Success => (System.Collections.Generic.EqualityComparer<UnionTypesDemo.Success>.Default.Equals(((UnionTypesDemo.Success)this.__reference!), ((UnionTypesDemo.Success)other.__reference!))),\n\t\t\t\t__Tag.ValidationError => (System.Collections.Generic.EqualityComparer<UnionTypesDemo.ValidationError>.Default.Equals(((UnionTypesDemo.ValidationError)this.__reference!), ((UnionTypesDemo.ValidationError)other.__reference!))),\n\t\t\t\t_ => throw new System.InvalidOperationException("Unable to determine the represented type or value. The union type was likely not initialized correctly.")\n\t\t\t}\n\t\t\t;\n\t\t\n\t\t#endregion\n\t\t\n\t\t#region Conversions\n\t\t\n\t\t#region Representable Type Conversions\n\t\t\n\t\t/// <summary>\n\t\t/// Converts an instance of the representable type <see cref="UnionTypesDemo.Success"/> to the union type <see cref="UnionTypesDemo.ResultSave"/>.\n\t\t/// </summary>\n\t\t/// <param name="value">\n\t\t/// The value to convert.\n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// The union type instance.\n\t\t/// </returns>\n\t\tpublic static implicit operator ResultSave(UnionTypesDemo.Success value) => CreateFromSuccess(value);\n\t\t/// <summary>\n\t\t/// Converts an instance of the union type <see cref="UnionTypesDemo.ResultSave"/> to the representable type <see cref="UnionTypesDemo.Success"/>.\n\t\t/// </summary>\n\t\t/// <param name="union">\n\t\t/// The union to convert.\n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// The represented value.\n\t\t/// </returns>\n\t\tpublic static explicit operator UnionTypesDemo.Success(UnionTypesDemo.ResultSave union) =>union.__tag == __Tag.Success?\n\t\t((UnionTypesDemo.Success)union.__reference!):throw new System.InvalidOperationException($"Unable to convert from an instance of {typeof(ResultSave)} representing a value of type {union.RepresentedType} to an instance of {typeof(UnionTypesDemo.Success)}.");\n\t\t\n\t\t/// <summary>\n\t\t/// Converts an instance of the representable type <see cref="UnionTypesDemo.ValidationError"/> to the union type <see cref="UnionTypesDemo.ResultSave"/>.\n\t\t/// </summary>\n\t\t/// <param name="value">\n\t\t/// The value to convert.\n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// The union type instance.\n\t\t/// </returns>\n\t\tpublic static implicit operator ResultSave(UnionTypesDemo.ValidationError value) => CreateFromValidationError(value);\n\t\t/// <summary>\n\t\t/// Converts an instance of the union type <see cref="UnionTypesDemo.ResultSave"/> to the representable type <see cref="UnionTypesDemo.ValidationError"/>.\n\t\t/// </summary>\n\t\t/// <param name="union">\n\t\t/// The union to convert.\n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// The represented value.\n\t\t/// </returns>\n\t\tpublic static explicit operator UnionTypesDemo.ValidationError(UnionTypesDemo.ResultSave union) =>union.__tag == __Tag.ValidationError?\n\t\t((UnionTypesDemo.ValidationError)union.__reference!):throw new System.InvalidOperationException($"Unable to convert from an instance of {typeof(ResultSave)} representing a value of type {union.RepresentedType} to an instance of {typeof(UnionTypesDemo.ValidationError)}.");\n\t\t#endregion\n\t\t\n\t\t#region Related Type Conversions\n\t\t#endregion\n\t\t#endregion\n\t}\n}\n#endregion\n\n'})})})]}),"\n",(0,a.jsx)(t.h2,{id:"useful",children:"Useful"}),"\n",(0,a.jsx)(t.h3,{id:"download-example-net--c",children:"Download Example (.NET  C#)"}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(19505).A+"",children:"Download Example project UnionsGenerator "})})}),"\n",(0,a.jsx)(t.h3,{id:"share-unionsgenerator",children:"Share UnionsGenerator"}),"\n",(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator&quote=UnionsGenerator",title:"Share on Facebook",target:"_blank",children:"Share on Facebook"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator&text=UnionsGenerator:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator",target:"_blank",title:"Tweet",children:"Share in Twitter"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator&title=UnionsGenerator",target:"_blank",title:"Submit to Reddit",children:"Share on Reddit"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator&title=UnionsGenerator&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnionsGenerator",target:"_blank",title:"Share on LinkedIn",children:"Share on Linkedin"})})]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/UnionsGenerator",children:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/UnionsGenerator"})}),"\n",(0,a.jsx)(t.p,{children:"aaa"}),"\n",(0,a.jsx)(p.Ay,{})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);