"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[6685],{608:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>m,contentTitle:()=>i,default:()=>f,frontMatter:()=>l,metadata:()=>u,toc:()=>c});var t=a(7462),r=(a(7294),a(4137)),s=a(3992),o=a(425);a(8839);const l={sidebar_position:200,title:"20 - NetEscapades.EnumGenerators",description:"Running fast tostring and other  features for enum",slug:"/NetEscapades.EnumGenerators"},i="NetEscapades.EnumGenerators  by Andrew Lock",u={unversionedId:"RSCG-Examples/NetEscapades.EnumGenerators",id:"RSCG-Examples/NetEscapades.EnumGenerators",title:"20 - NetEscapades.EnumGenerators",description:"Running fast tostring and other  features for enum",source:"@site/docs/RSCG-Examples/NetEscapades.EnumGenerators.md",sourceDirName:"RSCG-Examples",slug:"/NetEscapades.EnumGenerators",permalink:"/RSCG_Examples/v2/docs/NetEscapades.EnumGenerators",draft:!1,tags:[],version:"current",sidebarPosition:200,frontMatter:{sidebar_position:200,title:"20 - NetEscapades.EnumGenerators",description:"Running fast tostring and other  features for enum",slug:"/NetEscapades.EnumGenerators"},sidebar:"tutorialSidebar",previous:{title:"19 - ApparatusAOT",permalink:"/RSCG_Examples/v2/docs/ApparatusAOT"},next:{title:"21 - Microsoft.Interop.JavaScript.JSImportGenerator",permalink:"/RSCG_Examples/v2/docs/Microsoft.Interop.JavaScript.JSImportGenerator"}},m={},c=[{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Download PDF",id:"download-pdf",level:3},{value:"Share NetEscapades.EnumGenerators",id:"share-netescapadesenumgenerators",level:3}],d={toc:c},p="wrapper";function f(e){let{components:n,...l}=e;return(0,r.kt)(p,(0,t.Z)({},d,l,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"netescapadesenumgenerators--by-andrew-lock"},"NetEscapades.EnumGenerators  by Andrew Lock"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/NetEscapades.EnumGenerators/"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/NetEscapades.EnumGenerators?label=NetEscapades.EnumGenerators",alt:"Nuget"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/andrewlock/NetEscapades.EnumGenerators"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/andrewlock/NetEscapades.EnumGenerators?label=updated",alt:"GitHub last commit"})),"\n",(0,r.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/andrewlock/NetEscapades.EnumGenerators?style=social",alt:"GitHub Repo stars"})),(0,r.kt)("h2",{id:"details"},"Details"),(0,r.kt)("h3",{id:"info"},"Info"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Name: ",(0,r.kt)("strong",{parentName:"p"},"NetEscapades.EnumGenerators")),(0,r.kt)("p",{parentName:"admonition"},"Author: Andrew Lock"),(0,r.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/NetEscapades.EnumGenerators/"},"https://www.nuget.org/packages/NetEscapades.EnumGenerators/")),"   "),(0,r.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,r.kt)("a",{parentName:"p",href:"https://andrewlock.net/netescapades-enumgenerators-a-source-generator-for-enum-performance/"},"https://andrewlock.net/netescapades-enumgenerators-a-source-generator-for-enum-performance/")),(0,r.kt)("p",{parentName:"admonition"},"Source : ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/andrewlock/NetEscapades.EnumGenerators"},"https://github.com/andrewlock/NetEscapades.EnumGenerators"))),(0,r.kt)("h3",{id:"about"},"About"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Running fast tostring and other  features for enum")),(0,r.kt)("h2",{id:"how-to-use"},"How to use"),(0,r.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,r.kt)("p",null,"This is the CSharp Project that references ",(0,r.kt)("strong",{parentName:"p"},"NetEscapades.EnumGenerators")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {11}",showLineNumbers:!0,"{11}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net7.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include="NetEscapades.EnumGenerators" Version="1.0.0-beta08" \n                      OutputItemType="Analyzer" ReferenceOutputAssembly="false"\n                      PrivateAssets="all" ExcludeAssets="comile;runtime"\n                      />\n  </ItemGroup>\n <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n  \n</Project>\n\n'))),(0,r.kt)(o.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\NetEscapades.EnumGenerators\\src\\TestEnumEscapades\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"NetEscapades.EnumGenerators")," in ",(0,r.kt)("em",{parentName:"p"},"Program.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'\nvar value = InstallType.ShowGUI;\nConsole.WriteLine($"the enum string is {value.ToStringFast()}");\nConsole.WriteLine($"{InstallType.None.ToStringFast()}");\n\n\nvar flags = AddToCoffee.Milk | AddToCoffee.Sugar;\n\nConsole.WriteLine(flags.ToStringFast());\nConsole.WriteLine($"HasFlag(Milk), {flags.HasFlagFast(AddToCoffee.Milk)}");\nConsole.WriteLine($"HasFlag(Biscuit), {flags.HasFlagFast(AddToCoffee.Biscuit)}");\n//check also\n//InstallTypeExtensions.GetNames\n//AddToCoffeeExtensions.GetNames\n'))),(0,r.kt)(o.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\NetEscapades.EnumGenerators\\src\\TestEnumEscapades\\InstallType.cs",label:"InstallType.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"NetEscapades.EnumGenerators")," in ",(0,r.kt)("em",{parentName:"p"},"InstallType.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using NetEscapades.EnumGenerators;\nusing System.ComponentModel.DataAnnotations;\nusing System.Xml.Linq;\n\n[EnumExtensions]\ninternal enum InstallType\n{\n    [Display(Name = $"Please use one of the flags of {nameof(InstallType)}")]\n    None= 0,\n    \n    ShowGUI,\n    ShowNoGui,\n}\n\n'))),(0,r.kt)(o.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\NetEscapades.EnumGenerators\\src\\TestEnumEscapades\\AddToCoffee.cs",label:"AddToCoffee.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"NetEscapades.EnumGenerators")," in ",(0,r.kt)("em",{parentName:"p"},"AddToCoffee.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"using NetEscapades.EnumGenerators;\n\n[EnumExtensions]\n[Flags]\ninternal enum AddToCoffee\n{\n    None= 0,\n    Milk=1,\n    Sugar=2,\n    Biscuit=4\n}\n")))),(0,r.kt)("h3",{id:"generated-files"},"Generated Files"),(0,r.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\NetEscapades.EnumGenerators\\src\\TestEnumEscapades\\obj\\GX\\NetEscapades.EnumGenerators\\NetEscapades.EnumGenerators.EnumGenerator\\AddToCoffeeExtensions_EnumExtensions.g.cs",label:"AddToCoffeeExtensions_EnumExtensions.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by the NetEscapades.EnumGenerators source generator\n//\n//     Changes to this file may cause incorrect behavior and will be lost if\n//     the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n#if NETCOREAPP && !NETCOREAPP2_0 && !NETCOREAPP1_1 && !NETCOREAPP1_0\nusing System;\n#endif\n\n    /// <summary>\n    /// Extension methods for <see cref="global::AddToCoffee" />\n    /// </summary>\n    internal static partial class AddToCoffeeExtensions\n    {\n        /// <summary>\n        /// The number of members in the enum.\n        /// This is a non-distinct count of defined names.\n        /// </summary>\n        public const int Length = 4;\n\n        /// <summary>\n        /// Returns the string representation of the <see cref="global::AddToCoffee"/> value.\n        /// If the attribute is decorated with a <c>[Display]</c> attribute, then\n        /// uses the provided value. Otherwise uses the name of the member, equivalent to\n        /// calling <c>ToString()</c> on <paramref name="value"/>.\n        /// </summary>\n        /// <param name="value">The value to retrieve the string value for</param>\n        /// <returns>The string representation of the value</returns>\n        public static string ToStringFast(this global::AddToCoffee value)\n            => value switch\n            {\n                global::AddToCoffee.None => nameof(global::AddToCoffee.None),\n                global::AddToCoffee.Milk => nameof(global::AddToCoffee.Milk),\n                global::AddToCoffee.Sugar => nameof(global::AddToCoffee.Sugar),\n                global::AddToCoffee.Biscuit => nameof(global::AddToCoffee.Biscuit),\n                _ => value.ToString(),\n            };\n\n        /// <summary>\n        /// Determines whether one or more bit fields are set in the current instance.\n        /// Equivalent to calling <see cref="global::System.Enum.HasFlag" /> on <paramref name="value"/>.\n        /// </summary>\n        /// <param name="value">The value of the instance to investigate</param>\n        /// <param name="flag">The flag to check for</param>\n        /// <returns><c>true</c> if the fields set in the flag are also set in the current instance; otherwise <c>false</c>.</returns>\n        /// <remarks>If the underlying value of <paramref name="flag"/> is zero, the method returns true.\n        /// This is consistent with the behaviour of <see cref="global::System.Enum.HasFlag" /></remarks>\n        public static bool HasFlagFast(this global::AddToCoffee value, global::AddToCoffee flag)\n            => flag == 0 ? true : (value & flag) == flag;\n\n        /// <summary>\n        /// Returns a boolean telling whether the given enum value exists in the enumeration.\n        /// </summary>\n        /// <param name="value">The value to check if it\'s defined</param>\n        /// <returns><c>true</c> if the value exists in the enumeration, <c>false</c> otherwise</returns>\n       public static bool IsDefined(global::AddToCoffee value)\n            => value switch\n            {\n                global::AddToCoffee.None => true,\n                global::AddToCoffee.Milk => true,\n                global::AddToCoffee.Sugar => true,\n                global::AddToCoffee.Biscuit => true,\n                _ => false,\n            };\n\n        /// <summary>\n        /// Returns a boolean telling whether an enum with the given name exists in the enumeration.\n        /// </summary>\n        /// <param name="name">The name to check if it\'s defined</param>\n        /// <returns><c>true</c> if a member with the name exists in the enumeration, <c>false</c> otherwise</returns>\n        public static bool IsDefined(string name) => IsDefined(name, allowMatchingMetadataAttribute: false);\n\n        /// <summary>\n        /// Returns a boolean telling whether an enum with the given name exists in the enumeration,\n        /// or if a member decorated with a <c>[Display]</c> attribute\n        /// with the required name exists.\n        /// </summary>\n        /// <param name="name">The name to check if it\'s defined</param>\n        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value of metadata attributes,otherwise ignores them</param>\n        /// <returns><c>true</c> if a member with the name exists in the enumeration, or a member is decorated\n        /// with a <c>[Display]</c> attribute with the name, <c>false</c> otherwise</returns>\n        public static bool IsDefined(string name, bool allowMatchingMetadataAttribute)\n        {\n            return name switch\n            {\n                nameof(global::AddToCoffee.None) => true,\n                nameof(global::AddToCoffee.Milk) => true,\n                nameof(global::AddToCoffee.Sugar) => true,\n                nameof(global::AddToCoffee.Biscuit) => true,\n                _ => false,\n            };\n        }\n\n#if NETCOREAPP && !NETCOREAPP2_0 && !NETCOREAPP1_1 && !NETCOREAPP1_0\n        /// <summary>\n        /// Returns a boolean telling whether an enum with the given name exists in the enumeration\n        /// </summary>\n        /// <param name="name">The name to check if it\'s defined</param>\n        /// <returns><c>true</c> if a member with the name exists in the enumeration, <c>false</c> otherwise</returns>\n        public static bool IsDefined(in ReadOnlySpan<char> name) => IsDefined(name, allowMatchingMetadataAttribute: false);\n\n        /// <summary>\n        /// Returns a boolean telling whether an enum with the given name exists in the enumeration,\n        /// or optionally if a member decorated with a <c>[Display]</c> attribute\n        /// with the required name exists.\n        /// Slower then the <see cref="IsDefined(string, bool)" /> overload, but doesn\'t allocate memory./>\n        /// </summary>\n        /// <param name="name">The name to check if it\'s defined</param>\n        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value of metadata attributes,otherwise ignores them</param>\n        /// <returns><c>true</c> if a member with the name exists in the enumeration, or a member is decorated\n        /// with a <c>[Display]</c> attribute with the name, <c>false</c> otherwise</returns>\n        public static bool IsDefined(in ReadOnlySpan<char> name, bool allowMatchingMetadataAttribute)\n        {\n            return name switch\n            {\n                ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.None).AsSpan(), global::System.StringComparison.Ordinal) => true,\n                ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.Milk).AsSpan(), global::System.StringComparison.Ordinal) => true,\n                ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.Sugar).AsSpan(), global::System.StringComparison.Ordinal) => true,\n                ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.Biscuit).AsSpan(), global::System.StringComparison.Ordinal) => true,\n                _ => false,\n            };\n        }\n#endif\n\n        /// <summary>\n        /// Converts the string representation of the name or numeric value of\n        /// an <see cref="global::AddToCoffee" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>\n        /// <param name="value">When this method returns, contains an object of type \n        /// <see cref="global::AddToCoffee" /> whose\n        /// value is represented by <paramref name="value"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::AddToCoffee" />. This parameter is passed uninitialized.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            string? name, \n            out global::AddToCoffee value)\n            => TryParse(name, out value, false, false);\n\n        /// <summary>\n        /// Converts the string representation of the name or numeric value of\n        /// an <see cref="global::AddToCoffee" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The string representation of the enumeration name or underlying value to convert</param>\n        /// <param name="value">When this method returns, contains an object of type \n        /// <see cref="global::AddToCoffee" /> whose\n        /// value is represented by <paramref name="value"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::AddToCoffee" />. This parameter is passed uninitialized.</param>\n        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            string? name, \n            out global::AddToCoffee value,\n            bool ignoreCase) \n            => TryParse(name, out value, ignoreCase, false);\n\n        /// <summary>\n        /// Converts the string representation of the name or numeric value of\n        /// an <see cref="global::AddToCoffee" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The string representation of the enumeration name or underlying value to convert</param>\n        /// <param name="value">When this method returns, contains an object of type \n        /// <see cref="global::AddToCoffee" /> whose\n        /// value is represented by <paramref name="value"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::AddToCoffee" />. This parameter is passed uninitialized.</param>\n        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>\n        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as\n        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            string? name, \n            out global::AddToCoffee value, \n            bool ignoreCase, \n            bool allowMatchingMetadataAttribute)\n        {\n            if (ignoreCase)\n            {\n                switch (name)\n                {\n                    case string s when s.Equals(nameof(global::AddToCoffee.None), global::System.StringComparison.OrdinalIgnoreCase):\n                        value = global::AddToCoffee.None;\n                        return true;\n                    case string s when s.Equals(nameof(global::AddToCoffee.Milk), global::System.StringComparison.OrdinalIgnoreCase):\n                        value = global::AddToCoffee.Milk;\n                        return true;\n                    case string s when s.Equals(nameof(global::AddToCoffee.Sugar), global::System.StringComparison.OrdinalIgnoreCase):\n                        value = global::AddToCoffee.Sugar;\n                        return true;\n                    case string s when s.Equals(nameof(global::AddToCoffee.Biscuit), global::System.StringComparison.OrdinalIgnoreCase):\n                        value = global::AddToCoffee.Biscuit;\n                        return true;\n                    case string s when int.TryParse(name, out var val):\n                        value = (global::AddToCoffee)val;\n                        return true;\n                    default:\n                        value = default;\n                        return false;\n                }\n            }\n            else\n            {\n                switch (name)\n                {\n                    case nameof(global::AddToCoffee.None):\n                        value = global::AddToCoffee.None;\n                        return true;\n                    case nameof(global::AddToCoffee.Milk):\n                        value = global::AddToCoffee.Milk;\n                        return true;\n                    case nameof(global::AddToCoffee.Sugar):\n                        value = global::AddToCoffee.Sugar;\n                        return true;\n                    case nameof(global::AddToCoffee.Biscuit):\n                        value = global::AddToCoffee.Biscuit;\n                        return true;\n                    case string s when int.TryParse(name, out var val):\n                        value = (global::AddToCoffee)val;\n                        return true;\n                    default:\n                        value = default;\n                        return false;\n                }\n            }\n        }\n\n#if NETCOREAPP && !NETCOREAPP2_0 && !NETCOREAPP1_1 && !NETCOREAPP1_0\n        /// <summary>\n        /// Converts the span representation of the name or numeric value of\n        /// an <see cref="global::AddToCoffee" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>\n        /// <param name="value">When this method returns, contains an object of type \n        /// <see cref="global::AddToCoffee" /> whose\n        /// value is represented by <paramref name="value"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::AddToCoffee" />. This parameter is passed uninitialized.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            in ReadOnlySpan<char> name, \n            out global::AddToCoffee value)\n            => TryParse(name, out value, false, false);\n\n        /// <summary>\n        /// Converts the span representation of the name or numeric value of\n        /// an <see cref="global::AddToCoffee" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>\n        /// <param name="value">When this method returns, contains an object of type \n        /// <see cref="global::AddToCoffee" /> whose\n        /// value is represented by <paramref name="value"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::AddToCoffee" />. This parameter is passed uninitialized.</param>\n        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            in ReadOnlySpan<char> name, \n            out global::AddToCoffee value,\n            bool ignoreCase) \n            => TryParse(name, out value, ignoreCase, false);\n\n        /// <summary>\n        /// Converts the span representation of the name or numeric value of\n        /// an <see cref="global::AddToCoffee" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>\n        /// <param name="result">When this method returns, contains an object of type \n        /// <see cref="global::AddToCoffee" /> whose\n        /// value is represented by <paramref name="result"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::AddToCoffee" />. This parameter is passed uninitialized.</param>\n        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>\n        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as\n        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            in ReadOnlySpan<char> name, \n            out global::AddToCoffee result, \n            bool ignoreCase,             \n            bool allowMatchingMetadataAttribute)\n        {\n            if (ignoreCase)\n            {\n                switch (name)\n                {\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.None).AsSpan(), global::System.StringComparison.OrdinalIgnoreCase):\n                        result = global::AddToCoffee.None;\n                        return true;\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.Milk).AsSpan(), global::System.StringComparison.OrdinalIgnoreCase):\n                        result = global::AddToCoffee.Milk;\n                        return true;\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.Sugar).AsSpan(), global::System.StringComparison.OrdinalIgnoreCase):\n                        result = global::AddToCoffee.Sugar;\n                        return true;\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.Biscuit).AsSpan(), global::System.StringComparison.OrdinalIgnoreCase):\n                        result = global::AddToCoffee.Biscuit;\n                        return true;\n                    case ReadOnlySpan<char> current when int.TryParse(name, out var numericResult):\n                        result = (global::AddToCoffee)numericResult;\n                        return true;\n                    default:\n                        result = default;\n                        return false;\n                }\n            }\n            else\n            {\n                switch (name)\n                {\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.None).AsSpan(), global::System.StringComparison.Ordinal):\n                        result = global::AddToCoffee.None;\n                        return true;\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.Milk).AsSpan(), global::System.StringComparison.Ordinal):\n                        result = global::AddToCoffee.Milk;\n                        return true;\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.Sugar).AsSpan(), global::System.StringComparison.Ordinal):\n                        result = global::AddToCoffee.Sugar;\n                        return true;\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::AddToCoffee.Biscuit).AsSpan(), global::System.StringComparison.Ordinal):\n                        result = global::AddToCoffee.Biscuit;\n                        return true;\n                    case ReadOnlySpan<char> current when int.TryParse(name, out var numericResult):\n                        result = (global::AddToCoffee)numericResult;\n                        return true;\n                    default:\n                        result = default;\n                        return false;\n                }\n            }\n        }\n#endif\n\n        /// <summary>\n        /// Retrieves an array of the values of the members defined in\n        /// <see cref="global::AddToCoffee" />.\n        /// Note that this returns a new array with every invocation, so\n        /// should be cached if appropriate.\n        /// </summary>\n        /// <returns>An array of the values defined in <see cref="global::AddToCoffee" /></returns>\n        public static global::AddToCoffee[] GetValues()\n        {\n            return new[]\n            {\n                global::AddToCoffee.None,\n                global::AddToCoffee.Milk,\n                global::AddToCoffee.Sugar,\n                global::AddToCoffee.Biscuit,\n            };\n        }\n\n        /// <summary>\n        /// Retrieves an array of the names of the members defined in\n        /// <see cref="global::AddToCoffee" />.\n        /// Note that this returns a new array with every invocation, so\n        /// should be cached if appropriate.\n        /// </summary>\n        /// <returns>An array of the names of the members defined in <see cref="global::AddToCoffee" /></returns>\n        public static string[] GetNames()\n        {\n            return new[]\n            {\n                nameof(global::AddToCoffee.None),\n                nameof(global::AddToCoffee.Milk),\n                nameof(global::AddToCoffee.Sugar),\n                nameof(global::AddToCoffee.Biscuit),\n            };\n        }\n    }\n'))),(0,r.kt)(o.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\NetEscapades.EnumGenerators\\src\\TestEnumEscapades\\obj\\GX\\NetEscapades.EnumGenerators\\NetEscapades.EnumGenerators.EnumGenerator\\EnumExtensionsAttribute.g.cs",label:"EnumExtensionsAttribute.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by the NetEscapades.EnumGenerators source generator\n//\n//     Changes to this file may cause incorrect behavior and will be lost if\n//     the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\n#if NETESCAPADES_ENUMGENERATORS_EMBED_ATTRIBUTES\nnamespace NetEscapades.EnumGenerators\n{\n    /// <summary>\n    /// Add to enums to indicate that extension methods should be generated for the type\n    /// </summary>\n    [global::System.AttributeUsage(global::System.AttributeTargets.Enum)]\n    [global::System.Diagnostics.Conditional("NETESCAPADES_ENUMGENERATORS_USAGES")]\n#if NET5_0_OR_GREATER\n    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Generated by the NetEscapades.EnumGenerators source generator.")]\n#else\n    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n#endif\n    public class EnumExtensionsAttribute : global::System.Attribute\n    {\n        /// <summary>\n        /// The namespace to generate the extension class.\n        /// If not provided the namespace of the enum will be used\n        /// </summary>\n        public string? ExtensionClassNamespace { get; set; }\n\n        /// <summary>\n        /// The name to use for the extension class.\n        /// If not provided, the enum name with "Extensions" will be used.\n        /// For example for an Enum called StatusCodes, the default name\n        /// will be StatusCodesExtensions\n        /// </summary>\n        public string? ExtensionClassName { get; set; }\n    }\n}\n#endif\n\n'))),(0,r.kt)(o.Z,{value:"C:\\test\\RSCG_Examples\\v2\\rscg_examples\\NetEscapades.EnumGenerators\\src\\TestEnumEscapades\\obj\\GX\\NetEscapades.EnumGenerators\\NetEscapades.EnumGenerators.EnumGenerator\\InstallTypeExtensions_EnumExtensions.g.cs",label:"InstallTypeExtensions_EnumExtensions.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by the NetEscapades.EnumGenerators source generator\n//\n//     Changes to this file may cause incorrect behavior and will be lost if\n//     the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n#if NETCOREAPP && !NETCOREAPP2_0 && !NETCOREAPP1_1 && !NETCOREAPP1_0\nusing System;\n#endif\n\n    /// <summary>\n    /// Extension methods for <see cref="global::InstallType" />\n    /// </summary>\n    internal static partial class InstallTypeExtensions\n    {\n        /// <summary>\n        /// The number of members in the enum.\n        /// This is a non-distinct count of defined names.\n        /// </summary>\n        public const int Length = 3;\n\n        /// <summary>\n        /// Returns the string representation of the <see cref="global::InstallType"/> value.\n        /// If the attribute is decorated with a <c>[Display]</c> attribute, then\n        /// uses the provided value. Otherwise uses the name of the member, equivalent to\n        /// calling <c>ToString()</c> on <paramref name="value"/>.\n        /// </summary>\n        /// <param name="value">The value to retrieve the string value for</param>\n        /// <returns>The string representation of the value</returns>\n        public static string ToStringFast(this global::InstallType value)\n            => value switch\n            {\n                global::InstallType.None => "Please use one of the flags of InstallType",\n                global::InstallType.ShowGUI => nameof(global::InstallType.ShowGUI),\n                global::InstallType.ShowNoGui => nameof(global::InstallType.ShowNoGui),\n                _ => value.ToString(),\n            };\n\n        /// <summary>\n        /// Returns a boolean telling whether the given enum value exists in the enumeration.\n        /// </summary>\n        /// <param name="value">The value to check if it\'s defined</param>\n        /// <returns><c>true</c> if the value exists in the enumeration, <c>false</c> otherwise</returns>\n       public static bool IsDefined(global::InstallType value)\n            => value switch\n            {\n                global::InstallType.None => true,\n                global::InstallType.ShowGUI => true,\n                global::InstallType.ShowNoGui => true,\n                _ => false,\n            };\n\n        /// <summary>\n        /// Returns a boolean telling whether an enum with the given name exists in the enumeration.\n        /// </summary>\n        /// <param name="name">The name to check if it\'s defined</param>\n        /// <returns><c>true</c> if a member with the name exists in the enumeration, <c>false</c> otherwise</returns>\n        public static bool IsDefined(string name) => IsDefined(name, allowMatchingMetadataAttribute: false);\n\n        /// <summary>\n        /// Returns a boolean telling whether an enum with the given name exists in the enumeration,\n        /// or if a member decorated with a <c>[Display]</c> attribute\n        /// with the required name exists.\n        /// </summary>\n        /// <param name="name">The name to check if it\'s defined</param>\n        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value of metadata attributes,otherwise ignores them</param>\n        /// <returns><c>true</c> if a member with the name exists in the enumeration, or a member is decorated\n        /// with a <c>[Display]</c> attribute with the name, <c>false</c> otherwise</returns>\n        public static bool IsDefined(string name, bool allowMatchingMetadataAttribute)\n        {\n            var isDefinedInDisplayAttribute = false;\n            if (allowMatchingMetadataAttribute)\n            {\n                isDefinedInDisplayAttribute = name switch\n                {\n                    "Please use one of the flags of InstallType" => true,\n                    _ => false,\n                };\n            }\n\n            if (isDefinedInDisplayAttribute)\n            {\n                return true;\n            }\n\n            \n            return name switch\n            {\n                nameof(global::InstallType.None) => true,\n                nameof(global::InstallType.ShowGUI) => true,\n                nameof(global::InstallType.ShowNoGui) => true,\n                _ => false,\n            };\n        }\n\n#if NETCOREAPP && !NETCOREAPP2_0 && !NETCOREAPP1_1 && !NETCOREAPP1_0\n        /// <summary>\n        /// Returns a boolean telling whether an enum with the given name exists in the enumeration\n        /// </summary>\n        /// <param name="name">The name to check if it\'s defined</param>\n        /// <returns><c>true</c> if a member with the name exists in the enumeration, <c>false</c> otherwise</returns>\n        public static bool IsDefined(in ReadOnlySpan<char> name) => IsDefined(name, allowMatchingMetadataAttribute: false);\n\n        /// <summary>\n        /// Returns a boolean telling whether an enum with the given name exists in the enumeration,\n        /// or optionally if a member decorated with a <c>[Display]</c> attribute\n        /// with the required name exists.\n        /// Slower then the <see cref="IsDefined(string, bool)" /> overload, but doesn\'t allocate memory./>\n        /// </summary>\n        /// <param name="name">The name to check if it\'s defined</param>\n        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value of metadata attributes,otherwise ignores them</param>\n        /// <returns><c>true</c> if a member with the name exists in the enumeration, or a member is decorated\n        /// with a <c>[Display]</c> attribute with the name, <c>false</c> otherwise</returns>\n        public static bool IsDefined(in ReadOnlySpan<char> name, bool allowMatchingMetadataAttribute)\n        {\n            var isDefinedInDisplayAttribute = false;\n            if (allowMatchingMetadataAttribute)\n            {\n                isDefinedInDisplayAttribute = name switch\n                {\n                    ReadOnlySpan<char> current when current.Equals("Please use one of the flags of InstallType".AsSpan(), global::System.StringComparison.Ordinal) => true,\n                    _ => false,\n                };\n            }\n\n            if (isDefinedInDisplayAttribute)\n            {\n                return true;\n            }\n\n            return name switch\n            {\n                ReadOnlySpan<char> current when current.Equals(nameof(global::InstallType.None).AsSpan(), global::System.StringComparison.Ordinal) => true,\n                ReadOnlySpan<char> current when current.Equals(nameof(global::InstallType.ShowGUI).AsSpan(), global::System.StringComparison.Ordinal) => true,\n                ReadOnlySpan<char> current when current.Equals(nameof(global::InstallType.ShowNoGui).AsSpan(), global::System.StringComparison.Ordinal) => true,\n                _ => false,\n            };\n        }\n#endif\n\n        /// <summary>\n        /// Converts the string representation of the name or numeric value of\n        /// an <see cref="global::InstallType" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The case-sensitive string representation of the enumeration name or underlying value to convert</param>\n        /// <param name="value">When this method returns, contains an object of type \n        /// <see cref="global::InstallType" /> whose\n        /// value is represented by <paramref name="value"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::InstallType" />. This parameter is passed uninitialized.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            string? name, \n            out global::InstallType value)\n            => TryParse(name, out value, false, false);\n\n        /// <summary>\n        /// Converts the string representation of the name or numeric value of\n        /// an <see cref="global::InstallType" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The string representation of the enumeration name or underlying value to convert</param>\n        /// <param name="value">When this method returns, contains an object of type \n        /// <see cref="global::InstallType" /> whose\n        /// value is represented by <paramref name="value"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::InstallType" />. This parameter is passed uninitialized.</param>\n        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            string? name, \n            out global::InstallType value,\n            bool ignoreCase) \n            => TryParse(name, out value, ignoreCase, false);\n\n        /// <summary>\n        /// Converts the string representation of the name or numeric value of\n        /// an <see cref="global::InstallType" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The string representation of the enumeration name or underlying value to convert</param>\n        /// <param name="value">When this method returns, contains an object of type \n        /// <see cref="global::InstallType" /> whose\n        /// value is represented by <paramref name="value"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::InstallType" />. This parameter is passed uninitialized.</param>\n        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>\n        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as\n        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            string? name, \n            out global::InstallType value, \n            bool ignoreCase, \n            bool allowMatchingMetadataAttribute)\n        {\n            if (allowMatchingMetadataAttribute)\n            {\n                if (ignoreCase)\n                {\n                    switch (name)\n                    {\n                        case string s when s.Equals("Please use one of the flags of InstallType", global::System.StringComparison.OrdinalIgnoreCase):\n                            value = global::InstallType.None;\n                            return true;\n                        default:\n                            break;\n                    };\n                }\n                else\n                {\n                    switch (name)\n                    {\n                        case "Please use one of the flags of InstallType":\n                            value = global::InstallType.None;\n                            return true;\n                        default:\n                            break;\n                    };\n                }\n            }\n\n            if (ignoreCase)\n            {\n                switch (name)\n                {\n                    case string s when s.Equals(nameof(global::InstallType.None), global::System.StringComparison.OrdinalIgnoreCase):\n                        value = global::InstallType.None;\n                        return true;\n                    case string s when s.Equals(nameof(global::InstallType.ShowGUI), global::System.StringComparison.OrdinalIgnoreCase):\n                        value = global::InstallType.ShowGUI;\n                        return true;\n                    case string s when s.Equals(nameof(global::InstallType.ShowNoGui), global::System.StringComparison.OrdinalIgnoreCase):\n                        value = global::InstallType.ShowNoGui;\n                        return true;\n                    case string s when int.TryParse(name, out var val):\n                        value = (global::InstallType)val;\n                        return true;\n                    default:\n                        value = default;\n                        return false;\n                }\n            }\n            else\n            {\n                switch (name)\n                {\n                    case nameof(global::InstallType.None):\n                        value = global::InstallType.None;\n                        return true;\n                    case nameof(global::InstallType.ShowGUI):\n                        value = global::InstallType.ShowGUI;\n                        return true;\n                    case nameof(global::InstallType.ShowNoGui):\n                        value = global::InstallType.ShowNoGui;\n                        return true;\n                    case string s when int.TryParse(name, out var val):\n                        value = (global::InstallType)val;\n                        return true;\n                    default:\n                        value = default;\n                        return false;\n                }\n            }\n        }\n\n#if NETCOREAPP && !NETCOREAPP2_0 && !NETCOREAPP1_1 && !NETCOREAPP1_0\n        /// <summary>\n        /// Converts the span representation of the name or numeric value of\n        /// an <see cref="global::InstallType" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>\n        /// <param name="value">When this method returns, contains an object of type \n        /// <see cref="global::InstallType" /> whose\n        /// value is represented by <paramref name="value"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::InstallType" />. This parameter is passed uninitialized.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            in ReadOnlySpan<char> name, \n            out global::InstallType value)\n            => TryParse(name, out value, false, false);\n\n        /// <summary>\n        /// Converts the span representation of the name or numeric value of\n        /// an <see cref="global::InstallType" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>\n        /// <param name="value">When this method returns, contains an object of type \n        /// <see cref="global::InstallType" /> whose\n        /// value is represented by <paramref name="value"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::InstallType" />. This parameter is passed uninitialized.</param>\n        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            in ReadOnlySpan<char> name, \n            out global::InstallType value,\n            bool ignoreCase) \n            => TryParse(name, out value, ignoreCase, false);\n\n        /// <summary>\n        /// Converts the span representation of the name or numeric value of\n        /// an <see cref="global::InstallType" /> to the equivalent instance.\n        /// The return value indicates whether the conversion succeeded.\n        /// </summary>\n        /// <param name="name">The span representation of the enumeration name or underlying value to convert</param>\n        /// <param name="result">When this method returns, contains an object of type \n        /// <see cref="global::InstallType" /> whose\n        /// value is represented by <paramref name="result"/> if the parse operation succeeds.\n        /// If the parse operation fails, contains the default value of the underlying type\n        /// of <see cref="global::InstallType" />. This parameter is passed uninitialized.</param>\n        /// <param name="ignoreCase"><c>true</c> to read value in case insensitive mode; <c>false</c> to read value in case sensitive mode.</param>\n        /// <param name="allowMatchingMetadataAttribute">If <c>true</c>, considers the value included in metadata attributes such as\n        /// <c>[Display]</c> attribute when parsing, otherwise only considers the member names.</param>\n        /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n        public static bool TryParse(\n#if NETCOREAPP3_0_OR_GREATER\n            [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)]\n#endif\n            in ReadOnlySpan<char> name, \n            out global::InstallType result, \n            bool ignoreCase,             \n            bool allowMatchingMetadataAttribute)\n        {\n            if (allowMatchingMetadataAttribute)\n            {\n                if (ignoreCase)\n                {\n                    switch (name)\n                    {\n                        case ReadOnlySpan<char> current when current.Equals("Please use one of the flags of InstallType".AsSpan(), global::System.StringComparison.OrdinalIgnoreCase):\n                            result = global::InstallType.None;\n                            return true;\n                        default:\n                            break;\n                    };\n                }\n                else\n                {\n                    switch (name)\n                    {\n                        case ReadOnlySpan<char> current when current.Equals("Please use one of the flags of InstallType".AsSpan(), global::System.StringComparison.Ordinal):\n                            result = global::InstallType.None;\n                            return true;\n                        default:\n                            break;\n                    };\n                }\n            }\n\n            if (ignoreCase)\n            {\n                switch (name)\n                {\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::InstallType.None).AsSpan(), global::System.StringComparison.OrdinalIgnoreCase):\n                        result = global::InstallType.None;\n                        return true;\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::InstallType.ShowGUI).AsSpan(), global::System.StringComparison.OrdinalIgnoreCase):\n                        result = global::InstallType.ShowGUI;\n                        return true;\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::InstallType.ShowNoGui).AsSpan(), global::System.StringComparison.OrdinalIgnoreCase):\n                        result = global::InstallType.ShowNoGui;\n                        return true;\n                    case ReadOnlySpan<char> current when int.TryParse(name, out var numericResult):\n                        result = (global::InstallType)numericResult;\n                        return true;\n                    default:\n                        result = default;\n                        return false;\n                }\n            }\n            else\n            {\n                switch (name)\n                {\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::InstallType.None).AsSpan(), global::System.StringComparison.Ordinal):\n                        result = global::InstallType.None;\n                        return true;\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::InstallType.ShowGUI).AsSpan(), global::System.StringComparison.Ordinal):\n                        result = global::InstallType.ShowGUI;\n                        return true;\n                    case ReadOnlySpan<char> current when current.Equals(nameof(global::InstallType.ShowNoGui).AsSpan(), global::System.StringComparison.Ordinal):\n                        result = global::InstallType.ShowNoGui;\n                        return true;\n                    case ReadOnlySpan<char> current when int.TryParse(name, out var numericResult):\n                        result = (global::InstallType)numericResult;\n                        return true;\n                    default:\n                        result = default;\n                        return false;\n                }\n            }\n        }\n#endif\n\n        /// <summary>\n        /// Retrieves an array of the values of the members defined in\n        /// <see cref="global::InstallType" />.\n        /// Note that this returns a new array with every invocation, so\n        /// should be cached if appropriate.\n        /// </summary>\n        /// <returns>An array of the values defined in <see cref="global::InstallType" /></returns>\n        public static global::InstallType[] GetValues()\n        {\n            return new[]\n            {\n                global::InstallType.None,\n                global::InstallType.ShowGUI,\n                global::InstallType.ShowNoGui,\n            };\n        }\n\n        /// <summary>\n        /// Retrieves an array of the names of the members defined in\n        /// <see cref="global::InstallType" />.\n        /// Note that this returns a new array with every invocation, so\n        /// should be cached if appropriate.\n        /// </summary>\n        /// <returns>An array of the names of the members defined in <see cref="global::InstallType" /></returns>\n        public static string[] GetNames()\n        {\n            return new[]\n            {\n                nameof(global::InstallType.None),\n                nameof(global::InstallType.ShowGUI),\n                nameof(global::InstallType.ShowNoGui),\n            };\n        }\n    }\n')))),(0,r.kt)("h2",{id:"usefull"},"Usefull"),(0,r.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{target:"_blank",href:a(9826).Z},"Download Example project NetEscapades.EnumGenerators "))),(0,r.kt)("h3",{id:"download-pdf"},"Download PDF"),(0,r.kt)("p",null,(0,r.kt)("a",{target:"_blank",href:a(6928).Z},"Download PDF NetEscapades.EnumGenerators ")),(0,r.kt)("h3",{id:"share-netescapadesenumgenerators"},"Share NetEscapades.EnumGenerators"),(0,r.kt)("ul",null,(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FNetEscapades.EnumGenerators&quote=NetEscapades.EnumGenerators",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FNetEscapades.EnumGenerators&text=NetEscapades.EnumGenerators:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FNetEscapades.EnumGenerators",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FNetEscapades.EnumGenerators&title=NetEscapades.EnumGenerators",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FNetEscapades.EnumGenerators&title=NetEscapades.EnumGenerators&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FNetEscapades.EnumGenerators",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/NetEscapades.EnumGenerators"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/NetEscapades.EnumGenerators")))}f.isMDXComponent=!0},6928:(e,n,a)=>{a.d(n,{Z:()=>t});const t=a.p+"assets/files/NetEscapades.EnumGenerators-86ff7ee8db029da54603f5e6fa6f606f.pdf"},9826:(e,n,a)=>{a.d(n,{Z:()=>t});const t=a.p+"assets/files/NetEscapades.EnumGenerators-a642b956e443d2606810960b67c9fb5e.zip"}}]);