"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[2399],{1115:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>u,toc:()=>c});var a=n(7462),r=(n(7294),n(4137)),i=n(3992),o=n(425),p=n(8839);const l={sidebar_position:760,title:"76 - UnitGenerator",description:"Generating classes instead of value objects( e.g. int)",slug:"/UnitGenerator"},s="UnitGenerator  by Cysharp, Inc",u={unversionedId:"RSCG-Examples/UnitGenerator",id:"RSCG-Examples/UnitGenerator",title:"76 - UnitGenerator",description:"Generating classes instead of value objects( e.g. int)",source:"@site/docs/RSCG-Examples/UnitGenerator.md",sourceDirName:"RSCG-Examples",slug:"/UnitGenerator",permalink:"/RSCG_Examples/v2/docs/UnitGenerator",draft:!1,tags:[],version:"current",sidebarPosition:760,frontMatter:{sidebar_position:760,title:"76 - UnitGenerator",description:"Generating classes instead of value objects( e.g. int)",slug:"/UnitGenerator"},sidebar:"tutorialSidebar",previous:{title:"75 - StaticReflection",permalink:"/RSCG_Examples/v2/docs/StaticReflection"},next:{title:"77 - DynamicsMapper",permalink:"/RSCG_Examples/v2/docs/DynamicsMapper"}},m={},c=[{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share UnitGenerator",id:"share-unitgenerator",level:3},{value:"In the same category (PrimitiveObsession)",id:"in-the-same-category-primitiveobsession",level:2},{value:"Strongly",id:"strongly",level:3},{value:"Vogen",id:"vogen",level:3}],d={toc:c},y="wrapper";function h(e){let{components:t,...l}=e;return(0,r.kt)(y,(0,a.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"unitgenerator--by-cysharp-inc"},"UnitGenerator  by Cysharp, Inc"),(0,r.kt)(p.Z,{toc:c,mdxType:"TOCInline"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/UnitGenerator/"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/UnitGenerator?label=UnitGenerator",alt:"Nuget"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/UnitGenerator"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/Cysharp/UnitGenerator?label=updated",alt:"GitHub last commit"})),"\n",(0,r.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/Cysharp/UnitGenerator?style=social",alt:"GitHub Repo stars"})),(0,r.kt)("h2",{id:"details"},"Details"),(0,r.kt)("h3",{id:"info"},"Info"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Name: ",(0,r.kt)("strong",{parentName:"p"},"UnitGenerator")),(0,r.kt)("p",{parentName:"admonition"},"C# Source Generator to create value-object, inspired by units of measure."),(0,r.kt)("p",{parentName:"admonition"},"Author: Cysharp, Inc"),(0,r.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/UnitGenerator/"},"https://www.nuget.org/packages/UnitGenerator/")),"   "),(0,r.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/UnitGenerator"},"https://github.com/Cysharp/UnitGenerator")),(0,r.kt)("p",{parentName:"admonition"},"Source : ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/UnitGenerator"},"https://github.com/Cysharp/UnitGenerator"))),(0,r.kt)("h3",{id:"original-readme"},"Original Readme"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("h1",{parentName:"admonition",id:"unitgenerator"},"UnitGenerator"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/UnitGenerator/actions"},(0,r.kt)("img",{parentName:"a",src:"https://github.com/Cysharp/UnitGenerator/workflows/Build-Debug/badge.svg",alt:"GitHub Actions"}))," ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/UnitGenerator/releases"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/release/Cysharp/UnitGenerator.svg",alt:"Releases"}))),(0,r.kt)("p",{parentName:"admonition"},"C# Source Generator to create ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Value_object"},"Value object")," pattern, also inspired by ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/units-of-measure"},"units of measure")," to support all arithmetic operators and serialization."),(0,r.kt)("p",{parentName:"admonition"},"NuGet: ",(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/UnitGenerator"},"UnitGenerator")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre"},"Install-Package UnitGenerator\n")),(0,r.kt)("h2",{parentName:"admonition",id:"introduction"},"Introduction"),(0,r.kt)("p",{parentName:"admonition"},"For example, Identifier, UserId is comparable only to UserId, and cannot be assigned to any other type. Also, arithmetic operations are not allowed."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using UnitGenerator;\n\n[UnitOf(typeof(int))]\npublic readonly partial struct UserId { }\n")),(0,r.kt)("p",{parentName:"admonition"},"will generates"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[System.ComponentModel.TypeConverter(typeof(UserIdTypeConverter))]\npublic readonly partial struct UserId : IEquatable<UserId> \n{\n    readonly int value;\n    \n    public UserId(int value)\n    {\n        this.value = value;\n    }\n\n    public readonly int AsPrimitive() => value;\n    public static explicit operator int(UserId value) => value.value;\n    public static explicit operator UserId(int value) => new UserId(value);\n    public bool Equals(UserId other) => value.Equals(other.value);\n    public override bool Equals(object? obj) => // snip...\n    public override int GetHashCode() => value.GetHashCode();\n    public override string ToString() => value.ToString();\n    public static bool operator ==(in UserId x, in UserId y) => x.value.Equals(y.value);\n    public static bool operator !=(in UserId x, in UserId y) => !x.value.Equals(y.value);\n\n    private class UserIdTypeConverter : System.ComponentModel.TypeConverter\n    {\n        // snip...\n    }\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"However, Hp in games, should not be allowed to be assigned to other types, but should support arithmetic operations with int. For example double heal = ",(0,r.kt)("inlineCode",{parentName:"p"},"target.Hp = Hp.Min(target.Hp * 2, target.MaxHp)"),"."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[UnitOf(typeof(int), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable | UnitGenerateOptions.MinMaxMethod)]\npublic readonly partial struct Hp { }\n\n// -- generates\n\n[System.ComponentModel.TypeConverter(typeof(HpTypeConverter))]\npublic readonly partial struct Hp\n    : IEquatable<Hp>\n#if NET7_0_OR_GREATER\n    , IEqualityOperators<Hp, Hp, bool>\n#endif    \n    , IComparable<Hp>\n#if NET7_0_OR_GREATER\n    , IComparisonOperators<Hp, Hp, bool>\n#endif\n#if NET7_0_OR_GREATER\n    , IAdditionOperators<Hp, Hp, Hp>\n    , ISubtractionOperators<Hp, Hp, Hp>\n    , IMultiplyOperators<Hp, Hp, Hp>\n    , IDivisionOperators<Hp, Hp, Hp>\n    , IUnaryPlusOperators<Hp, Hp>\n    , IUnaryNegationOperators<Hp, Hp>\n    , IIncrementOperators<Hp>\n    , IDecrementOperators<Hp>\n#endif    \n{\n    readonly int value;\n\n    public Hp(int value)\n    {\n        this.value = value;\n    }\n\n    public int AsPrimitive() => value;\n    public static explicit operator int(Hp value) => value.value;\n    public static explicit operator Hp(int value) => new Hp(value);\n    public bool Equals(Hp other) => value.Equals(other.value);\n    public override bool Equals(object? obj) => // snip...\n    public override int GetHashCode() => value.GetHashCode();\n    public override string ToString() => value.ToString();\n    public static bool operator ==(in Hp x, in Hp y) => x.value.Equals(y.value);\n    public static bool operator !=(in Hp x, in Hp y) => !x.value.Equals(y.value);\n    private class HpTypeConverter : System.ComponentModel.TypeConverter { /* snip... */ }\n\n    // UnitGenerateOptions.ArithmeticOperator\n    public static Hp operator +(Hp x, Hp y) => new Hp(checked((int)(x.value + y.value)));\n    public static Hp operator -(Hp x, Hp y) => new Hp(checked((int)(x.value - y.value)));\n    public static Hp operator *(Hp x, Hp y) => new Hp(checked((int)(x.value * y.value)));\n    public static Hp operator /(Hp x, Hp y) => new Hp(checked((int)(x.value / y.value)));\n    public static Hp operator ++(Hp x) => new Hp(checked((int)(x.value + 1)));\n    public static Hp operator --(Hp x) => new Hp(checked((int)(x.value - 1)));\n    public static Hp operator +(A value) => new((int)(+value.value));\n    public static Hp operator -(A value) => new((int)(-value.value));\n\n    // UnitGenerateOptions.ValueArithmeticOperator\n    public static Hp operator +(Hp x, in int y) => new Hp(checked((int)(x.value + y)));\n    public static Hp operator -(Hp x, in int y) => new Hp(checked((int)(x.value - y)));\n    public static Hp operator *(Hp x, in int y) => new Hp(checked((int)(x.value * y)));\n    public static Hp operator /(Hp x, in int y) => new Hp(checked((int)(x.value / y)));\n\n    // UnitGenerateOptions.Comparable\n    public int CompareTo(Hp other) => value.CompareTo(other.value);\n    public static bool operator >(Hp x, Hp y) => x.value > y.value;\n    public static bool operator <(Hp x, Hp y) => x.value < y.value;\n    public static bool operator >=(Hp x, Hp y) => x.value >= y.value;\n    public static bool operator <=(Hp x, Hp y) => x.value <= y.value;\n\n    // UnitGenerateOptions.MinMaxMethod\n    public static Hp Min(Hp x, Hp y) => new Hp(Math.Min(x.value, y.value));\n    public static Hp Max(Hp x, Hp y) => new Hp(Math.Max(x.value, y.value));\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"You can configure with ",(0,r.kt)("inlineCode",{parentName:"p"},"UnitGenerateOptions"),", which method to implement."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[Flags]\nenum UnitGenerateOptions\n{\n    None = 0,\n    ImplicitOperator = 1,\n    ParseMethod = 1 << 1,\n    MinMaxMethod = 1 << 2,\n    ArithmeticOperator = 1 << 3,\n    ValueArithmeticOperator = 1 << 4,\n    Comparable = 1 << 5,\n    Validate = 1 << 6,\n    JsonConverter = 1 << 7,\n    MessagePackFormatter = 1 << 8,\n    DapperTypeHandler = 1 << 9,\n    EntityFrameworkValueConverter = 1 << 10,\n    WithoutComparisonOperator = 1 << 11,\n    JsonConverterDictionaryKeySupport = 1 << 12,\n    Normalize = 1 << 13,\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"UnitGenerateOptions has some serializer support. For example, a result like ",(0,r.kt)("inlineCode",{parentName:"p"},"Serialize(userId) => { Value = 1111 }")," is awful. The value-object should be serialized natively, i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"Serialize(useId) => 1111"),", and should be able to be added directly to a database, etc."),(0,r.kt)("p",{parentName:"admonition"},"Currently UnitGenerator supports ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/neuecc/MessagePack-CSharp"},"MessagePack for C#"),", System.Text.Json(JsonSerializer), ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/StackExchange/Dapper"},"Dapper")," and EntityFrameworkCore."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[UnitOf(typeof(int), UnitGenerateOptions.MessagePackFormatter)]\npublic readonly partial struct UserId { }\n\n// -- generates\n\n[MessagePackFormatter(typeof(UserIdMessagePackFormatter))]\npublic readonly partial struct UserId \n{\n    class UserIdMessagePackFormatter : IMessagePackFormatter<UserId>\n    {\n        public void Serialize(ref MessagePackWriter writer, UserId value, MessagePackSerializerOptions options)\n        {\n            options.Resolver.GetFormatterWithVerify<int>().Serialize(ref writer, value.value, options);\n        }\n\n        public UserId Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n        {\n            return new UserId(options.Resolver.GetFormatterWithVerify<int>().Deserialize(ref reader, options));\n        }\n    }\n}\n")),(0,r.kt)("h2",{parentName:"admonition",id:"table-of-contents"},"Table of Contents"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#unitofattribute"},"UnitOfAttribute")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#unitgenerateoptions"},"UnitGenerateOptions"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#implicitoperator"},"ImplicitOperator")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#parsemethod"},"ParseMethod")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#minmaxmethod"},"MinMaxMethod")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#arithmeticoperator"},"ArithmeticOperator")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#valuearithmeticoperator"},"ValueArithmeticOperator")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#comparable"},"Comparable")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#withoutcomparisonoperator"},"WithoutComparisonOperator")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#validate"},"Validate")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#normalize"},"Normalize")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#jsonconverter"},"JsonConverter")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#jsonconverterdictionarykeysupport"},"JsonConverterDictionaryKeySupport")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#messagepackformatter"},"MessagePackFormatter")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#dappertypehandler"},"DapperTypeHandler")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#entityframeworkvalueconverter"},"EntityFrameworkValueConverter")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#use-for-unity"},"Use for Unity")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#license"},"License"))),(0,r.kt)("h2",{parentName:"admonition",id:"unitofattribute"},"UnitOfAttribute"),(0,r.kt)("p",{parentName:"admonition"},"When referring to the UnitGenerator, it generates a internal ",(0,r.kt)("inlineCode",{parentName:"p"},"UnitOfAttribute"),"."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"namespace UnitGenerator\n{\n    [AttributeUsage(AttributeTargets.Struct, AllowMultiple = false)]\n    internal class UnitOfAttribute : Attribute\n    {\n        public Type Type { get; }\n        public UnitGenerateOptions Options { get; }\n        public UnitArithmeticOperators ArithmeticOperators { get; set; }\n        public string ToStringFormat { get; set; }\n        \n        public UnitOfAttribute(Type type, UnitGenerateOptions options = UnitGenerateOptions.None) { ... }\n    }\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"You can attach this attribute with any specified underlying type to ",(0,r.kt)("inlineCode",{parentName:"p"},"readonly partial struct"),"."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[UnitOf(typeof(Guid))]\npublic readonly partial struct GroupId { }\n\n[UnitOf(typeof(string))]\npublic readonly partial struct Message { }\n\n[UnitOf(typeof(long))]\npublic readonly partial struct Power { }\n\n[UnitOf(typeof(byte[]))]\npublic readonly partial struct Image { }\n\n[UnitOf(typeof(DateTime))]\npublic readonly partial struct StartDate { }\n\n[UnitOf(typeof((string street, string city)))]\npublic readonly partial struct StreetAddress { }\n")),(0,r.kt)("p",{parentName:"admonition"},"Standard UnitOf(",(0,r.kt)("inlineCode",{parentName:"p"},"UnitGenerateOptions.None"),") generates value constructor, ",(0,r.kt)("inlineCode",{parentName:"p"},"explicit operator"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"implement IEquatable "),", ",(0,r.kt)("inlineCode",{parentName:"p"},"override GetHashCode"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"override ToString"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"==")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"!=")," operator, ",(0,r.kt)("inlineCode",{parentName:"p"},"TypeConverter")," for ASP.NET Core binding, ",(0,r.kt)("inlineCode",{parentName:"p"},"AsPrimitive")," method."),(0,r.kt)("p",{parentName:"admonition"},"If you want to retrieve primitive value, use ",(0,r.kt)("inlineCode",{parentName:"p"},"AsPrimitive()")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},".Value"),". This is intended to avoid casual getting of primitive values (using the arithmetic operator option if available)."),(0,r.kt)("blockquote",{parentName:"admonition"},(0,r.kt)("p",{parentName:"blockquote"},"When type is bool, also implements ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," operators.")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public static bool operator true(Foo x) => x.value;\npublic static bool operator false(Foo x) => !x.value;\npublic static bool operator !(Foo x) => !x.value;\n")),(0,r.kt)("blockquote",{parentName:"admonition"},(0,r.kt)("p",{parentName:"blockquote"},"When type is Guid or ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/Ulid"},"Ulid"),", also implements ",(0,r.kt)("inlineCode",{parentName:"p"},"New()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"New***()")," static operator.")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public static GroupId New();\npublic static GroupId NewGroupId();\n")),(0,r.kt)("p",{parentName:"admonition"},"Second parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"UnitGenerateOptions options")," can configure which method to implement, default is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,r.kt)("p",{parentName:"admonition"},"Optional named parameter: ",(0,r.kt)("inlineCode",{parentName:"p"},"ArithmeticOperators")," can configure which generates operators specifically. Default is ",(0,r.kt)("inlineCode",{parentName:"p"},"Number"),". (This can be used if UnitGenerateOptions.ArithmeticOperator is specified.)"),(0,r.kt)("p",{parentName:"admonition"},"Optional named parameter: ",(0,r.kt)("inlineCode",{parentName:"p"},"ToStringFormat")," can configure ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString")," format. Default is null and output as $",(0,r.kt)("inlineCode",{parentName:"p"},"{0}"),"."),(0,r.kt)("h2",{parentName:"admonition",id:"unitgenerateoptions"},"UnitGenerateOptions"),(0,r.kt)("p",{parentName:"admonition"},"When referring to the UnitGenerator, it generates a internal ",(0,r.kt)("inlineCode",{parentName:"p"},"UnitGenerateOptions")," that is bit flag of which method to implement."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[Flags]\ninternal enum UnitGenerateOptions\n{\n    None = 0,\n    ImplicitOperator = 1,\n    ParseMethod = 2,\n    MinMaxMethod = 4,\n    ArithmeticOperator = 8,\n    ValueArithmeticOperator = 16,\n    Comparable = 32,\n    Validate = 64,\n    JsonConverter = 128,\n    MessagePackFormatter = 256,\n    DapperTypeHandler = 512,\n    EntityFrameworkValueConverter = 1024,\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"You can use this with ",(0,r.kt)("inlineCode",{parentName:"p"},"[UnitOf]"),"."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[UnitOf(typeof(int), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable | UnitGenerateOptions.MinMaxMethod)]\npublic readonly partial struct Strength { }\n\n[UnitOf(typeof(DateTime), UnitGenerateOptions.Validate | UnitGenerateOptions.ParseMethod | UnitGenerateOptions.Comparable)]\npublic readonly partial struct EndDate { }\n\n[UnitOf(typeof(double), UnitGenerateOptions.ParseMethod | UnitGenerateOptions.MinMaxMethod | UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable | UnitGenerateOptions.Validate | UnitGenerateOptions.JsonConverter | UnitGenerateOptions.MessagePackFormatter | UnitGenerateOptions.DapperTypeHandler | UnitGenerateOptions.EntityFrameworkValueConverter)]\npublic readonly partial struct AllOptionsStruct { }\n")),(0,r.kt)("p",{parentName:"admonition"},"You can setup project default options like this."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"internal static class UnitOfOptions\n{\n    public const UnitGenerateOptions Default = UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable | UnitGenerateOptions.MinMaxMethod;\n}\n\n[UnitOf(typeof(int), UnitOfOptions.Default)]\npublic readonly partial struct Hp { }\n")),(0,r.kt)("h3",{parentName:"admonition",id:"implicitoperator"},"ImplicitOperator"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// Default\npublic static explicit operator U(T value) => value.value;\npublic static explicit operator T(U value) => new T(value);\n\n// UnitGenerateOptions.ImplicitOperator\npublic static implicit operator U(T value) => value.value;\npublic static implicit operator T(U value) => new T(value);\n")),(0,r.kt)("h3",{parentName:"admonition",id:"parsemethod"},"ParseMethod"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public static T Parse(string s)\npublic static bool TryParse(string s, out T result)\n")),(0,r.kt)("h3",{parentName:"admonition",id:"minmaxmethod"},"MinMaxMethod"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public static T Min(T x, T y)\npublic static T Max(T x, T y)\n")),(0,r.kt)("h3",{parentName:"admonition",id:"arithmeticoperator"},"ArithmeticOperator"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public static T operator +(in T x, in T y) => new T(checked((U)(x.value + y.value)));\npublic static T operator -(in T x, in T y) => new T(checked((U)(x.value - y.value)));\npublic static T operator *(in T x, in T y) => new T(checked((U)(x.value * y.value)));\npublic static T operator /(in T x, in T y) => new T(checked((U)(x.value / y.value)));\npublic static T operator +(T value) => new((U)(+value.value));\npublic static T operator -(T value) => new((U)(-value.value));\npublic static T operator ++(T x) => new T(checked((U)(x.value + 1)));\npublic static T operator --(T x) => new T(checked((U)(x.value - 1)));\n")),(0,r.kt)("p",{parentName:"admonition"},"In addition,  all members conforming to ",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/ja-jp/dotnet/api/system.numerics.inumber-1"},"System.Numerics.INumber")," are generated."),(0,r.kt)("p",{parentName:"admonition"},"If you want to suppress this and generate only certain operators, you can use the the ",(0,r.kt)("inlineCode",{parentName:"p"},"ArithmeticOperatros")," option of ",(0,r.kt)("inlineCode",{parentName:"p"},"[UnitOf]")," attribute as follows:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[UnitOf(\n    typeof(int), \n    UnitGenerateOptions.ArithmeticOperator,\n    ArithmeticOperators = UnitArithmeticOperators.Addition | UnitArithmeticOperators.Subtraction)]\npublic readonly partial struct Hp { }\n")),(0,r.kt)("table",{parentName:"admonition"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Generates"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UnitArithmeticOperators.Addition"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T operator +(T, T)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UnitArithmeticOperators.Subtraction"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T operator -(T, T)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UnitArithmeticOperators.Multiply"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T operator *(T, T)"),",  ",(0,r.kt)("inlineCode",{parentName:"td"},"T operator +(T)"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"T operator-(T)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UnitArithmeticOperators.Division"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T operator /(T, T)"),",  ",(0,r.kt)("inlineCode",{parentName:"td"},"T operator +(T)"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"T operator-(T)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UnitArithmeticOperators.Increment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T operator ++(T)"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UnitArithmeticOperators.Decrement"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T operator --(T)"))))),(0,r.kt)("h3",{parentName:"admonition",id:"valuearithmeticoperator"},"ValueArithmeticOperator"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public static T operator +(in T x, in U y) => new T(checked((U)(x.value + y)));\npublic static T operator -(in T x, in U y) => new T(checked((U)(x.value - y)));\npublic static T operator *(in T x, in U y) => new T(checked((U)(x.value * y)));\npublic static T operator /(in T x, in U y) => new T(checked((U)(x.value / y)));\n")),(0,r.kt)("h3",{parentName:"admonition",id:"comparable"},"Comparable"),(0,r.kt)("p",{parentName:"admonition"},"Implements ",(0,r.kt)("inlineCode",{parentName:"p"},"IComparable")," and ",(0,r.kt)("inlineCode",{parentName:"p"},">"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,r.kt)("inlineCode",{parentName:"p"},">="),", ",(0,r.kt)("inlineCode",{parentName:"p"},"<=")," operators."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public U CompareTo(T other) => value.CompareTo(other.value);\npublic static bool operator >(in T x, in T y) => x.value > y.value;\npublic static bool operator <(in T x, in T y) => x.value < y.value;\npublic static bool operator >=(in T x, in T y) => x.value >= y.value;\npublic static bool operator <=(in T x, in T y) => x.value <= y.value;\n")),(0,r.kt)("h3",{parentName:"admonition",id:"withoutcomparisonoperator"},"WithoutComparisonOperator"),(0,r.kt)("p",{parentName:"admonition"},"Without implements ",(0,r.kt)("inlineCode",{parentName:"p"},">"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,r.kt)("inlineCode",{parentName:"p"},">="),", ",(0,r.kt)("inlineCode",{parentName:"p"},"<=")," operators. For example, useful for Guid."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[UnitOf(typeof(Guid), UnitGenerateOptions.Comparable | UnitGenerateOptions.WithoutComparisonOperator)]\npublic readonly partial struct FooId { }\n")),(0,r.kt)("h3",{parentName:"admonition",id:"validate"},"Validate"),(0,r.kt)("p",{parentName:"admonition"},"Implements ",(0,r.kt)("inlineCode",{parentName:"p"},"partial void Validate()")," method that is called on constructor."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'// You can implement this custom validate method.\n[UnitOf(typeof(int), UnitGenerateOptions.Validate)]\npublic readonly partial struct SampleValidate\n{\n    // impl here.\n    private partial void Validate()\n    {\n        if (value > 9999) throw new Exception("Invalid value range: " + value);\n    }\n}\n\n// Source generator generate this codes.\npublic T(int value)\n{\n    this.value = value;\n    this.Validate();\n}\n \nprivate partial void Validate();\n')),(0,r.kt)("h3",{parentName:"admonition",id:"normalize"},"Normalize"),(0,r.kt)("p",{parentName:"admonition"},"Implements ",(0,r.kt)("inlineCode",{parentName:"p"},"partial void Normalize(ref T value)")," method that is called on constructor."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// You can implement this custom normalize method to change value during initialization\n[UnitOf(typeof(int), UnitGenerateOptions.Normalize)]\npublic readonly partial struct SampleValidate\n{\n    // impl here.\n    private partial void Normalize(ref int value)\n    {\n        value = Math.Max(value, 9999);\n    }\n}\n\n// Source generator generate this codes.\npublic T(int value)\n{\n    this.value = value;\n    this.Normalize(ref this.value);\n}\n \nprivate partial void Normalize(ref int value);\n")),(0,r.kt)("h3",{parentName:"admonition",id:"jsonconverter"},"JsonConverter"),(0,r.kt)("p",{parentName:"admonition"},"Implements ",(0,r.kt)("inlineCode",{parentName:"p"},"System.Text.Json"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonConverter"),". It will be used ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonSerializer")," automatically."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[JsonConverter(typeof(UserIdJsonConverter))]\npublic readonly partial struct UserId\n{\n    class UserIdJsonConverter : JsonConverter<UserId>\n}\n")),(0,r.kt)("h3",{parentName:"admonition",id:"jsonconverterdictionarykeysupport"},"JsonConverterDictionaryKeySupport"),(0,r.kt)("p",{parentName:"admonition"},"Implements ",(0,r.kt)("inlineCode",{parentName:"p"},"JsonConverter"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"WriteAsPropertyName/ReadAsPropertyName"),". It supports from .NET 6, supports Dictionary's Key."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"var dict = Dictionary<UserId, int>\nJsonSerializer.Serialize(dict);\n")),(0,r.kt)("h3",{parentName:"admonition",id:"messagepackformatter"},"MessagePackFormatter"),(0,r.kt)("p",{parentName:"admonition"},"Implements MessagePack for C#'s ",(0,r.kt)("inlineCode",{parentName:"p"},"MessagePackFormatter"),". It will be used ",(0,r.kt)("inlineCode",{parentName:"p"},"MessagePackSerializer")," automatically."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[MessagePackFormatter(typeof(UserIdMessagePackFormatter))]\npublic readonly partial struct UserId\n{\n    class UserIdMessagePackFormatter : IMessagePackFormatter<UserId>\n}\n")),(0,r.kt)("h3",{parentName:"admonition",id:"dappertypehandler"},"DapperTypeHandler"),(0,r.kt)("p",{parentName:"admonition"},"Implements Dapper's TypeHandler by public accessibility. TypeHandler is automatically registered at the time of Module initialization."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public readonly partial struct UserId\n{\n    public class UserIdTypeHandler : Dapper.SqlMapper.TypeHandler<UserId>\n}\n\n[ModuleInitializer]\npublic static void AddTypeHandler()\n{\n    Dapper.SqlMapper.AddTypeHandler(new A.ATypeHandler());\n}\n")),(0,r.kt)("h3",{parentName:"admonition",id:"entityframeworkvalueconverter"},"EntityFrameworkValueConverter"),(0,r.kt)("p",{parentName:"admonition"},"Implements EntityFrameworkCore's ValueConverter by public accessibility. It is not registered automatically so you need to register manually."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public readonly partial struct UserId\n{\n    public class UserIdValueConverter : ValueConverter<UserId, int>\n}\n\n// setup handler manually\nbuilder.HasConversion(new UserId.UserIdValueConverter());\n")),(0,r.kt)("h2",{parentName:"admonition",id:"use-for-unity"},"Use for Unity"),(0,r.kt)("p",{parentName:"admonition"},"C# Source Generator feature is rely on C# 9.0. If you are using Unity 2021.2, that supports ",(0,r.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/2021.2/Documentation/Manual/roslyn-analyzers.html"},"Source Generators"),". Add the ",(0,r.kt)("inlineCode",{parentName:"p"},"UnitGenerator.dll")," from the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/UnitGenerator/releases"},"releases page"),", disable Any Platform, disable Include all platforms and set label as ",(0,r.kt)("inlineCode",{parentName:"p"},"RoslynAnalyzer"),"."),(0,r.kt)("p",{parentName:"admonition"},"It works in Unity Editor however does not work on IDE because Unity does not generate analyzer reference to ",(0,r.kt)("inlineCode",{parentName:"p"},".csproj"),". We provides ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/CsprojModifier"},"CsprojModifer")," to analyzer support, uses ",(0,r.kt)("inlineCode",{parentName:"p"},"Add analyzer references to generated .csproj")," supports both IDE and Unity Editor."),(0,r.kt)("p",{parentName:"admonition"},"Unity(2020) does not support C# 9.0 so can not use directly. However, C# Source Genertor supports output source as file."),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},"Create ",(0,r.kt)("inlineCode",{parentName:"li"},"UnitSourceGen.csproj"),".")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<Project Sdk="Microsoft.NET.Sdk">\n    <PropertyGroup>\n        <TargetFramework>net5.0</TargetFramework>\n\n        \x3c!-- add this two lines and configure output path --\x3e\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(ProjectDir)..\\Generated</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n\n    <ItemGroup>\n        \x3c!-- reference UnitGenerator --\x3e\n        <PackageReference Include="UnitGenerator" Version="1.0.0" />\n\n        \x3c!-- add target sources path from Unity --\x3e\n        <Compile Include="..\\MyUnity\\Assets\\Scripts\\Models\\**\\*.cs" />\n    </ItemGroup>\n</Project>\n')),(0,r.kt)("ol",{parentName:"admonition",start:2},(0,r.kt)("li",{parentName:"ol"},"install ",(0,r.kt)("a",{parentName:"li",href:"https://dotnet.microsoft.com/download"},".NET SDK")," and run this command.")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre"},"dotnet build UnitSourceGen.csproj\n")),(0,r.kt)("p",{parentName:"admonition"},"File will be generated under ",(0,r.kt)("inlineCode",{parentName:"p"},"UnitGenerator\\UnitGenerator.SourceGenerator\\*.Generated.cs"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"UnitOfAttribute")," is also included in generated folder, so at first, run build command and get attribute to configure."),(0,r.kt)("h2",{parentName:"admonition",id:"license"},"License"),(0,r.kt)("p",{parentName:"admonition"},"This library is under the MIT License.")),(0,r.kt)("h3",{id:"about"},"About"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Generating classes instead of value objects( e.g. int)")),(0,r.kt)("h2",{id:"how-to-use"},"How to use"),(0,r.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,r.kt)("p",null,"This is the CSharp Project that references ",(0,r.kt)("strong",{parentName:"p"},"UnitGenerator")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {16}",showLineNumbers:!0,"{16}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net7.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include="UnitGenerator" Version="1.5.1">\n      <PrivateAssets>all</PrivateAssets>\n      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n    </PackageReference>\n  </ItemGroup>\n</Project>\n\n'))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnitGenerator\\src\\UnitDemo\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"UnitGenerator")," in ",(0,r.kt)("em",{parentName:"p"},"Program.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// See https://aka.ms/new-console-template for more information\nusing StronglyDemo;\n\nPerson p = new();\n//p.SetBirthDate(1970, 4, 16);\np.SetBirthDate(new YearId(1970) , new MonthId(4),new DayId( 16));\nConsole.WriteLine(p.BirthDate);\n"))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnitGenerator\\src\\UnitDemo\\Person.cs",label:"Person.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"UnitGenerator")," in ",(0,r.kt)("em",{parentName:"p"},"Person.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"\nusing UnitGenerator;\n\nnamespace StronglyDemo;\n\n\n[UnitOf(typeof(int))]\npublic partial struct YearId { }\n\n[UnitOf(typeof(int))]\npublic partial struct MonthId { }\n\n[UnitOf(typeof(int))]\npublic partial struct DayId { }\n\ninternal class Person\n{\n    public DateTime BirthDate { get; internal set; }\n    public void SetBirthDate(YearId yearId,MonthId monthId,DayId dayId)\n    {\n        BirthDate = new DateTime(yearId.AsPrimitive(), monthId.AsPrimitive(), dayId.AsPrimitive());\n    }\n}\n\n")))),(0,r.kt)("h3",{id:"generated-files"},"Generated Files"),(0,r.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnitGenerator\\src\\UnitDemo\\obj\\GX\\UnitGenerator\\UnitGenerator.SourceGenerator\\StronglyDemo.DayId.g.cs",label:"StronglyDemo.DayId.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY UnitGenerator. DO NOT CHANGE IT.\n// </auto-generated>\n#pragma warning disable CS8669\nusing System;\nusing System.Globalization;\n#if NET7_0_OR_GREATER\nusing System.Numerics;\n#endif\nnamespace StronglyDemo\n{\n    [System.ComponentModel.TypeConverter(typeof(DayIdTypeConverter))]\n    readonly partial struct DayId \n        : IEquatable<DayId>\n#if NET7_0_OR_GREATER\n        , IEqualityOperators<DayId, DayId, bool>\n#endif    \n    {\n        readonly int value;\n\n        public int AsPrimitive() => value;\n\n        public DayId(int value)\n        {\n            this.value = value;\n        }\n        \n        public static explicit operator int(DayId value)\n        {\n            return value.value;\n        }\n\n        public static explicit operator DayId(int value)\n        {\n            return new DayId(value);\n        }\n\n        public bool Equals(DayId other)\n        {\n            return value.Equals(other.value);\n        }\n\n        public override bool Equals(object obj)\n        {\n            if (obj == null) return false;\n            var t = obj.GetType();\n            if (t == typeof(DayId))\n            {\n                return Equals((DayId)obj);\n            }\n            if (t == typeof(int))\n            {\n                return value.Equals((int)obj);\n            }\n\n            return value.Equals(obj);\n        }\n        \n        public static bool operator ==(DayId x, DayId y)\n        {\n            return x.value.Equals(y.value);\n        }\n\n        public static bool operator !=(DayId x, DayId y)\n        {\n            return !x.value.Equals(y.value);\n        }\n\n        public override int GetHashCode()\n        {\n            return value.GetHashCode();\n        }\n\n        public override string ToString() => value.ToString();\n\n        // Default\n        \n        private class DayIdTypeConverter : System.ComponentModel.TypeConverter\n        {\n            private static readonly Type WrapperType = typeof(DayId);\n            private static readonly Type ValueType = typeof(int);\n\n            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, Type sourceType)\n            {\n                if (sourceType == WrapperType || sourceType == ValueType)\n                {\n                    return true;\n                }\n\n                return base.CanConvertFrom(context, sourceType);\n            }\n\n            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, Type destinationType)\n            {\n                if (destinationType == WrapperType || destinationType == ValueType)\n                {\n                    return true;\n                }\n\n                return base.CanConvertTo(context, destinationType);\n            }\n\n            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)\n            {\n                if (value != null)\n                {\n                    var t = value.GetType();\n                    if (t == typeof(DayId))\n                    {\n                        return (DayId)value;\n                    }\n                    if (t == typeof(int))\n                    {\n                        return new DayId((int)value);\n                    }\n                }\n\n                return base.ConvertFrom(context, culture, value);\n            }\n\n            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)\n            {\n                if (value is DayId wrappedValue)\n                {\n                    if (destinationType == WrapperType)\n                    {\n                        return wrappedValue;\n                    }\n\n                    if (destinationType == ValueType)\n                    {\n                        return wrappedValue.AsPrimitive();\n                    }\n                }\n\n                return base.ConvertTo(context, culture, value, destinationType);\n            }\n        }\n    }\n}\n\n"))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnitGenerator\\src\\UnitDemo\\obj\\GX\\UnitGenerator\\UnitGenerator.SourceGenerator\\StronglyDemo.MonthId.g.cs",label:"StronglyDemo.MonthId.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY UnitGenerator. DO NOT CHANGE IT.\n// </auto-generated>\n#pragma warning disable CS8669\nusing System;\nusing System.Globalization;\n#if NET7_0_OR_GREATER\nusing System.Numerics;\n#endif\nnamespace StronglyDemo\n{\n    [System.ComponentModel.TypeConverter(typeof(MonthIdTypeConverter))]\n    readonly partial struct MonthId \n        : IEquatable<MonthId>\n#if NET7_0_OR_GREATER\n        , IEqualityOperators<MonthId, MonthId, bool>\n#endif    \n    {\n        readonly int value;\n\n        public int AsPrimitive() => value;\n\n        public MonthId(int value)\n        {\n            this.value = value;\n        }\n        \n        public static explicit operator int(MonthId value)\n        {\n            return value.value;\n        }\n\n        public static explicit operator MonthId(int value)\n        {\n            return new MonthId(value);\n        }\n\n        public bool Equals(MonthId other)\n        {\n            return value.Equals(other.value);\n        }\n\n        public override bool Equals(object obj)\n        {\n            if (obj == null) return false;\n            var t = obj.GetType();\n            if (t == typeof(MonthId))\n            {\n                return Equals((MonthId)obj);\n            }\n            if (t == typeof(int))\n            {\n                return value.Equals((int)obj);\n            }\n\n            return value.Equals(obj);\n        }\n        \n        public static bool operator ==(MonthId x, MonthId y)\n        {\n            return x.value.Equals(y.value);\n        }\n\n        public static bool operator !=(MonthId x, MonthId y)\n        {\n            return !x.value.Equals(y.value);\n        }\n\n        public override int GetHashCode()\n        {\n            return value.GetHashCode();\n        }\n\n        public override string ToString() => value.ToString();\n\n        // Default\n        \n        private class MonthIdTypeConverter : System.ComponentModel.TypeConverter\n        {\n            private static readonly Type WrapperType = typeof(MonthId);\n            private static readonly Type ValueType = typeof(int);\n\n            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, Type sourceType)\n            {\n                if (sourceType == WrapperType || sourceType == ValueType)\n                {\n                    return true;\n                }\n\n                return base.CanConvertFrom(context, sourceType);\n            }\n\n            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, Type destinationType)\n            {\n                if (destinationType == WrapperType || destinationType == ValueType)\n                {\n                    return true;\n                }\n\n                return base.CanConvertTo(context, destinationType);\n            }\n\n            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)\n            {\n                if (value != null)\n                {\n                    var t = value.GetType();\n                    if (t == typeof(MonthId))\n                    {\n                        return (MonthId)value;\n                    }\n                    if (t == typeof(int))\n                    {\n                        return new MonthId((int)value);\n                    }\n                }\n\n                return base.ConvertFrom(context, culture, value);\n            }\n\n            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)\n            {\n                if (value is MonthId wrappedValue)\n                {\n                    if (destinationType == WrapperType)\n                    {\n                        return wrappedValue;\n                    }\n\n                    if (destinationType == ValueType)\n                    {\n                        return wrappedValue.AsPrimitive();\n                    }\n                }\n\n                return base.ConvertTo(context, culture, value, destinationType);\n            }\n        }\n    }\n}\n\n"))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnitGenerator\\src\\UnitDemo\\obj\\GX\\UnitGenerator\\UnitGenerator.SourceGenerator\\StronglyDemo.YearId.g.cs",label:"StronglyDemo.YearId.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY UnitGenerator. DO NOT CHANGE IT.\n// </auto-generated>\n#pragma warning disable CS8669\nusing System;\nusing System.Globalization;\n#if NET7_0_OR_GREATER\nusing System.Numerics;\n#endif\nnamespace StronglyDemo\n{\n    [System.ComponentModel.TypeConverter(typeof(YearIdTypeConverter))]\n    readonly partial struct YearId \n        : IEquatable<YearId>\n#if NET7_0_OR_GREATER\n        , IEqualityOperators<YearId, YearId, bool>\n#endif    \n    {\n        readonly int value;\n\n        public int AsPrimitive() => value;\n\n        public YearId(int value)\n        {\n            this.value = value;\n        }\n        \n        public static explicit operator int(YearId value)\n        {\n            return value.value;\n        }\n\n        public static explicit operator YearId(int value)\n        {\n            return new YearId(value);\n        }\n\n        public bool Equals(YearId other)\n        {\n            return value.Equals(other.value);\n        }\n\n        public override bool Equals(object obj)\n        {\n            if (obj == null) return false;\n            var t = obj.GetType();\n            if (t == typeof(YearId))\n            {\n                return Equals((YearId)obj);\n            }\n            if (t == typeof(int))\n            {\n                return value.Equals((int)obj);\n            }\n\n            return value.Equals(obj);\n        }\n        \n        public static bool operator ==(YearId x, YearId y)\n        {\n            return x.value.Equals(y.value);\n        }\n\n        public static bool operator !=(YearId x, YearId y)\n        {\n            return !x.value.Equals(y.value);\n        }\n\n        public override int GetHashCode()\n        {\n            return value.GetHashCode();\n        }\n\n        public override string ToString() => value.ToString();\n\n        // Default\n        \n        private class YearIdTypeConverter : System.ComponentModel.TypeConverter\n        {\n            private static readonly Type WrapperType = typeof(YearId);\n            private static readonly Type ValueType = typeof(int);\n\n            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, Type sourceType)\n            {\n                if (sourceType == WrapperType || sourceType == ValueType)\n                {\n                    return true;\n                }\n\n                return base.CanConvertFrom(context, sourceType);\n            }\n\n            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, Type destinationType)\n            {\n                if (destinationType == WrapperType || destinationType == ValueType)\n                {\n                    return true;\n                }\n\n                return base.CanConvertTo(context, destinationType);\n            }\n\n            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)\n            {\n                if (value != null)\n                {\n                    var t = value.GetType();\n                    if (t == typeof(YearId))\n                    {\n                        return (YearId)value;\n                    }\n                    if (t == typeof(int))\n                    {\n                        return new YearId((int)value);\n                    }\n                }\n\n                return base.ConvertFrom(context, culture, value);\n            }\n\n            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)\n            {\n                if (value is YearId wrappedValue)\n                {\n                    if (destinationType == WrapperType)\n                    {\n                        return wrappedValue;\n                    }\n\n                    if (destinationType == ValueType)\n                    {\n                        return wrappedValue.AsPrimitive();\n                    }\n                }\n\n                return base.ConvertTo(context, culture, value, destinationType);\n            }\n        }\n    }\n}\n\n"))),(0,r.kt)(o.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\UnitGenerator\\src\\UnitDemo\\obj\\GX\\UnitGenerator\\UnitGenerator.SourceGenerator\\UnitOfAttribute.cs",label:"UnitOfAttribute.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY UnitGenerator. DO NOT CHANGE IT.\n// </auto-generated>\n#pragma warning disable CS8669\n#pragma warning disable CS8625\nusing System;\n#if NET7_0_OR_GREATER\nusing System.Numerics;\n#endif\n\nnamespace UnitGenerator\n{\n    [AttributeUsage(AttributeTargets.Struct, AllowMultiple = false)]\n    internal class UnitOfAttribute : Attribute\n    {\n        public Type Type { get; }\n        public UnitGenerateOptions Options { get; }\n        public UnitArithmeticOperators ArithmeticOperators { get; set; } = UnitArithmeticOperators.All;\n        public string ToStringFormat { get; set; }\n\n        public UnitOfAttribute(Type type, UnitGenerateOptions options = UnitGenerateOptions.None)\n        {\n            this.Type = type;\n            this.Options = options;\n        }\n    }\n    \n    [Flags]\n    internal enum UnitGenerateOptions\n    {\n        None = 0,\n        ImplicitOperator = 1,\n        ParseMethod = 1 << 1,\n        MinMaxMethod = 1 << 2,\n        ArithmeticOperator = 1 << 3,\n        ValueArithmeticOperator = 1 << 4,\n        Comparable = 1 << 5,\n        Validate = 1 << 6,\n        JsonConverter = 1 << 7,\n        MessagePackFormatter = 1 << 8,\n        DapperTypeHandler = 1 << 9,\n        EntityFrameworkValueConverter = 1 << 10,\n        WithoutComparisonOperator = 1 << 11,\n        JsonConverterDictionaryKeySupport = 1 << 12,\n        Normalize = 1 << 13,\n    }\n\n    [Flags]\n    internal enum UnitArithmeticOperators\n    {\n        All = Addition | Subtraction | Multiply | Division | Increment | Decrement,\n        Addition = 1,\n        Subtraction = 1 << 1,\n        Multiply = 1 << 2,\n        Division = 1 << 3,\n        Increment = 1 << 4,\n        Decrement = 1 << 5,\n    }\n}\n\n")))),(0,r.kt)("h2",{id:"usefull"},"Usefull"),(0,r.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{target:"_blank",href:n(2956).Z},"Download Example project UnitGenerator "))),(0,r.kt)("h3",{id:"share-unitgenerator"},"Share UnitGenerator"),(0,r.kt)("ul",null,(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnitGenerator&quote=UnitGenerator",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnitGenerator&text=UnitGenerator:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnitGenerator",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnitGenerator&title=UnitGenerator",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnitGenerator&title=UnitGenerator&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FUnitGenerator",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/UnitGenerator"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/UnitGenerator")),(0,r.kt)("h2",{id:"in-the-same-category-primitiveobsession"},"In the same category (PrimitiveObsession)"),(0,r.kt)("h3",{id:"strongly"},(0,r.kt)("a",{parentName:"h3",href:"/docs/Strongly"},"Strongly")),(0,r.kt)("h3",{id:"vogen"},(0,r.kt)("a",{parentName:"h3",href:"/docs/Vogen"},"Vogen")))}h.isMDXComponent=!0},2956:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/UnitGenerator-71d18e2b6eb6834aa6f1b3d7d84a5cb5.zip"}}]);