"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[5863],{4137:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(n),m=a,g=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?r.createElement(g,l(l({ref:t},p),{},{components:n})):r.createElement(g,l({ref:t},p))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:a,l[1]=o;for(var c=2;c<i;c++)l[c]=n[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8444:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=n(7462),a=(n(7294),n(4137));const i={},l="AutoRegisterInject",o={unversionedId:"RSCG-Examples/AutoRegisterInject_readme",id:"RSCG-Examples/AutoRegisterInject_readme",title:"AutoRegisterInject",description:"AutoRegisterInject, also referred to as ARI, is a C# source generator that will automatically create Microsoft.Extensions.DependencyInjection registrations for types marked with attributes.",source:"@site/docs/RSCG-Examples/AutoRegisterInject_readme.md",sourceDirName:"RSCG-Examples",slug:"/RSCG-Examples/AutoRegisterInject_readme",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/AutoRegisterInject_readme",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AutoDeconstruct",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/AutoDeconstruct_readme"},next:{title:"Breezy_readme",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/Breezy_readme"}},s={},c=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"Register as interface",id:"register-as-interface",level:3},{value:"Multiple assemblies",id:"multiple-assemblies",level:3},{value:"License",id:"license",level:2}],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"autoregisterinject"},"AutoRegisterInject"),(0,a.kt)("p",null,"AutoRegisterInject, also referred to as ARI, is a C# source generator that will automatically create Microsoft.Extensions.DependencyInjection registrations for types marked with attributes."),(0,a.kt)("p",null,"This is a compile time alternative to reflection/assembly scanning for your injections or manually adding to the ",(0,a.kt)("inlineCode",{parentName:"p"},"ServiceCollection")," every time a new type needs to be registered."),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"namespace MyProject;\n\n[RegisterScoped]\npublic class Foo { }\n")),(0,a.kt)("p",null,"will automatically generate an extension method called ",(0,a.kt)("inlineCode",{parentName:"p"},"AutoRegister()")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"IServiceProvider"),", that registers ",(0,a.kt)("inlineCode",{parentName:"p"},"Foo"),", as scoped."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"internal IServiceCollection AutoRegister(this IServiceCollection serviceCollection)\n{\n    serviceCollection.AddScoped<Foo>();\n    return serviceCollection;\n}\n")),(0,a.kt)("p",null,"In larger projects, dependency injection registration becomes tedious and in team situations can lead to merge conflicts which can be easily avoided."),(0,a.kt)("p",null,"AutoRegisterInject moves the responsibility of service registration to the owning type rather than external service collection configuration, giving control and oversight of the type that is going to be registered with the container."),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"Install the ",(0,a.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/AutoRegisterInject"},"Nuget")," package, and start decorating classes with ARI attributes."),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"dotnet add package AutoRegisterInject")," or add a package reference manually:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-xml"},'<PackageReference Include="AutoRegisterInject" />\n')),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("p",null,"Classes should be decorated with one of four attributes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"[RegisterScoped]")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"[RegisterSingleton]")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"[RegisterTransient]")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"[RegisterHostedService]"))),(0,a.kt)("p",null,"Register a class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"[RegisterScoped]\nclass Foo;\n")),(0,a.kt)("p",null,"and get the following output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"serviceCollection.AddScoped<Foo>();\n")),(0,a.kt)("p",null,"Update the service collection by invoking:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"var serviceCollection = new ServiceCollection();\nserviceCollection.AutoRegister();\nserviceCollection.BuildServiceProvider();\n")),(0,a.kt)("p",null,"You can now inject ",(0,a.kt)("inlineCode",{parentName:"p"},"Foo")," as a dependency and have this resolved as scoped."),(0,a.kt)("p",null,"Alternatively, you can register hosted services by:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"[RegisterHostedService]\nclass Foo;\n")),(0,a.kt)("p",null,"and get:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"serviceCollection.AddHostedService<Foo>();\n")),(0,a.kt)("h3",{id:"register-as-interface"},"Register as interface"),(0,a.kt)("p",null,"Implement one or many interfaces on your target class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"[RegisterTransient]\nclass Bar : IBar;\n")),(0,a.kt)("p",null,"and get the following output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"serviceCollection.AddTransient<IBar, Bar>();\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Important note:")," AutoRegisterInject is opinionated and ",(0,a.kt)("inlineCode",{parentName:"p"},"Bar")," will only be registered with its implemented interface. ARI will ",(0,a.kt)("strong",{parentName:"p"},"not")," register ",(0,a.kt)("inlineCode",{parentName:"p"},"Bar"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"Bar")," will always need to be resolved from ",(0,a.kt)("inlineCode",{parentName:"p"},"IBar")," in your code."),(0,a.kt)("p",null,"Implementing multiple interfaces will have the implementing type be registered for each distinct interface."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"[RegisterTransient]\nclass Bar : IBar, IFoo, IBaz;\n")),(0,a.kt)("p",null,"will output the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"serviceCollection.AddTransient<IBar, Bar>();\nserviceCollection.AddTransient<IFoo, Bar>();\nserviceCollection.AddTransient<IBaz, Bar>();\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Important note:")," AutoRegisterInject is opinionated and ",(0,a.kt)("inlineCode",{parentName:"p"},"Bar")," will only be registered with its implemented interfaces. ARI will ",(0,a.kt)("strong",{parentName:"p"},"not")," register ",(0,a.kt)("inlineCode",{parentName:"p"},"Bar"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"Bar")," will always need to be resolved from ",(0,a.kt)("inlineCode",{parentName:"p"},"IBar"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"IFoo")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"IBaz")," in your code."),(0,a.kt)("h3",{id:"multiple-assemblies"},"Multiple assemblies"),(0,a.kt)("p",null,"In addition to the ",(0,a.kt)("inlineCode",{parentName:"p"},"AutoRegister")," extension method, every assembly that AutoRegisterInject is a part of, a ",(0,a.kt)("inlineCode",{parentName:"p"},"AutoRegisterFromAssemblyName")," will be generated. This allows you to configure your service collection from one, main, executing assembly."),(0,a.kt)("p",null,"Given 3 assemblies, ",(0,a.kt)("inlineCode",{parentName:"p"},"MyProject.Main"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"MyProject.Services"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"MyProject.Data"),", you can configure the ",(0,a.kt)("inlineCode",{parentName:"p"},"ServiceCollection")," as such:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"var serviceCollection = new ServiceCollection();\nserviceCollection.AutoRegisterFromMyProjectMain();\nserviceCollection.AutoRegisterFromMyProjectServices();\nserviceCollection.AutoRegisterFromMyProjectData();\nserviceCollection.BuildServiceProvider();\n")),(0,a.kt)("p",null,"AutoRegisterInject will remove illegal characters from assembly names in order to generate legal C# method names. ",(0,a.kt)("inlineCode",{parentName:"p"},","),", ",(0,a.kt)("inlineCode",{parentName:"p"},".")," and ",(0,a.kt)("inlineCode",{parentName:"p"}," ")," will be removed."),(0,a.kt)("h2",{id:"license"},"License"),(0,a.kt)("p",null,"AutoRegisterInject is MIT licensed. Do with it what you please under the terms of MIT."))}d.isMDXComponent=!0}}]);