"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[1137],{18800:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>g,frontMatter:()=>u,metadata:()=>p,toc:()=>d});var n=a(87462),i=(a(67294),a(3905)),r=a(73992),l=a(18679),o=a(68839);const u={sidebar_position:1990,title:"199 - SuperFluid",description:"Generate a state machine from a yaml file",slug:"/SuperFluid"},s="SuperFluid  by James Hughes",p={unversionedId:"RSCG-Examples/SuperFluid",id:"RSCG-Examples/SuperFluid",title:"199 - SuperFluid",description:"Generate a state machine from a yaml file",source:"@site/docs/RSCG-Examples/SuperFluid.md",sourceDirName:"RSCG-Examples",slug:"/SuperFluid",permalink:"/RSCG_Examples/v2/docs/SuperFluid",draft:!1,tags:[],version:"current",sidebarPosition:1990,frontMatter:{sidebar_position:1990,title:"199 - SuperFluid",description:"Generate a state machine from a yaml file",slug:"/SuperFluid"},sidebar:"tutorialSidebar",previous:{title:"198 - DimonSmart.BuilderGenerator",permalink:"/RSCG_Examples/v2/docs/DimonSmart.BuilderGenerator"},next:{title:"200 - Figgle",permalink:"/RSCG_Examples/v2/docs/Figgle"}},m={},d=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use-1",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share SuperFluid",id:"share-superfluid",level:3},{value:"In the same category (StateMachine) - 0 other generators",id:"in-the-same-category-statemachine---0-other-generators",level:3}],c={toc:d},h="wrapper";function g(e){let{components:t,...u}=e;return(0,i.kt)(h,(0,n.Z)({},c,u,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"superfluid--by-james-hughes"},"SuperFluid  by James Hughes"),(0,i.kt)(o.Z,{toc:d,mdxType:"TOCInline"}),(0,i.kt)("h2",{id:"nuget--site-data"},"NuGet / site data"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/SuperFluid/"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/SuperFluid?label=SuperFluid",alt:"Nuget"})),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hughesjs/SuperFluid"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/hughesjs/SuperFluid?label=updated",alt:"GitHub last commit"})),"\n",(0,i.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/hughesjs/SuperFluid?style=social",alt:"GitHub Repo stars"})),(0,i.kt)("h2",{id:"details"},"Details"),(0,i.kt)("h3",{id:"info"},"Info"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Name: ",(0,i.kt)("strong",{parentName:"p"},"SuperFluid")),(0,i.kt)("p",{parentName:"admonition"},"An incremental source generator for fluent APIs with grammar"),(0,i.kt)("p",{parentName:"admonition"},"Author: James Hughes"),(0,i.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/SuperFluid/"},"https://www.nuget.org/packages/SuperFluid/")),"   "),(0,i.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hughesjs/SuperFluid"},"https://github.com/hughesjs/SuperFluid")),(0,i.kt)("p",{parentName:"admonition"},"Source: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hughesjs/SuperFluid"},"https://github.com/hughesjs/SuperFluid"))),(0,i.kt)("h3",{id:"original-readme"},"Original Readme"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/hughesjs/SuperFluid/actions"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/github/actions/workflow/status/hughesjs/SuperFluid/dotnet-ci.yml?label=BUILD%20CI&style=for-the-badge&branch=master",alt:"GitHub Workflow Status CI"})),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hughesjs/SuperFluid/actions"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/github/actions/workflow/status/hughesjs/SuperFluid/dotnet-cd.yml?label=BUILD%20CD&style=for-the-badge&branch=master",alt:"GitHub Workflow Status CD"})),"\n",(0,i.kt)("img",{parentName:"p",src:"https://img.shields.io/github/languages/top/hughesjs/SuperFluid?style=for-the-badge",alt:"GitHub top language"}),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hughesjs/SuperFluid/LICENSE"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/github/license/hughesjs/SuperFluid?style=for-the-badge",alt:"GitHub"})),"\n",(0,i.kt)("a",{parentName:"p",href:"https://nuget.org/packages/SuperFluid/"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/vpre/SuperFluid?style=for-the-badge",alt:"Nuget (with prereleases)"})),"\n",(0,i.kt)("a",{parentName:"p",href:"https://nuget.org/packages/SuperFluid/"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/SuperFluid?style=for-the-badge",alt:"Nuget"})),"\n",(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/hughesjs/custom-badges/master/made-in/made-in-scotland.svg",alt:"FTB"})),(0,i.kt)("hr",{parentName:"admonition"}),(0,i.kt)("h1",{parentName:"admonition",id:"superfluid"},"SuperFluid"),(0,i.kt)("p",{parentName:"admonition"},"A C# library for generating fluent APIs with grammar."),(0,i.kt)("h1",{parentName:"admonition",id:"introduction"},"Introduction"),(0,i.kt)("p",{parentName:"admonition"},"It is often desirable to define an API that allows us to express our intentions as an easily readable method chain."),(0,i.kt)("p",{parentName:"admonition"},"The most common example of this in C# would probably be LINQ:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"var result = myCollection\n    .Where(item => item.IsActive)\n    .OrderBy(item => item.Name)\n    .Select(item => new { item.Id, item.Name });\n")),(0,i.kt)("p",{parentName:"admonition"},"The simple case of this is actually quite simple to implement, you just have each of your methods return the type of the declaring object and ",(0,i.kt)("inlineCode",{parentName:"p"},"this"),"."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"public class Car\n{\n    public Car Unlock()\n    {\n        // Do something\n        return this;\n    }\n    \n    public Car Enter()\n    {\n        // Do something\n        return this;\n    }\n    \n    public Car Start()\n    {\n        // Do something\n        return this;\n    }\n}\n\n// Which then lets us do\nvar car = new Car().Unlock().Enter().Start();\n")),(0,i.kt)("p",{parentName:"admonition"},"However, in this instance, there's nothing stopping us from starting the car before we've unlocked and entered it."),(0,i.kt)("p",{parentName:"admonition"},"Clearly, in cases where we want to enforce a valid state, we have to define a grammar for our API."),(0,i.kt)("p",{parentName:"admonition"},"Typically, we accomplish this by designing a state machine for our API and then working out the set of all unique combinations of transitions, and creating interfaces for each of these states.\nWe can then make the return type for each method be the interface that represents the set of transitions that it allows."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Car: ICanEnter, ICanStart\n{\n    public ICanEnter Unlock()\n    {\n        // Do something\n        return this;\n    }\n    \n    public ICanStart Enter()\n    {\n        // Do something\n        return this;\n    }\n    \n    public void Start()\n    {\n        // Do something\n        return this;\n    }\n}\n\n// Which then lets us do\nvar car = new Car().Unlock().Enter().Start();\n\n// But we can't do\nvar car = new Car().Unlock().Start(); // Haven't entered yet\nvar otherCar = new Car().Enter().Start(); // Haven't unlocked yet\n")),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{parentName:"p",href:"https://mitesh1612.github.io/blog/2021/08/11/how-to-design-fluent-api"},"This write up explains how tricky this can be to do by hand.")),(0,i.kt)("p",{parentName:"admonition"},"This is where SuperFluid comes in. It lets us define the grammar for your API in a YAML file and then generates the interfaces for you."),(0,i.kt)("p",{parentName:"admonition"},"All you then need to do is implement the interfaces and you're good to go."),(0,i.kt)("h1",{parentName:"admonition",id:"how-to-use"},"How to Use"),(0,i.kt)("h2",{parentName:"admonition",id:"installation"},"Installation"),(0,i.kt)("p",{parentName:"admonition"},"You can install SuperFluid from Nuget:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre"},"Install-Package SuperFluid\n")),(0,i.kt)("h2",{parentName:"admonition",id:"defining-your-grammar"},"Defining Your Grammar"),(0,i.kt)("blockquote",{parentName:"admonition"},(0,i.kt)("p",{parentName:"blockquote"},"[!WARNING]","\nYour grammar file needs to end with ",(0,i.kt)("inlineCode",{parentName:"p"},".fluid.yml")," to be picked up by SuperFluid.")),(0,i.kt)("p",{parentName:"admonition"},"Your grammar is defined in a YAML file following this data structure. "),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"record FluidApiDefinition\n{\n    public required string Name { get; init; }\n    public required string Namespace { get; init; }\n    public required FluidApiMethodDefinition InitialState { get; init; }\n    public required List<FluidApiMethodDefinition> Methods { get; init; }\n}\n\nrecord FluidApiMethodDefinition\n{\n    public required string Name { get; init; }\n    public string? ReturnType { get; init; }\n    public List<string> CanTransitionTo { get; init; };\n    public List<FluidApiArgumentDefinition> Arguments { get; init; };\n    public List<FluidGenericArgumentDefinition> GenericArguments { get; init; };\n}\n\nrecord FluidApiArgumentDefinition\n{\n    public required string Type { get; init; }\n    public required string Name { get; init; }\n    public string? DefaultValue { get; init; }\n}\n\nrecord FluidGenericArgumentDefinition\n{\n    public required List<string> Constraints { get; init; }\n    public required string Name { get; init; }\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"Essentially, you do the following:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Define the initial state of your API, the namespaces you want your interfaces to be in, and what you want the main interface to be called."),(0,i.kt)("li",{parentName:"ul"},"Define each of the methods that you want to be able to call on your API."),(0,i.kt)("li",{parentName:"ul"},"Define the arguments that each method takes."),(0,i.kt)("li",{parentName:"ul"},"Define the return type of each method."),(0,i.kt)("li",{parentName:"ul"},"Define the states that each method can transition to.")),(0,i.kt)("p",{parentName:"admonition"},"Then Roslyn will generate the interfaces for you."),(0,i.kt)("p",{parentName:"admonition"},"A simple example of this would be:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'Name: "ICarActor"\nNamespace: "SuperFluid.Tests.Cars"\nInitialState:\n  Name: "Initialize"\n  CanTransitionTo: \n    - "Unlock"\nMethods:\n  - Name: "Unlock"\n    CanTransitionTo:\n      - "Lock"\n      - "Enter"\n  - Name: "Lock"\n    CanTransitionTo:\n      - "Unlock"\n  - Name: "Enter"\n    CanTransitionTo:\n      - "Start"\n      - "Exit"\n  - Name: "Exit"\n    CanTransitionTo:\n      - "Lock"\n      - "Enter"\n  - Name: "Start"\n    Arguments:\n      # These are deliberately out of order to test that the parser sticks the defaults to the end of the argument list\n      - Name: "direction"\n        Type: "string"\n        DefaultValue: "\\"Forward\\"" # Note that we need the quotes here\n      - Name: "speed"\n        Type: "int"\n      - Name: "hotwire"\n        Type: "bool"\n        DefaultValue: "false"\n\n    # These constraints are pointless but are here to test the parser\n    GenericArguments:\n      - Name: "T"\n        Constraints:\n          - "class"\n          - "INumber"\n      - Name: "X"\n        Constraints:\n          - "notnull"\n      \n    CanTransitionTo:\n      - "Stop"\n      - "Build"\n  - Name: "Stop"\n    CanTransitionTo:\n      - "Start"\n      - "Exit"\n  - Name: "Build"\n    Arguments:\n      - Name: "color"\n        Type: "string"\n    CanTransitionTo: []\n    ReturnType: "string"\n')),(0,i.kt)("p",{parentName:"admonition"},"Unfortunately, Roslyn isn't great at giving you feedback for source generation errors. In Rider, you can find them under ",(0,i.kt)("inlineCode",{parentName:"p"},"Problems > Toolset, Environment")," if it's actually run."),(0,i.kt)("p",{parentName:"admonition"},"I plan to add an analyzer to the project that can give actual feedback to you but this might take a while."),(0,i.kt)("h2",{parentName:"admonition",id:"registering-your-grammar-file-with-superfluid"},"Registering Your Grammar File with SuperFluid"),(0,i.kt)("p",{parentName:"admonition"},"You need to add your grammar file(s) as ",(0,i.kt)("inlineCode",{parentName:"p"},"AdditionalFiles")," in your csproj file."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-xml"},'    <ItemGroup>\n      <AdditionalFiles Include="myGrammarFile.fluid.yml" />\n    </ItemGroup>\n')),(0,i.kt)("p",{parentName:"admonition"},"You can have as many files as you want and they don't have to be in the root of your project."),(0,i.kt)("h2",{parentName:"admonition",id:"implementing-your-api"},"Implementing Your API"),(0,i.kt)("p",{parentName:"admonition"},"Actually implementing the API is pretty simple. You just implement the root interface that has been generated. In the above example, that would be ",(0,i.kt)("inlineCode",{parentName:"p"},"ICarActor"),"."),(0,i.kt)("p",{parentName:"admonition"},"You then just implement the methods on that interface, and you're good to go."),(0,i.kt)("p",{parentName:"admonition"},"One note, if you use your IDE's feature to generate your method stubs, you might end up with multiple declarations of each method for each explicit interface that has it as a component. In this case, just delete the explicit implementations and implement the method once using the standard ",(0,i.kt)("inlineCode",{parentName:"p"},"public type name(args)")," syntax. This is simply an artefact of the fact that you can arrive at the same method through multiple transitions."),(0,i.kt)("h1",{parentName:"admonition",id:"reference-project"},"Reference Project"),(0,i.kt)("p",{parentName:"admonition"},"Another one of my projects ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hughesjs/PgfPlotsSdk"},"PgfPlotsSdk")," uses SuperFluid to generate a complicated fluent API for working with LaTex PgfPlots."),(0,i.kt)("p",{parentName:"admonition"},"The yaml file for this is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hughesjs/PgfPlotsSdk/blob/master/src/PgfPlotsSdk/SuperFluidDefinitions/PgfPlotsBuilder.fluid.yml"},"here"),"."),(0,i.kt)("p",{parentName:"admonition"},"The relevant class is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/hughesjs/PgfPlotsSdk/blob/master/src/PgfPlotsSdk/Public/Builders/PgfPlotBuilder.cs"},"here"),".")),(0,i.kt)("h3",{id:"about"},"About"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Generate a state machine from a yaml file")),(0,i.kt)("h2",{id:"how-to-use-1"},"How to use"),(0,i.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,i.kt)("p",null,"This is the CSharp Project that references ",(0,i.kt)("strong",{parentName:"p"},"SuperFluid")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {14}",showLineNumbers:!0,"{14}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n    <PropertyGroup>\n        <TargetFramework>net8.0</TargetFramework>\n        <OutputType>Exe</OutputType>\n        <Nullable>enable</Nullable>\n        <ImplicitUsings>enable</ImplicitUsings>\n    </PropertyGroup>\n\n    <ItemGroup>\n        <AdditionalFiles Include="Calculator.fluid.yml" />\n    </ItemGroup>\n\n    <ItemGroup>\n      <PackageReference Include="SuperFluid" Version="1.0.1" OutputItemType="Analyzer" ReferenceOutputAssembly="true" >\n        <PrivateAssets>all</PrivateAssets>\n        <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n      </PackageReference>\n    </ItemGroup>\n    <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n</Project>\n\n'))),(0,i.kt)(l.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\SuperFluid\\src\\StateMachineExample\\Calculator.fluid.yml",label:"Calculator.fluid.yml",mdxType:"TabItem"},(0,i.kt)("p",null,"  This is the use of ",(0,i.kt)("strong",{parentName:"p"},"SuperFluid")," in ",(0,i.kt)("em",{parentName:"p"},"Calculator.fluid.yml")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'Name: "ICalculator"\nNamespace: "SimpleFluentExample"\nInitialState:\n  Name: "Create"\n  CanTransitionTo: \n    - "Add"\n    - "Subtract"\nMethods:\n  - Name: "Add"\n    Arguments:\n      - Name: "value"\n        Type: "int"\n    CanTransitionTo:\n      - "Add"\n      - "Subtract"\n      - "Calculate"\n  - Name: "Subtract"\n    Arguments:\n      - Name: "value"\n        Type: "int"\n    CanTransitionTo:\n      - "Add"\n      - "Subtract"\n      - "Calculate"\n  - Name: "Calculate"\n    ReturnType: "int"\n    CanTransitionTo: []\n\n'))),(0,i.kt)(l.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\SuperFluid\\src\\StateMachineExample\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,i.kt)("p",null,"  This is the use of ",(0,i.kt)("strong",{parentName:"p"},"SuperFluid")," in ",(0,i.kt)("em",{parentName:"p"},"Program.cs")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'using SimpleFluentExample;\n\nConsole.WriteLine("Example Basic calculation state machine");\nvar result1 = CalculatorService.Create()\n    .Add(10)\n    .Subtract(3)\n    .Add(5)\n    .Calculate();\n\nConsole.WriteLine($"Result 1: {result1}"); // Output: 12\nConsole.WriteLine();\n\n// Uncomment these lines to see compilation errors:\n// CalculatorService.Create().Calculate();        // Can\'t calculate without operations  \n// CalculatorService.Create().Add(5).Add(10);     // Missing Calculate() at the end\n\n'))),(0,i.kt)(l.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\SuperFluid\\src\\StateMachineExample\\CalculatorService.cs",label:"CalculatorService.cs",mdxType:"TabItem"},(0,i.kt)("p",null,"  This is the use of ",(0,i.kt)("strong",{parentName:"p"},"SuperFluid")," in ",(0,i.kt)("em",{parentName:"p"},"CalculatorService.cs")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'namespace SimpleFluentExample;\n\npublic class CalculatorService : ICalculator\n{\n    private int _currentValue = 0;\n\n    // Static factory method as required by the generated interface\n    public static ICanAddOrSubtract Create()\n    {\n        var calculator = new CalculatorService();\n        Console.WriteLine("\ud83e\uddee Calculator created");\n        return calculator;\n    }\n\n    public ICanAddOrSubtractOrCalculate Add(int value)\n    {\n        _currentValue += value;\n        Console.WriteLine($"\u2795 Added {value}, current value: {_currentValue}");\n        return this;\n    }\n\n    public ICanAddOrSubtractOrCalculate Subtract(int value)\n    {\n        _currentValue -= value;\n        Console.WriteLine($"\u2796 Subtracted {value}, current value: {_currentValue}");\n        return this;\n    }\n\n    public int Calculate()\n    {\n        Console.WriteLine($"\ud83c\udfaf Final result: {_currentValue}");\n        return _currentValue;\n    }\n}\n\n')))),(0,i.kt)("h3",{id:"generated-files"},"Generated Files"),(0,i.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\SuperFluid\\src\\StateMachineExample\\obj\\GX\\SuperFluid\\SuperFluid.Internal.SourceGenerators.FluidApiSourceGenerator\\ICalculator.fluid.g.cs",label:"ICalculator.fluid.g.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"namespace SimpleFluentExample;\n\npublic interface ICalculator: ICanAddOrSubtractOrCalculate,ICanAddOrSubtract\n{\n    public static abstract ICanAddOrSubtract Create();\n}\n"))),(0,i.kt)(l.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\SuperFluid\\src\\StateMachineExample\\obj\\GX\\SuperFluid\\SuperFluid.Internal.SourceGenerators.FluidApiSourceGenerator\\ICanAddOrSubtract.fluid.g.cs",label:"ICanAddOrSubtract.fluid.g.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"namespace SimpleFluentExample;\n\npublic interface ICanAddOrSubtract\n{\n    public ICanAddOrSubtractOrCalculate Add(int value);\n    public ICanAddOrSubtractOrCalculate Subtract(int value);\n}\n"))),(0,i.kt)(l.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\SuperFluid\\src\\StateMachineExample\\obj\\GX\\SuperFluid\\SuperFluid.Internal.SourceGenerators.FluidApiSourceGenerator\\ICanAddOrSubtractOrCalculate.fluid.g.cs",label:"ICanAddOrSubtractOrCalculate.fluid.g.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"namespace SimpleFluentExample;\n\npublic interface ICanAddOrSubtractOrCalculate\n{\n    public ICanAddOrSubtractOrCalculate Add(int value);\n    public ICanAddOrSubtractOrCalculate Subtract(int value);\n    public int Calculate();\n}\n")))),(0,i.kt)("h2",{id:"useful"},"Useful"),(0,i.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{target:"_blank",href:a(60567).Z},"Download Example project SuperFluid "))),(0,i.kt)("h3",{id:"share-superfluid"},"Share SuperFluid"),(0,i.kt)("ul",null,(0,i.kt)("li",null,(0,i.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FSuperFluid&quote=SuperFluid",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,i.kt)("li",null,(0,i.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FSuperFluid&text=SuperFluid:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FSuperFluid",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,i.kt)("li",null,(0,i.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FSuperFluid&title=SuperFluid",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,i.kt)("li",null,(0,i.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FSuperFluid&title=SuperFluid&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FSuperFluid",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/SuperFluid"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/SuperFluid")),(0,i.kt)("h3",{id:"in-the-same-category-statemachine---0-other-generators"},"In the same category (StateMachine) - 0 other generators"))}g.isMDXComponent=!0},60567:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/files/SuperFluid-e7035ab949294269015eabfab2cf2782.zip"}}]);