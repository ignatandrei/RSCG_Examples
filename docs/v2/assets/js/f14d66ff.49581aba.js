"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[4642],{83448:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>g,frontMatter:()=>m,metadata:()=>p,toc:()=>u});var a=t(87462),i=(t(67294),t(3905)),o=t(73992),r=t(18679),l=t(68839);const m={sidebar_position:1080,title:"108 - CommandLine",description:"Generating easy command line applications.",slug:"/CommandLine"},s="CommandLine  by DotMake",p={unversionedId:"RSCG-Examples/CommandLine",id:"RSCG-Examples/CommandLine",title:"108 - CommandLine",description:"Generating easy command line applications.",source:"@site/docs/RSCG-Examples/CommandLine.md",sourceDirName:"RSCG-Examples",slug:"/CommandLine",permalink:"/RSCG_Examples/v2/docs/CommandLine",draft:!1,tags:[],version:"current",sidebarPosition:1080,frontMatter:{sidebar_position:1080,title:"108 - CommandLine",description:"Generating easy command line applications.",slug:"/CommandLine"},sidebar:"tutorialSidebar",previous:{title:"107 - NetAutomaticInterface",permalink:"/RSCG_Examples/v2/docs/NetAutomaticInterface"},next:{title:"109 - FunicularSwitch",permalink:"/RSCG_Examples/v2/docs/FunicularSwitch"}},d={},u=[{value:"Nuget / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share CommandLine",id:"share-commandline",level:3},{value:"In the same category (EnhancementProject) - 18 other generators",id:"in-the-same-category-enhancementproject---18-other-generators",level:3},{value:"AutoInvoke.Generator",id:"autoinvokegenerator",level:4},{value:"AutoSpectre",id:"autospectre",level:4},{value:"BuildInfo",id:"buildinfo",level:4},{value:"Com",id:"com",level:4},{value:"Credfeto.Version.Information.Generator",id:"credfetoversioninformationgenerator",level:4},{value:"Larcanum.GitInfo",id:"larcanumgitinfo",level:4},{value:"LinqGen.Generator",id:"linqgengenerator",level:4},{value:"Pekspro.BuildInformationGenerator",id:"peksprobuildinformationgenerator",level:4},{value:"PlantUmlClassDiagramGenerator",id:"plantumlclassdiagramgenerator",level:4},{value:"RSCG_AMS",id:"rscg_ams",level:4},{value:"RSCG_ExportDiagram",id:"rscg_exportdiagram",level:4},{value:"RSCG_FunctionsWithDI",id:"rscg_functionswithdi",level:4},{value:"RSCG_NameGenerator",id:"rscg_namegenerator",level:4},{value:"RSCG_TimeBombComment",id:"rscg_timebombcomment",level:4},{value:"RSCG_Wait",id:"rscg_wait",level:4},{value:"ThisAssembly",id:"thisassembly",level:4},{value:"ThisAssembly.Constants",id:"thisassemblyconstants",level:4},{value:"ThisAssembly.Metadata",id:"thisassemblymetadata",level:4}],c={toc:u},C="wrapper";function g(e){let{components:n,...m}=e;return(0,i.kt)(C,(0,a.Z)({},c,m,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"commandline--by-dotmake"},"CommandLine  by DotMake"),(0,i.kt)(l.Z,{toc:u,mdxType:"TOCInline"}),(0,i.kt)("h2",{id:"nuget--site-data"},"Nuget / site data"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/DotMake.CommandLine/"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/DotMake.CommandLine?label=DotMake.CommandLine",alt:"Nuget"})),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dotmake-build/command-line"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/dotmake-build/command-line?label=updated",alt:"GitHub last commit"})),"\n",(0,i.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/dotmake-build/command-line?style=social",alt:"GitHub Repo stars"})),(0,i.kt)("h2",{id:"details"},"Details"),(0,i.kt)("h3",{id:"info"},"Info"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Name: ",(0,i.kt)("strong",{parentName:"p"},"CommandLine")),(0,i.kt)("p",{parentName:"admonition"},"Declarative syntax for System.CommandLine via attributes for easy, fast, strongly-typed (no reflection) usage. Includes a source generator which automagically converts your classes to CLI commands and properties to CLI options or CLI arguments."),(0,i.kt)("p",{parentName:"admonition"},"Author: DotMake"),(0,i.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/DotMake.CommandLine/"},"https://www.nuget.org/packages/DotMake.CommandLine/")),"   "),(0,i.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dotmake-build/command-line"},"https://github.com/dotmake-build/command-line")),(0,i.kt)("p",{parentName:"admonition"},"Source : ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dotmake-build/command-line"},"https://github.com/dotmake-build/command-line"))),(0,i.kt)("h3",{id:"original-readme"},"Original Readme"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/dotmake-build/command-line/master/images/logo-wide.png",alt:"DotMake Command-Line Logo",title:"DotMake Command-Line Logo"})),(0,i.kt)("h1",{parentName:"admonition",id:"dotmake-command-line"},"DotMake Command-Line"),(0,i.kt)("p",{parentName:"admonition"},"System.CommandLine is a very good parser but you need a lot of boilerplate code to get going and the API is hard to discover.\nThis becomes complicated to newcomers and also you would have a lot of ugly code in your ",(0,i.kt)("inlineCode",{parentName:"p"},"Program.cs")," to maintain.\nWhat if you had an easy class-based layer combined with a good parser?"),(0,i.kt)("p",{parentName:"admonition"},"DotMake.CommandLine is a library which provides declarative syntax for\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dotnet/command-line-api"},"System.CommandLine"),"\nvia attributes for easy, fast, strongly-typed (no reflection) usage. The library includes includes a source generator\nwhich automagically converts your classes to CLI commands and properties to CLI options or CLI arguments.\nSupports\n",(0,i.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained"},"trimming"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot"},"AOT compilation")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection"},"dependency injection"),"!"),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/DotMake.CommandLine"},(0,i.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/v/DotMake.CommandLine?style=for-the-badge&logo=nuget",alt:"Nuget"}))),(0,i.kt)("h2",{parentName:"admonition",id:"getting-started"},"Getting started"),(0,i.kt)("p",{parentName:"admonition"},"Install the library to your console app project with  ",(0,i.kt)("a",{parentName:"p",href:"https://www.nuget.org/"},"NuGet"),"."),(0,i.kt)("p",{parentName:"admonition"},"In your project directory, via dotnet cli:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"dotnet add package DotMake.CommandLine\n")),(0,i.kt)("p",{parentName:"admonition"},"or in Visual Studio Package Manager Console:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"PM> Install-Package DotMake.CommandLine\n")),(0,i.kt)("h3",{parentName:"admonition",id:"prerequisites"},"Prerequisites"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},".NET 7.0 and later project or .NET Standard 2.0 and later project.",(0,i.kt)("br",{parentName:"li"}),"Note that .NET Framework 4.7.2+ or .NET Core 2.0 to NET 6.0 projects can reference our netstandard2.0 target (automatic in nuget).",(0,i.kt)("br",{parentName:"li"}),"If your target framework is below net5.0, you also need ",(0,i.kt)("inlineCode",{parentName:"li"},"<LangVersion>9.0</LangVersion>")," tag (minimum) in your .csproj file."),(0,i.kt)("li",{parentName:"ul"},"Visual Studio 2022 v17.3+ or .NET SDK 6.0.407+ (when building via ",(0,i.kt)("inlineCode",{parentName:"li"},"dotnet")," cli).",(0,i.kt)("br",{parentName:"li"}),"Our incremental source generator requires performance features added first in these versions."),(0,i.kt)("li",{parentName:"ul"},"Usually a console app project but you can also use a class library project which will be consumed later.  ")),(0,i.kt)("h2",{parentName:"admonition",id:"usage"},"Usage"),(0,i.kt)("h3",{parentName:"admonition",id:"delegate-based-model"},"Delegate-based model"),(0,i.kt)("p",{parentName:"admonition"},"Create a CLI App with DotMake.Commandline in seconds!"),(0,i.kt)("p",{parentName:"admonition"},"In ",(0,i.kt)("inlineCode",{parentName:"p"},"Program.cs"),", add this simple code:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"using System;\nusing DotMake.CommandLine;\n\nCli.Run(([CliArgument]string arg1, bool opt1) =>\n{\n    Console.WriteLine($@\"Value for {nameof(arg1)} parameter is '{arg1}'\");\n    Console.WriteLine($@\"Value for {nameof(opt1)} parameter is '{opt1}'\");\n});\n")),(0,i.kt)("p",{parentName:"admonition"},"And that's it! You now have a fully working command-line app:"),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/dotmake-build/command-line/master/images/intro.gif",alt:"DotMake Command-Line Intro",title:"DotMake Command-Line Intro"})),(0,i.kt)("h4",{parentName:"admonition",id:"summary"},"Summary"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Pass a delegate (a parenthesized lambda expression or a method reference) which has parameters that represent your options and arguments, to ",(0,i.kt)("inlineCode",{parentName:"li"},"Cli.Run"),"."),(0,i.kt)("li",{parentName:"ul"},"A parameter is by default considered as a CLI option but you can;",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Mark a parameter with ",(0,i.kt)("inlineCode",{parentName:"li"},"CliArgument")," attribute to make it a CLI argument and specify settings (see ",(0,i.kt)("a",{parentName:"li",href:"https://dotmake.build/api/html/T_DotMake_CommandLine_CliArgumentAttribute.htm"},"CliArgumentAttribute")," docs for more info)."),(0,i.kt)("li",{parentName:"ul"},"Mark a parameter with ",(0,i.kt)("inlineCode",{parentName:"li"},"CliOption")," attribute to specify CLI option settings (see ",(0,i.kt)("a",{parentName:"li",href:"https://dotmake.build/api/html/T_DotMake_CommandLine_CliOptionAttribute.htm"},"CliOptionAttribute")," docs for more info)."),(0,i.kt)("li",{parentName:"ul"},"Mark the delegate itself with ",(0,i.kt)("inlineCode",{parentName:"li"},"CliCommand")," attribute to specify CLI command settings (see ",(0,i.kt)("a",{parentName:"li",href:"https://dotmake.build/api/html/T_DotMake_CommandLine_CliCommandAttribute.htm"},"CliCommandAttribute")," docs for more info)."),(0,i.kt)("li",{parentName:"ul"},"Note that for being able to mark a parameter with an attribute in an anonymous lambda function,\nif your target framework is below net6.0, you also need ",(0,i.kt)("inlineCode",{parentName:"li"},"<LangVersion>10.0</LangVersion>")," tag (minimum) in your .csproj file."))),(0,i.kt)("li",{parentName:"ul"},"Set a default value for a parameter if you want it to be optional (not required to be specified on the command-line)."),(0,i.kt)("li",{parentName:"ul"},"Your delegate can be ",(0,i.kt)("inlineCode",{parentName:"li"},"async"),"."),(0,i.kt)("li",{parentName:"ul"},"Your delegate can have a return type ",(0,i.kt)("inlineCode",{parentName:"li"},"void")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"int")," and if it's async ",(0,i.kt)("inlineCode",{parentName:"li"},"Task")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"Task<int>"),".")),(0,i.kt)("h3",{parentName:"admonition",id:"class-based-model"},"Class-based model"),(0,i.kt)("p",{parentName:"admonition"},"While delegate-based model above is useful for simple apps, for more complex apps, you should use the class-based model\nbecause you can have sub-commands and command inheritance."),(0,i.kt)("p",{parentName:"admonition"},"In ",(0,i.kt)("inlineCode",{parentName:"p"},"Program.cs"),", add this simple code:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'using System;\nusing DotMake.CommandLine;\n\n// Add this single line to run you app!\nCli.Run<RootCliCommand>(args);\n\n// Create a simple class like this to define your root command:\n[CliCommand(Description = "A root cli command")]\npublic class RootCliCommand\n{\n    [CliOption(Description = "Description for Option1")]\n    public string Option1 { get; set; } = "DefaultForOption1";\n \n    [CliArgument(Description = "Description for Argument1")]\n    public string Argument1 { get; set; }\n \n    public void Run()\n    {\n        Console.WriteLine($@"Handler for \'{GetType().FullName}\' is run:");\n        Console.WriteLine($@"Value for {nameof(Option1)} property is \'{Option1}\'");\n        Console.WriteLine($@"Value for {nameof(Argument1)} property is \'{Argument1}\'");\n        Console.WriteLine();\n    }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"And that's it! You now have a fully working command-line app. You just specify the name of your class which represents your root command to ",(0,i.kt)("inlineCode",{parentName:"p"},"Cli.Run<>")," method and everything is wired."),(0,i.kt)("blockquote",{parentName:"admonition"},(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"args")," is the string array typically passed to a program. This is usually\nthe special variable ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," available in ",(0,i.kt)("inlineCode",{parentName:"p"},"Program.cs")," (new style with top-level statements)\nor the string array passed to the program's ",(0,i.kt)("inlineCode",{parentName:"p"},"Main")," method (old style).\nWe also have method signatures which does not require ",(0,i.kt)("inlineCode",{parentName:"p"},"args"),",\nfor example you can also call ",(0,i.kt)("inlineCode",{parentName:"p"},"Cli.Run<RootCliCommand>()")," and in that case ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," will be retrieved automatically from the current process via ",(0,i.kt)("inlineCode",{parentName:"p"},"Cli.GetArgs()"),".")),(0,i.kt)("p",{parentName:"admonition"},"If you want to go async, just use this:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"await Cli.RunAsync<RootCliCommand>(args);\n")),(0,i.kt)("p",{parentName:"admonition"},"To handle exceptions, you just use a try-catch block:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'try\n{\n    Cli.Run<RootCliCommand>(args);\n}\ncatch (Exception e)\n{\n    Console.WriteLine(@"Exception in main: {0}", e.Message);\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"System.CommandLine, by default overtakes your exceptions that are thrown in command handlers\n(even if you don't set an exception handler explicitly) but DotMake.CommandLine, by default allows\nthe exceptions to pass through. However if you wish, you can easily use the default exception handler\nby passing a ",(0,i.kt)("inlineCode",{parentName:"p"},"CliSettings")," instance like below. Default exception handler prints the exception in red color to console:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"Cli.Run<RootCliCommand>(args, new CliSettings { EnableDefaultExceptionHandler = true });\n")),(0,i.kt)("p",{parentName:"admonition"},"If you need to simply parse the command-line arguments without invocation, use this:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"var parseResult = Cli.Parse<RootCliCommand>(args);\nvar rootCliCommand = parseResult.Bind<RootCliCommand>();\n")),(0,i.kt)("p",{parentName:"admonition"},"If you need to examine the parse result, such as errors:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"var parseResult = Cli.Parse<RootCliCommand>(args);\nif (parseResult.Errors.Count > 0)\n{\n\n}\n")),(0,i.kt)("h4",{parentName:"admonition",id:"summary-1"},"Summary"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Mark the class with ",(0,i.kt)("inlineCode",{parentName:"p"},"CliCommand")," attribute to make it a CLI command (see ",(0,i.kt)("a",{parentName:"p",href:"https://dotmake.build/api/html/T_DotMake_CommandLine_CliCommandAttribute.htm"},"CliCommandAttribute")," docs for more info).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Mark a property with ",(0,i.kt)("inlineCode",{parentName:"p"},"CliOption")," attribute to make it a CLI option (see ",(0,i.kt)("a",{parentName:"p",href:"https://dotmake.build/api/html/T_DotMake_CommandLine_CliOptionAttribute.htm"},"CliOptionAttribute")," docs for more info).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Mark a property with ",(0,i.kt)("inlineCode",{parentName:"p"},"CliArgument")," attribute to make it a CLI argument (see ",(0,i.kt)("a",{parentName:"p",href:"https://dotmake.build/api/html/T_DotMake_CommandLine_CliArgumentAttribute.htm"},"CliArgumentAttribute")," docs for more info).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Add a method with name ",(0,i.kt)("inlineCode",{parentName:"p"},"Run")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"RunAsync")," to make it the handler for the CLI command. The method can have one of the following signatures: "),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"void Run()\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"int Run()\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"async Task RunAsync()\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"async Task<int> RunAsync()\n")),(0,i.kt)("p",{parentName:"li"},"Optionally the method signature can have a ",(0,i.kt)("inlineCode",{parentName:"p"},"CliContext")," parameter in case you need to access it:")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"Run(CliContext context)\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"RunAsync(CliContext context)\n")))),(0,i.kt)("p",{parentName:"li"},"The signatures which return int value, sets the ExitCode of the app.\nIf no handler method is provided, then by default it will show help for the command.\nThis can be also controlled manually by extension method ",(0,i.kt)("inlineCode",{parentName:"p"},"ShowHelp")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"CliContext"),".\nOther extension methods ",(0,i.kt)("inlineCode",{parentName:"p"},"IsEmptyCommand")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ShowValues")," are also useful.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Call ",(0,i.kt)("inlineCode",{parentName:"p"},"Cli.Run<>")," or",(0,i.kt)("inlineCode",{parentName:"p"},"Cli.RunAsync<>")," method with your class name to run your CLI app (see ",(0,i.kt)("a",{parentName:"p",href:"https://dotmake.build/api/html/T_DotMake_CommandLine_Cli.htm"},"Cli")," docs for more info).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For best practice, create a subfolder named ",(0,i.kt)("inlineCode",{parentName:"p"},"Commands")," in your project and put your command classes there\nso that they are easy to locate and maintain in the future."))),(0,i.kt)("h2",{parentName:"admonition",id:"commands"},"Commands"),(0,i.kt)("p",{parentName:"admonition"},"A ",(0,i.kt)("em",{parentName:"p"},"command")," in command-line input is a token that specifies an action or defines a group of related actions. For example:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"In ",(0,i.kt)("inlineCode",{parentName:"li"},"dotnet run"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"run")," is a command that specifies an action."),(0,i.kt)("li",{parentName:"ul"},"In ",(0,i.kt)("inlineCode",{parentName:"li"},"dotnet tool install"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"install")," is a command that specifies an action, and ",(0,i.kt)("inlineCode",{parentName:"li"},"tool")," is a command that specifies a group of related commands. There are other tool-related commands, such as ",(0,i.kt)("inlineCode",{parentName:"li"},"tool uninstall"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"tool list"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"tool update"),".")),(0,i.kt)("h3",{parentName:"admonition",id:"root-commands"},"Root commands"),(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("em",{parentName:"p"},"root command")," is the one that specifies the name of the app's executable. For example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"dotnet")," command specifies the ",(0,i.kt)("em",{parentName:"p"},"dotnet.exe")," executable."),(0,i.kt)("h3",{parentName:"admonition",id:"subcommands"},"Subcommands"),(0,i.kt)("p",{parentName:"admonition"},"Most command-line apps support ",(0,i.kt)("em",{parentName:"p"},"subcommands"),", also known as ",(0,i.kt)("em",{parentName:"p"},"verbs"),". For example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"dotnet")," command has a ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," subcommand that you invoke by entering ",(0,i.kt)("inlineCode",{parentName:"p"},"dotnet run"),"."),(0,i.kt)("p",{parentName:"admonition"},"Subcommands can have their own subcommands. In ",(0,i.kt)("inlineCode",{parentName:"p"},"dotnet tool install"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"install")," is a subcommand of ",(0,i.kt)("inlineCode",{parentName:"p"},"tool"),"."),(0,i.kt)("h3",{parentName:"admonition",id:"command-hierarchy"},"Command Hierarchy"),(0,i.kt)("p",{parentName:"admonition"},"Defining sub-commands in DotMake.Commandline is very easy. We simply use nested classes to create a hierarchy.\nJust make sure you apply ",(0,i.kt)("inlineCode",{parentName:"p"},"CliCommand")," attribute to the nested classes as well.\nCommand hierarchy in below example is:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"RootWithNestedChildrenCliCommand")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"Level1SubCliCommand")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"Level2SubCliCommand")),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'[CliCommand(Description = "A root cli command with nested children")]\npublic class RootWithNestedChildrenCliCommand\n{\n    [CliOption(Description = "Description for Option1")]\n    public string Option1 { get; set; } = "DefaultForOption1";\n\n    [CliArgument(Description = "Description for Argument1")]\n    public string Argument1 { get; set; }\n\n    public void Run(CliContext context)\n    {\n        context.ShowValues();\n    }\n\n    [CliCommand(Description = "A nested level 1 sub-command")]\n    public class Level1SubCliCommand\n    {\n        [CliOption(Description = "Description for Option1")]\n        public string Option1 { get; set; } = "DefaultForOption1";\n\n        [CliArgument(Description = "Description for Argument1")]\n        public string Argument1 { get; set; }\n\n        public void Run(CliContext context)\n        {\n            context.ShowValues();\n        }\n\n        [CliCommand(Description = "A nested level 2 sub-command")]\n        public class Level2SubCliCommand\n        {\n            [CliOption(Description = "Description for Option1")]\n            public string Option1 { get; set; } = "DefaultForOption1";\n\n            [CliArgument(Description = "Description for Argument1")]\n            public string Argument1 { get; set; }\n\n            public void Run(CliContext context)\n            {\n                context.ShowValues();\n            }\n        }\n    }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"Another way to create hierarchy between commands, especially if you want to use standalone classes,",(0,i.kt)("br",{parentName:"p"}),"\n","is to use ",(0,i.kt)("inlineCode",{parentName:"p"},"Parent")," property of ",(0,i.kt)("inlineCode",{parentName:"p"},"CliCommand")," attribute to specify ",(0,i.kt)("inlineCode",{parentName:"p"},"typeof")," parent class.\nConsider you have this root command:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'[CliCommand(Description = "A root cli command with external children and one nested child and testing settings inheritance")]\npublic class RootWithExternalChildrenCliCommand\n{\n    [CliOption(Description = "Description for Option1")]\n    public string Option1 { get; set; } = "DefaultForOption1";\n\n    [CliArgument(Description = "Description for Argument1")]\n    public string Argument1 { get; set; }\n\n    public void Run(CliContext context)\n    {\n        context.ShowValues();\n    }\n\n    [CliCommand(\n        Description = "A nested level 1 sub-command with custom settings, throws test exception",\n        NameCasingConvention = CliNameCasingConvention.SnakeCase,\n        NamePrefixConvention = CliNamePrefixConvention.ForwardSlash,\n        ShortFormPrefixConvention = CliNamePrefixConvention.ForwardSlash\n    )]\n    public class Level1SubCliCommand\n    {\n        [CliOption(Description = "Description for Option1")]\n        public string Option1 { get; set; } = "DefaultForOption1";\n\n        [CliArgument(Description = "Description for Argument1")]\n        public string Argument1 { get; set; }\n\n        public void Run()\n        {\n            throw new Exception("This is a test exception from Level1SubCliCommand");\n        }\n    }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"Command hierarchy in below example is:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"RootWithExternalChildrenCliCommand")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalLevel1SubCliCommand")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"Level2SubCliCommand")),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'[CliCommand(\n    Description = "An external level 1 sub-command",\n    Parent = typeof(RootWithExternalChildrenCliCommand)\n)]\npublic class ExternalLevel1SubCliCommand\n{\n    [CliOption(Description = "Description for Option1")]\n    public string Option1 { get; set; } = "DefaultForOption1";\n\n    [CliArgument(Description = "Description for Argument1")]\n    public string Argument1 { get; set; }\n\n    public void Run(CliContext context)\n    {\n        context.ShowValues();\n    }\n\n    [CliCommand(Description = "A nested level 2 sub-command")]\n    public class Level2SubCliCommand\n    {\n        [CliOption(Description = "Description for Option1")]\n        public string Option1 { get; set; } = "DefaultForOption1";\n\n        [CliArgument(Description = "Description for Argument1")]\n        public string Argument1 { get; set; }\n\n        public void Run(CliContext context)\n        {\n            context.ShowValues();\n        }\n    }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"Command hierarchy in below example is:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"RootWithExternalChildrenCliCommand")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"Level1SubCliCommand")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalLevel2SubCliCommand")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"Level3SubCliCommand")),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'[CliCommand(\n    Description = "An external level 2 sub-command",\n    Parent = typeof(RootWithExternalChildrenCliCommand.Level1SubCliCommand),\n    NameCasingConvention = CliNameCasingConvention.SnakeCase,\n    NamePrefixConvention = CliNamePrefixConvention.ForwardSlash,\n    ShortFormPrefixConvention = CliNamePrefixConvention.ForwardSlash\n)]\npublic class ExternalLevel2SubCliCommand\n{\n    [CliOption(Description = "Description for Option1")]\n    public string Option1 { get; set; } = "DefaultForOption1";\n\n    [CliArgument(Description = "Description for Argument1")]\n    public string Argument1 { get; set; }\n\n    public void Run(CliContext context)\n    {\n        context.ShowValues();\n    }\n\n    [CliCommand(Description = "A nested level 3 sub-command")]\n    public class Level3SubCliCommand\n    {\n        [CliOption(Description = "Description for Option1")]\n        public string Option1 { get; set; } = "DefaultForOption1";\n\n        [CliArgument(Description = "Description for Argument1")]\n        public string Argument1 { get; set; }\n\n        public void Run(CliContext context)\n        {\n            context.ShowValues();\n        }\n    }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"The class that ",(0,i.kt)("inlineCode",{parentName:"p"},"CliCommand")," attribute is applied to,"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"will be a root command if the class is not a nested class and ",(0,i.kt)("inlineCode",{parentName:"li"},"Parent"),"property is not set."),(0,i.kt)("li",{parentName:"ul"},"will be a sub command if the class is a nested class or ",(0,i.kt)("inlineCode",{parentName:"li"},"Parent")," property is set.")),(0,i.kt)("h3",{parentName:"admonition",id:"command-inheritance"},"Command Inheritance"),(0,i.kt)("p",{parentName:"admonition"},"When you have repeating/common options and arguments for your commands, you can define them once in a base class and then\nshare them by inheriting that base class in other command classes. Interfaces are also supported !"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'[CliCommand]\npublic class InheritanceCliCommand : CredentialCommandBase, IDepartmentCommand\n{\n    public string Department { get; set; } = "Accounting";\n}\n\npublic abstract class CredentialCommandBase\n{\n    [CliOption(Description = "Username of the identity performing the command")]\n    public string Username { get; set; } = "admin";\n\n    [CliOption(Description = "Password of the identity performing the command")]\n    public string Password { get; set; }\n\n    public void Run()\n    {\n        Console.WriteLine($@"I am {Username}");\n    }\n}\n\npublic interface IDepartmentCommand\n{\n    [CliOption(Description = "Department of the identity performing the command (interface)")]\n    string Department { get; set; }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"The property attribute and the property initializer from the most derived class in the hierarchy will be used\n(they will override the base ones). The command handler (Run or RunAsync) will be also inherited.\nSo in the above example, ",(0,i.kt)("inlineCode",{parentName:"p"},"InheritanceCliCommand")," inherits options ",(0,i.kt)("inlineCode",{parentName:"p"},"Username"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Password")," from a base class and\noption ",(0,i.kt)("inlineCode",{parentName:"p"},"Department")," from an interface. Note that the property initializer for ",(0,i.kt)("inlineCode",{parentName:"p"},"Department")," is in the derived class,\nso that default value will be used."),(0,i.kt)("hr",{parentName:"admonition"}),(0,i.kt)("p",{parentName:"admonition"},"The properties for ",(0,i.kt)("inlineCode",{parentName:"p"},"CliCommand")," attribute (see ",(0,i.kt)("a",{parentName:"p",href:"https://dotmake.build/api/html/T_DotMake_CommandLine_CliCommandAttribute.htm"},"CliCommandAttribute")," docs for more info):"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Name"),(0,i.kt)("li",{parentName:"ul"},"Description"),(0,i.kt)("li",{parentName:"ul"},"Aliases"),(0,i.kt)("li",{parentName:"ul"},"Hidden"),(0,i.kt)("li",{parentName:"ul"},"Parent"),(0,i.kt)("li",{parentName:"ul"},"TreatUnmatchedTokensAsErrors"),(0,i.kt)("li",{parentName:"ul"},"NameCasingConvention ",(0,i.kt)("em",{parentName:"li"},"(inherited by child options, child arguments and subcommands)")),(0,i.kt)("li",{parentName:"ul"},"NamePrefixConvention ",(0,i.kt)("em",{parentName:"li"},"(inherited by child options and subcommands)")),(0,i.kt)("li",{parentName:"ul"},"ShortFormPrefixConvention ",(0,i.kt)("em",{parentName:"li"},"(inherited by child options and subcommands)")),(0,i.kt)("li",{parentName:"ul"},"ShortFormAutoGenerate ",(0,i.kt)("em",{parentName:"li"},"(inherited by child options and subcommands)"))),(0,i.kt)("h2",{parentName:"admonition",id:"options"},"Options"),(0,i.kt)("p",{parentName:"admonition"},"An option is a named parameter that can be passed to a command. ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/POSIX"},"POSIX")," CLIs typically prefix the option name with two hyphens (",(0,i.kt)("inlineCode",{parentName:"p"},"--"),"). The following example shows two options:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-dotnetcli"},"dotnet tool update dotnet-suggest --verbosity quiet --global\n                                  ^---------^       ^------^\n")),(0,i.kt)("p",{parentName:"admonition"},"As this example illustrates, the value of the option may be explicit (",(0,i.kt)("inlineCode",{parentName:"p"},"quiet")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"--verbosity"),") or implicit (nothing follows ",(0,i.kt)("inlineCode",{parentName:"p"},"--global"),"). Options that have no value specified are typically Boolean parameters that default to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the option is specified on the command line."),(0,i.kt)("p",{parentName:"admonition"},"For some Windows command-line apps, you identify an option by using a leading slash (",(0,i.kt)("inlineCode",{parentName:"p"},"/"),") with the option name. For example:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"msbuild /version\n        ^------^\n")),(0,i.kt)("p",{parentName:"admonition"},"Both POSIX and Windows prefix conventions are supported.\nWhen manually setting a name (overriding decorated property's name), you should specify the option name including the prefix (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"--option"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-option")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"/option"),")"),(0,i.kt)("hr",{parentName:"admonition"}),(0,i.kt)("p",{parentName:"admonition"},"The properties for ",(0,i.kt)("inlineCode",{parentName:"p"},"CliOption")," attribute (see ",(0,i.kt)("a",{parentName:"p",href:"https://dotmake.build/api/html/T_DotMake_CommandLine_CliOptionAttribute.htm"},"CliOptionAttribute")," docs for more info):"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Name"),(0,i.kt)("li",{parentName:"ul"},"Description"),(0,i.kt)("li",{parentName:"ul"},"Aliases"),(0,i.kt)("li",{parentName:"ul"},"HelpName"),(0,i.kt)("li",{parentName:"ul"},"Hidden"),(0,i.kt)("li",{parentName:"ul"},"Required"),(0,i.kt)("li",{parentName:"ul"},"Recursive"),(0,i.kt)("li",{parentName:"ul"},"Arity"),(0,i.kt)("li",{parentName:"ul"},"AllowedValues"),(0,i.kt)("li",{parentName:"ul"},"AllowMultipleArgumentsPerToken"),(0,i.kt)("li",{parentName:"ul"},"ValidationRules"),(0,i.kt)("li",{parentName:"ul"},"ValidationPattern"),(0,i.kt)("li",{parentName:"ul"},"ValidationMessage")),(0,i.kt)("h2",{parentName:"admonition",id:"arguments"},"Arguments"),(0,i.kt)("p",{parentName:"admonition"},"An argument is a value passed to an option or a command. The following examples show an argument for the ",(0,i.kt)("inlineCode",{parentName:"p"},"verbosity")," option and an argument for the ",(0,i.kt)("inlineCode",{parentName:"p"},"build")," command."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"dotnet tool update dotnet-suggest --verbosity quiet --global\n                                              ^---^\n")),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"dotnet build myapp.csproj\n             ^----------^\n")),(0,i.kt)("p",{parentName:"admonition"},"Arguments can have default values that apply if no argument is explicitly provided. For example, many options are implicitly Boolean parameters with a default of ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," when the option name is in the command line. The following command-line examples are equivalent:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-dotnetcli"},"dotnet tool update dotnet-suggest --global\n                                  ^------^\n\ndotnet tool update dotnet-suggest --global true\n                                  ^-----------^\n")),(0,i.kt)("p",{parentName:"admonition"},"Some options have required arguments. For example in the .NET CLI, ",(0,i.kt)("inlineCode",{parentName:"p"},"--output")," requires a folder name argument. If the argument is not provided, the command fails."),(0,i.kt)("p",{parentName:"admonition"},"Arguments can have expected types, and ",(0,i.kt)("inlineCode",{parentName:"p"},"System.CommandLine")," displays an error message if an argument can't be parsed into the expected type. For example, the following command errors because \"silent\" isn't one of the valid values for ",(0,i.kt)("inlineCode",{parentName:"p"},"--verbosity"),":"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-dotnetcli"},"dotnet build --verbosity silent\n")),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-output"},"Cannot parse argument 'silent' for option '-v' as expected type 'Microsoft.DotNet.Cli.VerbosityOptions'. Did you mean one of the following?\nDetailed\nDiagnostic\nMinimal\nNormal\nQuiet\n")),(0,i.kt)("hr",{parentName:"admonition"}),(0,i.kt)("p",{parentName:"admonition"},"The properties for ",(0,i.kt)("inlineCode",{parentName:"p"},"CliArgument")," attribute (see ",(0,i.kt)("a",{parentName:"p",href:"https://dotmake.build/api/html/T_DotMake_CommandLine_CliArgumentAttribute.htm"},"CliArgumentAttribute")," docs for more info):"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Name"),(0,i.kt)("li",{parentName:"ul"},"Description"),(0,i.kt)("li",{parentName:"ul"},"HelpName"),(0,i.kt)("li",{parentName:"ul"},"Hidden"),(0,i.kt)("li",{parentName:"ul"},"Required"),(0,i.kt)("li",{parentName:"ul"},"Arity"),(0,i.kt)("li",{parentName:"ul"},"AllowedValues"),(0,i.kt)("li",{parentName:"ul"},"ValidationRules"),(0,i.kt)("li",{parentName:"ul"},"ValidationPattern"),(0,i.kt)("li",{parentName:"ul"},"ValidationMessage")),(0,i.kt)("h2",{parentName:"admonition",id:"model-binding"},"Model binding"),(0,i.kt)("p",{parentName:"admonition"},"When the command handler is run, the properties for CLI options and arguments will be already populated\nand bound from values passed in the command-line. If no matching value is passed, the property will have its default value if\nit has one or an error will be displayed if it's a required option/argument and it was not specified on the command-line."),(0,i.kt)("p",{parentName:"admonition"},"An option/argument will be considered required when"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"There is no property initializer and the property type is a reference type (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"public string Arg { get; set; }"),").\n",(0,i.kt)("inlineCode",{parentName:"li"},"string")," is a reference type which has a null as the default value but ",(0,i.kt)("inlineCode",{parentName:"li"},"bool")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"enum")," are value\ntypes which already have non-null default values. ",(0,i.kt)("inlineCode",{parentName:"li"},"Nullable<T>")," is a reference type, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"bool?"),"."),(0,i.kt)("li",{parentName:"ul"},"There is a property initializer, but it's initialized with ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"null!")," (SuppressNullableWarningExpression)\n(e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"public string Arg { get; set; } = null!;"),")."),(0,i.kt)("li",{parentName:"ul"},"If it's forced via attribute property ",(0,i.kt)("inlineCode",{parentName:"li"},"Required")," (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"[CliArgument(Required = true)]"),")."),(0,i.kt)("li",{parentName:"ul"},"If it's forced via ",(0,i.kt)("inlineCode",{parentName:"li"},"required")," modifier (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"public required string Opt { get; set; }"),").\nNote that for being able to use ",(0,i.kt)("inlineCode",{parentName:"li"},"required")," modifier, if your target framework is below net7.0,\nyou also need ",(0,i.kt)("inlineCode",{parentName:"li"},"<LangVersion>11.0</LangVersion>")," tag (minimum) in your .csproj file (our source generator supplies the polyfills\nautomatically as long as you set C# language version to 11).")),(0,i.kt)("p",{parentName:"admonition"},"An option/argument will be considered optional when"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"There is no property initializer (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"public bool Opt { get; set; }"),") but the property type is a value type\nwhich already have non-null default value."),(0,i.kt)("li",{parentName:"ul"},"There is a property initializer, and it's not initialized with ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"null!")," (SuppressNullableWarningExpression)\n(e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},'public string Arg { get; set; } = "Default";'),")."),(0,i.kt)("li",{parentName:"ul"},"If it's forced via attribute property ",(0,i.kt)("inlineCode",{parentName:"li"},"Required")," (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"[CliArgument(Required = false)]"),").")),(0,i.kt)("hr",{parentName:"admonition"}),(0,i.kt)("p",{parentName:"admonition"},"When you run,"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"TestApp.exe NewValueForArgument1\n")),(0,i.kt)("p",{parentName:"admonition"},"or (note the double hyphen/dash which allows ",(0,i.kt)("inlineCode",{parentName:"p"},"dotnet run")," to pass arguments to our actual application):"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"dotnet run -- NewValueForArgument1\n")),(0,i.kt)("p",{parentName:"admonition"},"You see this result:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Handler for 'TestApp.Commands.RootCliCommand' is run:\nValue for Option1 property is 'DefaultForOption1'\nValue for Argument1 property is 'NewValueForArgument1'\n")),(0,i.kt)("hr",{parentName:"admonition"}),(0,i.kt)("h3",{parentName:"admonition",id:"supported-types"},"Supported types"),(0,i.kt)("p",{parentName:"admonition"},"Note that you can have a specific type (other than ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),") for a property which a ",(0,i.kt)("inlineCode",{parentName:"p"},"CliOption")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"CliArgument")," attribute is applied to, for example these properties will be parsed and bound/populated automatically:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"[CliCommand]\npublic class WriteFileCommand\n{\n    [CliArgument]\n    public FileInfo OutputFile { get; set; }\n\n    [CliOption]\n    public List<string> Lines { get; set; }\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"The following types for properties are supported:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Booleans (flags) - If ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," is passed for an option having a ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," argument, it is parsed and bound as expected.\nBut an option whose argument type is ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," doesn't require an argument to be specified.\nThe presence of the option token on the command line, with no argument following it, results in a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Enums - The values are bound by name, and the binding is case insensitive")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Common CLR types:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FileSystemInfo"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"FileInfo"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"DirectoryInfo")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"long"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"short"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"uint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ulong"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ushort")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"double"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"float"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"decimal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"byte"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"sbyte")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DateTime"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"DateTimeOffset"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"TimeSpan"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"DateOnly"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"TimeOnly")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Guid")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Uri"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"IPAddress"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"IPEndPoint")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Any type with a public constructor or a static ",(0,i.kt)("inlineCode",{parentName:"p"},"Parse")," method with a string parameter (other parameters, if any, should be optional) - These types can be bound/parsed\nautomatically even if they are wrapped with ",(0,i.kt)("inlineCode",{parentName:"p"},"Enumerable")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Nullable")," type."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"[CliCommand]\npublic class ArgumentConverterCliCommand\n{\n    [CliOption]\n    public ClassWithConstructor Opt { get; set; }\n\n    [CliOption(AllowMultipleArgumentsPerToken = true)]\n    public ClassWithConstructor[] OptArray { get; set; }\n\n    [CliOption]\n    public CustomStruct? OptNullable { get; set; }\n\n    [CliOption]\n    public IEnumerable<ClassWithConstructor> OptEnumerable { get; set; }\n\n    [CliOption]\n    public List<ClassWithConstructor> OptList { get; set; }\n\n    [CliOption]\n    public CustomList<ClassWithConstructor> OptCustomList { get; set; }\n\n    [CliArgument]\n    public IEnumerable<ClassWithParser> Arg { get; set; }\n}\n\npublic class ClassWithConstructor\n{\n    private readonly string value;\n\n    public ClassWithConstructor(string value)\n    {\n        this.value = value;\n    }\n\n    public override string ToString()\n    {\n        return value;\n    }\n}\n\npublic class ClassWithParser\n{\n    private string value;\n\n    public override string ToString()\n    {\n        return value;\n    }\n\n    public static ClassWithParser Parse(string value)\n    {\n        var instance = new ClassWithParser();\n        instance.value = value;\n        return instance;\n    }\n}\n\npublic struct CustomStruct\n{\n    private readonly string value;\n\n    public CustomStruct(string value)\n    {\n        this.value = value;\n    }\n\n    public override string ToString()\n    {\n        return value;\n    }\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Arrays, lists, collections:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Any type that implements ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," and has a public constructor with a ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"IList<T>")," parameter\n(other parameters, if any, should be optional). CLR collection types already satisfy this condition.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If type is generic ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"IList<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ICollection<T>")," interfaces itself, array ",(0,i.kt)("inlineCode",{parentName:"p"},"T[]")," will be used to create an instance.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If type is non-generic ",(0,i.kt)("inlineCode",{parentName:"p"},"IEnumerable"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"IList"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ICollection")," interfaces itself, array ",(0,i.kt)("inlineCode",{parentName:"p"},"string[]")," will be used to create an instance."))),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"[CliCommand]\npublic class EnumerableCliCommand\n{\n    [CliOption]\n    public IEnumerable<int> OptEnumerable { get; set; }\n\n    [CliOption]\n    public List<string> OptList { get; set; }\n\n    [CliOption(AllowMultipleArgumentsPerToken = true)]\n    public FileAccess[] OptEnumArray { get; set; }\n\n    [CliOption]\n    public Collection<string> OptCollection { get; set; }\n\n    [CliOption]\n    public HashSet<string> OptHashSet { get; set; }\n\n    [CliOption]\n    public Queue<FileInfo> OptQueue { get; set; }\n\n    [CliOption]\n    public CustomList<string> OptCustomList { get; set; }\n\n    [CliArgument]\n    public IList ArgIList { get; set; }\n}\n\npublic class CustomList<T> : List<T>\n{\n    public CustomList(IEnumerable<T> items)\n        : base(items)\n    {\n\n    }\n}\n")))),(0,i.kt)("h3",{parentName:"admonition",id:"validation"},"Validation"),(0,i.kt)("p",{parentName:"admonition"},"In ",(0,i.kt)("inlineCode",{parentName:"p"},"[CliOption]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"[CliArgument]")," attributes;\n",(0,i.kt)("inlineCode",{parentName:"p"},"ValidationRules")," property allows setting predefined validation rules such as"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliValidationRules.ExistingFile")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliValidationRules.NonExistingFile")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliValidationRules.ExistingDirectory")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliValidationRules.NonExistingDirectory")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliValidationRules.ExistingFileOrDirectory")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliValidationRules.NonExistingFileOrDirectory")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliValidationRules.LegalPath")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliValidationRules.LegalFileName")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliValidationRules.LegalUri")," "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliValidationRules.LegalUrl"))),(0,i.kt)("p",{parentName:"admonition"},"Validation rules can be combined via using bitwise 'or' operator(",(0,i.kt)("inlineCode",{parentName:"p"},"|")," in C#)."),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"ValidationPattern")," property allows setting a regular expression pattern for custom validation,\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidationMessage")," property allows setting a custom error message to show when ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidationPattern")," does not match."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'[CliCommand]\npublic class ValidationCliCommand\n{\n    [CliOption(Required = false, ValidationRules = CliValidationRules.ExistingFile)]\n    public FileInfo OptFile1 { get; set; }\n\n    [CliOption(Required = false, ValidationRules = CliValidationRules.NonExistingFile | CliValidationRules.LegalPath)]\n    public string OptFile2 { get; set; }\n\n    [CliOption(Required = false, ValidationPattern = @"(?i)^[a-z]+$")]\n    public string OptPattern1 { get; set; }\n\n    [CliOption(Required = false, ValidationPattern = @"(?i)^[a-z]+$", ValidationMessage = "Custom error message")]\n    public string OptPattern2 { get; set; }\n\n    [CliOption(Required = false, ValidationRules = CliValidationRules.LegalUrl)]\n    public string OptUrl { get; set; }\n\n    [CliOption(Required = false, ValidationRules = CliValidationRules.LegalUri)]\n    public string OptUri { get; set; }\n\n    [CliArgument(Required = false, ValidationRules = CliValidationRules.LegalFileName)]\n    public string OptFileName { get; set; }\n\n    public void Run(CliContext context)\n    {\n        context.ShowValues();\n    }\n}\n')),(0,i.kt)("h2",{parentName:"admonition",id:"dependency-injection"},"Dependency Injection"),(0,i.kt)("p",{parentName:"admonition"},"Commands can have injected dependencies, this is supported via ",(0,i.kt)("inlineCode",{parentName:"p"},"Microsoft.Extensions.DependencyInjection")," package (version >= 6.0.0).\nIn your project directory, via dotnet cli:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"dotnet add package Microsoft.Extensions.DependencyInjection\n")),(0,i.kt)("p",{parentName:"admonition"},"or in Visual Studio Package Manager Console:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"PM> Install-Package Microsoft.Extensions.DependencyInjection\n")),(0,i.kt)("p",{parentName:"admonition"},"When the source generator detects that your project has reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"Microsoft.Extensions.DependencyInjection"),",\nit will generate extension methods for supporting dependency injection.\nFor example, you can now add your services with the extension method ",(0,i.kt)("inlineCode",{parentName:"p"},"Cli.Ext.ConfigureServices"),":"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},"using DotMake.CommandLine;\nusing Microsoft.Extensions.DependencyInjection;\n\nCli.Ext.ConfigureServices(services =>\n{\n    services.AddTransient<TransientClass>();\n    services.AddScoped<ScopedClass>();\n    services.AddSingleton<SingletonClass>();\n});\n\nCli.Run<RootCliCommand>();\n")),(0,i.kt)("p",{parentName:"admonition"},"Then let them be injected to your command class automatically by providing a constructor with the required services:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'[CliCommand(Description = "A root cli command with dependency injection")]\npublic class RootCliCommand\n{\n    private readonly TransientClass transientDisposable;\n    private readonly ScopedClass scopedDisposable;\n    private readonly SingletonClass singletonDisposable;\n\n    public RootCliCommand(\n        TransientClass transientDisposable,\n        ScopedClass scopedDisposable,\n        SingletonClass singletonDisposable\n    )\n    {\n        this.transientDisposable = transientDisposable;\n        this.scopedDisposable = scopedDisposable;\n        this.singletonDisposable = singletonDisposable;\n    }\n\n    [CliOption(Description = "Description for Option1")]\n    public string Option1 { get; set; } = "DefaultForOption1";\n\n    [CliArgument(Description = "Description for Argument1")]\n    public string Argument1 { get; set; }\n\n    public void Run()\n    {\n        Console.WriteLine($@"Handler for \'{GetType().FullName}\' is run:");\n        Console.WriteLine($@"Value for {nameof(Option1)} property is \'{Option1}\'");\n        Console.WriteLine($@"Value for {nameof(Argument1)} property is \'{Argument1}\'");\n        Console.WriteLine();\n\n        Console.WriteLine($"Instance for {transientDisposable.Name} is available");\n        Console.WriteLine($"Instance for {scopedDisposable.Name} is available");\n        Console.WriteLine($"Instance for {singletonDisposable.Name} is available");\n        Console.WriteLine();\n    }\n}\n\npublic sealed class TransientClass : IDisposable\n{\n    public string Name => nameof(TransientClass);\n\n    public void Dispose() => Console.WriteLine($"{nameof(TransientClass)}.Dispose()");\n}\n\npublic sealed class ScopedClass : IDisposable\n{\n    public string Name => nameof(ScopedClass);\n\n    public void Dispose() => Console.WriteLine($"{nameof(ScopedClass)}.Dispose()");\n}\n\npublic sealed class SingletonClass : IDisposable\n{\n    public string Name => nameof(SingletonClass);\n\n    public void Dispose() => Console.WriteLine($"{nameof(SingletonClass)}.Dispose()");\n}\n')),(0,i.kt)("h2",{parentName:"admonition",id:"help-output"},"Help output"),(0,i.kt)("p",{parentName:"admonition"},"When you run the app via "),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"TestApp.exe -?")," in project output path (e.g. in ",(0,i.kt)("inlineCode",{parentName:"p"},"TestApp\\bin\\Debug\\net7.0"),")")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"or ",(0,i.kt)("inlineCode",{parentName:"p"},"dotnet run -- -?")," in project directory (e.g. in ",(0,i.kt)("inlineCode",{parentName:"p"},"TestApp"),") (note the double hyphen/dash which allows ",(0,i.kt)("inlineCode",{parentName:"p"},"dotnet run")," to pass arguments to our actual application)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You see this usage help:"))),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"DotMake Command-Line TestApp v1.6.0\nCopyright \xa9 2023-2024 DotMake\n\nA root cli command\n\nUsage:\n  TestApp <argument-1> [options]\n\nArguments:\n  <argument-1>  Description for Argument1 [required]\n\nOptions:\n  -o, --option-1 <option-1>  Description for Option1 [default: DefaultForOption1]\n  -v, --version              Show version information\n  -?, -h, --help             Show help and usage information\n")),(0,i.kt)("p",{parentName:"admonition"},"First line comes from ",(0,i.kt)("inlineCode",{parentName:"p"},"AssemblyProductAttribute")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"AssemblyName"),".\nVersion comes from ",(0,i.kt)("inlineCode",{parentName:"p"},"AssemblyInformationalVersionAttribute")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"AssemblyFileVersionAttribute")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"AssemblyVersionAttribute"),".\nSecond line comes from ",(0,i.kt)("inlineCode",{parentName:"p"},"AssemblyCopyrightAttribute"),".\nThird line comes from ",(0,i.kt)("inlineCode",{parentName:"p"},"CliCommand.Description")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"AssemblyDescriptionAttribute"),"."),(0,i.kt)("p",{parentName:"admonition"},"Note, how command/option/argument names, descriptions and default values are automatically populated."),(0,i.kt)("p",{parentName:"admonition"},"By default,  command/option/argument names are generated as follows;"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"First the following suffixes are stripped out from class and property names:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'For commands:\n"RootCliCommand", "RootCommand", "SubCliCommand", "SubCommand", "CliCommand", "Command", "Cli"'),(0,i.kt)("li",{parentName:"ul"},'For options:\n"RootCommandOption", "SubCliCommandOption", "SubCommandOption", "CliCommandOption", "CommandOption", "CliOption", "Option"'),(0,i.kt)("li",{parentName:"ul"},'For arguments:\n"RootCliCommandArgument", "RootCommandArgument", "SubCliCommandArgument", "SubCommandArgument", "CliCommandArgument", "CommandArgument", "CliArgument", "Argument"'))),(0,i.kt)("li",{parentName:"ul"},"Then the names are converted to ",(0,i.kt)("strong",{parentName:"li"},"kebab-case"),", this can be changed by setting ",(0,i.kt)("inlineCode",{parentName:"li"},"NameCasingConvention"),"  property of the ",(0,i.kt)("inlineCode",{parentName:"li"},"CliCommand")," attribute to one of the following values:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNameCasingConvention.None")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNameCasingConvention.LowerCase")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNameCasingConvention.UpperCase")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNameCasingConvention.TitleCase")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNameCasingConvention.PascalCase")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNameCasingConvention.CamelCase")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNameCasingConvention.KebabCase")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNameCasingConvention.SnakeCase")))),(0,i.kt)("li",{parentName:"ul"},"For options, double hyphen/dash prefix is added to the name (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"--option"),"), this can be changed by setting ",(0,i.kt)("inlineCode",{parentName:"li"},"NamePrefixConvention"),"  (default: DoubleHyphen) property of the ",(0,i.kt)("inlineCode",{parentName:"li"},"CliCommand")," attribute to one of the following values:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNamePrefixConvention.SingleHyphen")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNamePrefixConvention.DoubleHyphen")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CliNamePrefixConvention.ForwardSlash")))),(0,i.kt)("li",{parentName:"ul"},"For options, short-form alias with first letter (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"-o"),") is automatically added. This can be changed by setting ",(0,i.kt)("inlineCode",{parentName:"li"},"ShortFormAutoGenerate")," (default: true) and ",(0,i.kt)("inlineCode",{parentName:"li"},"ShortFormPrefixConvention")," (default: SingleHyphen) properties of the ",(0,i.kt)("inlineCode",{parentName:"li"},"CliCommand")," attribute.")),(0,i.kt)("hr",{parentName:"admonition"}),(0,i.kt)("p",{parentName:"admonition"},"For example, change the name casing and prefix convention:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'using System;\nusing DotMake.CommandLine;\n \n[CliCommand(\n    Description = "A cli command with snake_case name casing and forward slash prefix conventions",\n    NameCasingConvention = CliNameCasingConvention.SnakeCase,\n    NamePrefixConvention = CliNamePrefixConvention.ForwardSlash,\n    ShortFormPrefixConvention = CliNamePrefixConvention.ForwardSlash\n)]\npublic class RootSnakeSlashCliCommand\n{\n    [CliOption(Description = "Description for Option1")]\n    public string Option1 { get; set; } = "DefaultForOption1";\n \n    [CliArgument(Description = "Description for Argument1")]\n    public string Argument1 { get; set; }\n \n    public void Run()\n    {\n        Console.WriteLine($@"Handler for \'{GetType().FullName}\' is run:");\n        Console.WriteLine($@"Value for {nameof(Option1)} property is \'{Option1}\'");\n        Console.WriteLine($@"Value for {nameof(Argument1)} property is \'{Argument1}\'");\n        Console.WriteLine();\n    }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"When you run the app via ",(0,i.kt)("inlineCode",{parentName:"p"},"TestApp.exe -?")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"dotnet run -- -?"),", you see this usage help:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-console"},"DotMake Command-Line TestApp v1.6.0\nCopyright \xa9 2023-2024 DotMake\n\nA cli command with snake_case name casing and forward slash prefix conventions\n\nUsage:\n  TestApp <argument_1> [options]\n\nArguments:\n  <argument_1>  Description for Argument1 [required]\n\nOptions:\n  /o, /option_1 <option_1>  Description for Option1 [default: DefaultForOption1]\n  /v, /version              Show version information\n  -?, -h, /help             Show help and usage information\n")),(0,i.kt)("p",{parentName:"admonition"},"Note how even the default options ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"help")," use the new prefix convention ",(0,i.kt)("inlineCode",{parentName:"p"},"ForwardSlash"),". By the way, as ",(0,i.kt)("inlineCode",{parentName:"p"},"help")," is a special option, which allows user to discover your app, we still add short-form aliases with other prefix to prevent confusion."),(0,i.kt)("h3",{parentName:"admonition",id:"localization"},"Localization"),(0,i.kt)("p",{parentName:"admonition"},"Localizing commands, options and arguments is supported.\nYou can specify a ",(0,i.kt)("inlineCode",{parentName:"p"},"nameof")," operator expression with a resource property (generated by resx) in the attribute's argument (for ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," types only)\nand the source generator will smartly use the resource property accessor as the value of the argument so that it can localize at runtime.\nIf the property in the ",(0,i.kt)("inlineCode",{parentName:"p"},"nameof")," operator expression does not point to a resource property, then the name of that property will be used as usual.\nThe reason we use ",(0,i.kt)("inlineCode",{parentName:"p"},"nameof")," operator is that attributes in ",(0,i.kt)("inlineCode",{parentName:"p"},".NET")," only accept compile-time constants and you get ",(0,i.kt)("inlineCode",{parentName:"p"},"CS0182")," error if not,\nso specifying resource property directly is not possible as it's not a compile-time constant but it's a static property access."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'[CliCommand(Description = nameof(TestResources.CommandDescription))]\ninternal class LocalizedCliCommand\n{\n    [CliOption(Description = nameof(TestResources.OptionDescription))]\n    public string Option1 { get; set; } = "DefaultForOption1";\n\n    [CliArgument(Description = nameof(TestResources.ArgumentDescription))]\n    public string Argument1 { get; set; }\n\n    public void Run()\n    {\n        Console.WriteLine($@"Handler for \'{GetType().FullName}\' is run:");\n        Console.WriteLine($@"Value for {nameof(Option1)} property is \'{Option1}\'");\n        Console.WriteLine($@"Value for {nameof(Argument1)} property is \'{Argument1}\'");\n        Console.WriteLine();\n    }\n}\n')),(0,i.kt)("h3",{parentName:"admonition",id:"triggering-help"},"Triggering help"),(0,i.kt)("p",{parentName:"admonition"},"If a command represents a group and not an action, you may want to show help.\nIf ",(0,i.kt)("inlineCode",{parentName:"p"},"Run")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"RunAsync")," method is missing in a command class, then by default it will show help.\nYou can also manually trigger help in ",(0,i.kt)("inlineCode",{parentName:"p"},"Run")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"RunAsync")," method of a command class via calling ",(0,i.kt)("inlineCode",{parentName:"p"},"CliContext.ShowHelp"),".\nFor testing a command, other methods ",(0,i.kt)("inlineCode",{parentName:"p"},"CliContext.ShowValues")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CliContext.IsEmptyCommand")," are also useful.\n",(0,i.kt)("inlineCode",{parentName:"p"},"ShowValues")," shows parsed values for current command and its arguments and options."),(0,i.kt)("p",{parentName:"admonition"},"See below example; root command does not have a handler method so it will always show help\nand sub-command will show help if command is specified without any arguments or option,\nand it will show (dump) values if not:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-c#"},'[CliCommand(Description = "A root cli command")]\npublic class HelpCliCommand\n{\n  [CliOption(Description = "Description for Option1")]\n  public string Option1 { get; set; } = "DefaultForOption1";\n\n  [CliArgument(Description = "Description for Argument1")]\n  public string Argument1 { get; set; } = "DefaultForArgument1";\n\n  [CliCommand(Description = "A sub cli command")]\n  public class SubCliCommand\n  {\n      [CliArgument(Description = "Description for Argument2")]\n      public string Argument2 { get; set; } = "DefaultForArgument2";\n\n      public void Run(CliContext context)\n      {\n          if (context.IsEmptyCommand())\n              context.ShowHelp();\n          else\n              context.ShowValues();\n      }\n  }\n}\n')),(0,i.kt)("h2",{parentName:"admonition",id:"additional-documentation"},"Additional documentation"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://dotmake.build/api/"},"DotMake Command-Line API docs")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/standard/commandline/syntax"},"Command-line syntax overview for System.CommandLine")))),(0,i.kt)("h3",{id:"about"},"About"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Generating easy command line applications.")),(0,i.kt)("h2",{id:"how-to-use"},"How to use"),(0,i.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,i.kt)(o.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,i.kt)("p",null,"This is the CSharp Project that references ",(0,i.kt)("strong",{parentName:"p"},"CommandLine")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {11}",showLineNumbers:!0,"{11}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include="DotMake.CommandLine" Version="1.8.0" />\n  </ItemGroup>\n    <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n</Project>\n\n'))),(0,i.kt)(r.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CommandLine\\src\\CmdDemo\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,i.kt)("p",null,"  This is the use of ",(0,i.kt)("strong",{parentName:"p"},"CommandLine")," in ",(0,i.kt)("em",{parentName:"p"},"Program.cs")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// See https://aka.ms/new-console-template for more information\nusing DotMake.CommandLine;\n\nCli.Run(([CliArgument] string PersonName, int  Age) =>\n{\n    Console.WriteLine($@\"Value for {nameof(PersonName)} parameter is '{PersonName}'\");\n    Console.WriteLine($@\"Value for {nameof(Age)} parameter is '{Age}'\");\n});\n\n\nCli.Run(([CliArgument] int idData) =>\n{\n    Console.WriteLine($@\"Value for {nameof(idData)} parameter is '{idData}'\");\n    \n});\n")))),(0,i.kt)("h3",{id:"generated-files"},"Generated Files"),(0,i.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,i.kt)(o.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CommandLine\\src\\CmdDemo\\obj\\GX\\DotMake.CommandLine.SourceGeneration\\DotMake.CommandLine.SourceGeneration.CliCommandGenerator\\CliCommandAsDelegate_1ra93x8.g.cs",label:"CliCommandAsDelegate_1ra93x8.g.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated />\n// Generated by DotMake.CommandLine.SourceGeneration v1.8.0.0\n// Roslyn (Microsoft.CodeAnalysis) v4.1100.24.36508\n// Generation: 1\n\nnamespace GeneratedCode\n{\n    /// <inheritdoc />\n    [DotMake.CommandLine.CliCommandAttribute]\n    public class CliCommandAsDelegate_1ra93x8 : DotMake.CommandLine.CliCommandAsDelegateDefinition\n    {\n        /// <inheritdoc />\n        [DotMake.CommandLine.CliArgumentAttribute]\n        public int idData { get; set; }\n\n        /// <inheritdoc />\n        public void Run()\n        {\n            InvokeDelegate\n            (\n                "1ra93x8",\n                new object[]\n                {\n                    idData, \n                }\n            );\n        }\n\n        [System.Runtime.CompilerServices.ModuleInitializerAttribute]\n        internal static void Initialize()\n        {\n            // Register this definition class so that it can be found by the command as delegate hash.\n            Register<GeneratedCode.CliCommandAsDelegate_1ra93x8>("1ra93x8");\n        }\n    }\n}\n\n'))),(0,i.kt)(r.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CommandLine\\src\\CmdDemo\\obj\\GX\\DotMake.CommandLine.SourceGeneration\\DotMake.CommandLine.SourceGeneration.CliCommandGenerator\\CliCommandAsDelegate_1ra93x8Builder-6ke4hy4.g.cs",label:"CliCommandAsDelegate_1ra93x8Builder-6ke4hy4.g.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated />\n// Generated by DotMake.CommandLine.SourceGeneration v1.8.0.0\n// Roslyn (Microsoft.CodeAnalysis) v4.1100.24.36508\n// Generation: 1\n\nnamespace GeneratedCode\n{\n    /// <inheritdoc />\n    public class CliCommandAsDelegate_1ra93x8Builder : DotMake.CommandLine.CliCommandBuilder\n    {\n        /// <inheritdoc />\n        public CliCommandAsDelegate_1ra93x8Builder()\n        {\n            DefinitionType = typeof(GeneratedCode.CliCommandAsDelegate_1ra93x8);\n            ParentDefinitionType = null;\n            NameCasingConvention = DotMake.CommandLine.CliNameCasingConvention.KebabCase;\n            NamePrefixConvention = DotMake.CommandLine.CliNamePrefixConvention.DoubleHyphen;\n            ShortFormPrefixConvention = DotMake.CommandLine.CliNamePrefixConvention.SingleHyphen;\n            ShortFormAutoGenerate = true;\n        }\n\n        private GeneratedCode.CliCommandAsDelegate_1ra93x8 CreateInstance()\n        {\n            return new GeneratedCode.CliCommandAsDelegate_1ra93x8();\n        }\n\n        /// <inheritdoc />\n        public override System.CommandLine.CliCommand Build()\n        {\n            // Command for 'CliCommandAsDelegate_1ra93x8' class\n            var rootCommand = new System.CommandLine.CliRootCommand()\n            {\n            };\n\n            var defaultClass = CreateInstance();\n\n            // Argument for 'idData' property\n            var argument0 = new System.CommandLine.CliArgument<int>\n            (\n                \"id-data\"\n            )\n            {\n            };\n            argument0.CustomParser = GetParseArgument<int>\n            (\n                null\n            );\n            argument0.DefaultValueFactory = _ => defaultClass.idData;\n            rootCommand.Add(argument0);\n\n            // Add nested or external registered children\n            foreach (var child in Children)\n            {\n                rootCommand.Add(child.Build());\n            }\n\n            BindFunc = (parseResult) =>\n            {\n                var targetClass = CreateInstance();\n\n                //  Set the parsed or default values for the options\n\n                //  Set the parsed or default values for the arguments\n                targetClass.idData = GetValueForArgument(parseResult, argument0);\n\n                return targetClass;\n            };\n\n            rootCommand.SetAction(parseResult =>\n            {\n                var targetClass = (GeneratedCode.CliCommandAsDelegate_1ra93x8) BindFunc(parseResult);\n\n                //  Call the command handler\n                var cliContext = new DotMake.CommandLine.CliContext(parseResult);\n                var exitCode = 0;\n                targetClass.Run();\n                return exitCode;\n            });\n\n            return rootCommand;\n        }\n\n        [System.Runtime.CompilerServices.ModuleInitializerAttribute]\n        internal static void Initialize()\n        {\n            var commandBuilder = new GeneratedCode.CliCommandAsDelegate_1ra93x8Builder();\n\n            // Register this command builder so that it can be found by the definition class\n            // and it can be found by the parent definition class if it's a nested/external child.\n            commandBuilder.Register();\n        }\n    }\n}\n\n"))),(0,i.kt)(r.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CommandLine\\src\\CmdDemo\\obj\\GX\\DotMake.CommandLine.SourceGeneration\\DotMake.CommandLine.SourceGeneration.CliCommandGenerator\\CliCommandAsDelegate_34pdvjr.g.cs",label:"CliCommandAsDelegate_34pdvjr.g.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated />\n// Generated by DotMake.CommandLine.SourceGeneration v1.8.0.0\n// Roslyn (Microsoft.CodeAnalysis) v4.1100.24.36508\n// Generation: 1\n\nnamespace GeneratedCode\n{\n    /// <inheritdoc />\n    [DotMake.CommandLine.CliCommandAttribute]\n    public class CliCommandAsDelegate_34pdvjr : DotMake.CommandLine.CliCommandAsDelegateDefinition\n    {\n        /// <inheritdoc />\n        [DotMake.CommandLine.CliArgumentAttribute]\n        public string PersonName { get; set; }\n\n        /// <inheritdoc />\n        [DotMake.CommandLine.CliOptionAttribute]\n        public int Age { get; set; }\n\n        /// <inheritdoc />\n        public void Run()\n        {\n            InvokeDelegate\n            (\n                "34pdvjr",\n                new object[]\n                {\n                    PersonName, \n                    Age, \n                }\n            );\n        }\n\n        [System.Runtime.CompilerServices.ModuleInitializerAttribute]\n        internal static void Initialize()\n        {\n            // Register this definition class so that it can be found by the command as delegate hash.\n            Register<GeneratedCode.CliCommandAsDelegate_34pdvjr>("34pdvjr");\n        }\n    }\n}\n\n'))),(0,i.kt)(r.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\CommandLine\\src\\CmdDemo\\obj\\GX\\DotMake.CommandLine.SourceGeneration\\DotMake.CommandLine.SourceGeneration.CliCommandGenerator\\CliCommandAsDelegate_34pdvjrBuilder-empvmnm.g.cs",label:"CliCommandAsDelegate_34pdvjrBuilder-empvmnm.g.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated />\n// Generated by DotMake.CommandLine.SourceGeneration v1.8.0.0\n// Roslyn (Microsoft.CodeAnalysis) v4.1100.24.36508\n// Generation: 1\n\nnamespace GeneratedCode\n{\n    /// <inheritdoc />\n    public class CliCommandAsDelegate_34pdvjrBuilder : DotMake.CommandLine.CliCommandBuilder\n    {\n        /// <inheritdoc />\n        public CliCommandAsDelegate_34pdvjrBuilder()\n        {\n            DefinitionType = typeof(GeneratedCode.CliCommandAsDelegate_34pdvjr);\n            ParentDefinitionType = null;\n            NameCasingConvention = DotMake.CommandLine.CliNameCasingConvention.KebabCase;\n            NamePrefixConvention = DotMake.CommandLine.CliNamePrefixConvention.DoubleHyphen;\n            ShortFormPrefixConvention = DotMake.CommandLine.CliNamePrefixConvention.SingleHyphen;\n            ShortFormAutoGenerate = true;\n        }\n\n        private GeneratedCode.CliCommandAsDelegate_34pdvjr CreateInstance()\n        {\n            return new GeneratedCode.CliCommandAsDelegate_34pdvjr();\n        }\n\n        /// <inheritdoc />\n        public override System.CommandLine.CliCommand Build()\n        {\n            // Command for 'CliCommandAsDelegate_34pdvjr' class\n            var rootCommand = new System.CommandLine.CliRootCommand()\n            {\n            };\n\n            var defaultClass = CreateInstance();\n\n            // Option for 'Age' property\n            var option0 = new System.CommandLine.CliOption<int>\n            (\n                \"--age\"\n            )\n            {\n                Required = false,\n            };\n            option0.CustomParser = GetParseArgument<int>\n            (\n                null\n            );\n            option0.DefaultValueFactory = _ => defaultClass.Age;\n            option0.Aliases.Add(\"-a\");\n            rootCommand.Add(option0);\n\n            // Argument for 'PersonName' property\n            var argument0 = new System.CommandLine.CliArgument<string>\n            (\n                \"person-name\"\n            )\n            {\n            };\n            argument0.CustomParser = GetParseArgument<string>\n            (\n                null\n            );\n            rootCommand.Add(argument0);\n\n            // Add nested or external registered children\n            foreach (var child in Children)\n            {\n                rootCommand.Add(child.Build());\n            }\n\n            BindFunc = (parseResult) =>\n            {\n                var targetClass = CreateInstance();\n\n                //  Set the parsed or default values for the options\n                targetClass.Age = GetValueForOption(parseResult, option0);\n\n                //  Set the parsed or default values for the arguments\n                targetClass.PersonName = GetValueForArgument(parseResult, argument0);\n\n                return targetClass;\n            };\n\n            rootCommand.SetAction(parseResult =>\n            {\n                var targetClass = (GeneratedCode.CliCommandAsDelegate_34pdvjr) BindFunc(parseResult);\n\n                //  Call the command handler\n                var cliContext = new DotMake.CommandLine.CliContext(parseResult);\n                var exitCode = 0;\n                targetClass.Run();\n                return exitCode;\n            });\n\n            return rootCommand;\n        }\n\n        [System.Runtime.CompilerServices.ModuleInitializerAttribute]\n        internal static void Initialize()\n        {\n            var commandBuilder = new GeneratedCode.CliCommandAsDelegate_34pdvjrBuilder();\n\n            // Register this command builder so that it can be found by the definition class\n            // and it can be found by the parent definition class if it's a nested/external child.\n            commandBuilder.Register();\n        }\n    }\n}\n\n")))),(0,i.kt)("h2",{id:"usefull"},"Usefull"),(0,i.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{target:"_blank",href:t(53395).Z},"Download Example project CommandLine "))),(0,i.kt)("h3",{id:"share-commandline"},"Share CommandLine"),(0,i.kt)("ul",null,(0,i.kt)("li",null,(0,i.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommandLine&quote=CommandLine",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,i.kt)("li",null,(0,i.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommandLine&text=CommandLine:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommandLine",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,i.kt)("li",null,(0,i.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommandLine&title=CommandLine",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,i.kt)("li",null,(0,i.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommandLine&title=CommandLine&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FCommandLine",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/CommandLine"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/CommandLine")),(0,i.kt)("h3",{id:"in-the-same-category-enhancementproject---18-other-generators"},"In the same category (EnhancementProject) - 18 other generators"),(0,i.kt)("h4",{id:"autoinvokegenerator"},(0,i.kt)("a",{parentName:"h4",href:"/docs/AutoInvoke.Generator"},"AutoInvoke.Generator")),(0,i.kt)("h4",{id:"autospectre"},(0,i.kt)("a",{parentName:"h4",href:"/docs/AutoSpectre"},"AutoSpectre")),(0,i.kt)("h4",{id:"buildinfo"},(0,i.kt)("a",{parentName:"h4",href:"/docs/BuildInfo"},"BuildInfo")),(0,i.kt)("h4",{id:"com"},(0,i.kt)("a",{parentName:"h4",href:"/docs/Com"},"Com")),(0,i.kt)("h4",{id:"credfetoversioninformationgenerator"},(0,i.kt)("a",{parentName:"h4",href:"/docs/Credfeto.Version.Information.Generator"},"Credfeto.Version.Information.Generator")),(0,i.kt)("h4",{id:"larcanumgitinfo"},(0,i.kt)("a",{parentName:"h4",href:"/docs/Larcanum.GitInfo"},"Larcanum.GitInfo")),(0,i.kt)("h4",{id:"linqgengenerator"},(0,i.kt)("a",{parentName:"h4",href:"/docs/LinqGen.Generator"},"LinqGen.Generator")),(0,i.kt)("h4",{id:"peksprobuildinformationgenerator"},(0,i.kt)("a",{parentName:"h4",href:"/docs/Pekspro.BuildInformationGenerator"},"Pekspro.BuildInformationGenerator")),(0,i.kt)("h4",{id:"plantumlclassdiagramgenerator"},(0,i.kt)("a",{parentName:"h4",href:"/docs/PlantUmlClassDiagramGenerator"},"PlantUmlClassDiagramGenerator")),(0,i.kt)("h4",{id:"rscg_ams"},(0,i.kt)("a",{parentName:"h4",href:"/docs/RSCG_AMS"},"RSCG_AMS")),(0,i.kt)("h4",{id:"rscg_exportdiagram"},(0,i.kt)("a",{parentName:"h4",href:"/docs/RSCG_ExportDiagram"},"RSCG_ExportDiagram")),(0,i.kt)("h4",{id:"rscg_functionswithdi"},(0,i.kt)("a",{parentName:"h4",href:"/docs/RSCG_FunctionsWithDI"},"RSCG_FunctionsWithDI")),(0,i.kt)("h4",{id:"rscg_namegenerator"},(0,i.kt)("a",{parentName:"h4",href:"/docs/RSCG_NameGenerator"},"RSCG_NameGenerator")),(0,i.kt)("h4",{id:"rscg_timebombcomment"},(0,i.kt)("a",{parentName:"h4",href:"/docs/RSCG_TimeBombComment"},"RSCG_TimeBombComment")),(0,i.kt)("h4",{id:"rscg_wait"},(0,i.kt)("a",{parentName:"h4",href:"/docs/RSCG_Wait"},"RSCG_Wait")),(0,i.kt)("h4",{id:"thisassembly"},(0,i.kt)("a",{parentName:"h4",href:"/docs/ThisAssembly"},"ThisAssembly")),(0,i.kt)("h4",{id:"thisassemblyconstants"},(0,i.kt)("a",{parentName:"h4",href:"/docs/ThisAssembly.Constants"},"ThisAssembly.Constants")),(0,i.kt)("h4",{id:"thisassemblymetadata"},(0,i.kt)("a",{parentName:"h4",href:"/docs/ThisAssembly.Metadata"},"ThisAssembly.Metadata")))}g.isMDXComponent=!0},53395:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/CommandLine-7cfc9ead53f03643b9393f222c467de8.zip"}}]);