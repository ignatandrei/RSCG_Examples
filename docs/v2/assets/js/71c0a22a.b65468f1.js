"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[5658],{2203:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>m,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var t=a(87462),r=(a(67294),a(3905)),o=a(73992),i=a(18679),s=a(68839);const l={sidebar_position:320,title:"32 - Mediator",description:"Gnerating mediator data without reflection",slug:"/Mediator"},d="Mediator  by Martin Othamar",p={unversionedId:"RSCG-Examples/Mediator",id:"RSCG-Examples/Mediator",title:"32 - Mediator",description:"Gnerating mediator data without reflection",source:"@site/docs/RSCG-Examples/Mediator.md",sourceDirName:"RSCG-Examples",slug:"/Mediator",permalink:"/RSCG_Examples/v2/docs/Mediator",draft:!1,tags:[],version:"current",sidebarPosition:320,frontMatter:{sidebar_position:320,title:"32 - Mediator",description:"Gnerating mediator data without reflection",slug:"/Mediator"},sidebar:"tutorialSidebar",previous:{title:"31 - MorrisMoxy",permalink:"/RSCG_Examples/v2/docs/MorrisMoxy"},next:{title:"33 - Matryoshki",permalink:"/RSCG_Examples/v2/docs/Matryoshki"}},m={},c=[{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share Mediator",id:"share-mediator",level:3},{value:"In the same category (EnhancementProject)",id:"in-the-same-category-enhancementproject",level:2},{value:"BuildInfo",id:"buildinfo",level:3},{value:"Com",id:"com",level:3},{value:"CommandLine",id:"commandline",level:3},{value:"DeeDee",id:"deedee",level:3},{value:"PlantUmlClassDiagramGenerator",id:"plantumlclassdiagramgenerator",level:3},{value:"RSCG_AMS",id:"rscg_ams",level:3},{value:"RSCG_FunctionsWithDI",id:"rscg_functionswithdi",level:3},{value:"RSCG_TimeBombComment",id:"rscg_timebombcomment",level:3},{value:"SourceGenerator.Helper.CopyCode",id:"sourcegeneratorhelpercopycode",level:3},{value:"ThisAssembly",id:"thisassembly",level:3}],u={toc:c},g="wrapper";function h(e){let{components:n,...l}=e;return(0,r.kt)(g,(0,t.Z)({},u,l,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"mediator--by-martin-othamar"},"Mediator  by Martin Othamar"),(0,r.kt)(s.Z,{toc:c,mdxType:"TOCInline"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Mediator.SourceGenerator"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/Mediator.SourceGenerator?label=Mediator.SourceGenerator",alt:"Nuget"})),(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Mediator.Abstractions"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/Mediator.Abstractions?label=Mediator.Abstractions",alt:"Nuget"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/martinothamar/Mediator"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/martinothamar/Mediator?label=updated",alt:"GitHub last commit"})),"\n",(0,r.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/martinothamar/Mediator?style=social",alt:"GitHub Repo stars"})),(0,r.kt)("h2",{id:"details"},"Details"),(0,r.kt)("h3",{id:"info"},"Info"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Name: ",(0,r.kt)("strong",{parentName:"p"},"Mediator")),(0,r.kt)("p",{parentName:"admonition"},"A high performance .NET Mediator pattern implemenation using source generation."),(0,r.kt)("p",{parentName:"admonition"},"Author: Martin Othamar"),(0,r.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/Mediator.SourceGenerator"},"https://www.nuget.org/packages/Mediator.SourceGenerator")),"   "),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/Mediator.Abstractions"},"https://www.nuget.org/packages/Mediator.Abstractions")),"   "),(0,r.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/martinothamar/Mediator"},"https://github.com/martinothamar/Mediator")),(0,r.kt)("p",{parentName:"admonition"},"Source : ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/martinothamar/Mediator"},"https://github.com/martinothamar/Mediator"))),(0,r.kt)("h3",{id:"original-readme"},"Original Readme"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/martinothamar/Mediator/actions"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/actions/workflow/status/martinothamar/Mediator/build.yml?branch=main",alt:"GitHub Workflow Status"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/martinothamar/Mediator/blob/main/LICENSE"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/license/martinothamar/Mediator?style=flat-square",alt:"GitHub"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Mediator.Abstractions/"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/mediator.abstractions?style=flat-square",alt:"Downloads"})),(0,r.kt)("br",null),"\n",(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Mediator.Abstractions"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/v/Mediator.Abstractions?label=Mediator.Abstractions",alt:"Abstractions NuGet current"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Mediator.SourceGenerator"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/v/Mediator.SourceGenerator?label=Mediator.SourceGenerator",alt:"SourceGenerator NuGet current"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Mediator.Abstractions"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/vpre/Mediator.Abstractions?label=Mediator.Abstractions",alt:"Abstractions NuGet prerelease"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Mediator.SourceGenerator"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/vpre/Mediator.SourceGenerator?label=Mediator.SourceGenerator",alt:"SourceGenerator NuGet prerelease"})),(0,r.kt)("br",null)),(0,r.kt)("h1",{parentName:"admonition",id:"mediator"},"Mediator"),(0,r.kt)("blockquote",{parentName:"admonition"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Version 3.0")," is currently being developed. See status and provide feedback ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/martinothamar/Mediator/issues/98"},"here (#98)"))),(0,r.kt)("p",{parentName:"admonition"},"This is a high performance .NET implementation of the Mediator pattern using the ",(0,r.kt)("a",{parentName:"p",href:"https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/"},"source generators")," feature introduced in .NET 5.\nThe API and usage is mostly based on the great ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/jbogard/MediatR"},"MediatR")," library, with some deviations to allow for better performance.\nPackages are .NET Standard 2.1 compatible."),(0,r.kt)("p",{parentName:"admonition"},'The mediator pattern is great for implementing cross cutting concern (logging, metrics, etc) and avoiding "fat" constructors due to lots of injected services.'),(0,r.kt)("p",{parentName:"admonition"},"Goals for this library"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"High performance",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Runtime performance can be the same for both runtime reflection and source generator based approaches, but it's easier to optimize in the latter case"))),(0,r.kt)("li",{parentName:"ul"},"AOT friendly",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"MS are investing time in various AOT scenarios, and for example iOS requirees AOT compilation"))),(0,r.kt)("li",{parentName:"ul"},"Build time errors instead of runtime errors",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The generator includes diagnostics, i.e. if a handler is not defined for a request, a warning is emitted")))),(0,r.kt)("p",{parentName:"admonition"},"In particular, source generators in this library is used to"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Generate code for DI registration"),(0,r.kt)("li",{parentName:"ul"},"Generate code for ",(0,r.kt)("inlineCode",{parentName:"li"},"IMediator")," implementation",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Request/Command/Query ",(0,r.kt)("inlineCode",{parentName:"li"},"Send")," methods are monomorphized (1 method per T), the generic ",(0,r.kt)("inlineCode",{parentName:"li"},"ISender.Send")," methods rely on these"),(0,r.kt)("li",{parentName:"ul"},"You can use both ",(0,r.kt)("inlineCode",{parentName:"li"},"IMediator")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Mediator"),", the latter allows for better performance"))),(0,r.kt)("li",{parentName:"ul"},"Generate diagnostics related messages and message handlers")),(0,r.kt)("p",{parentName:"admonition"},"See this great video by ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Elfocrash"},"@Elfocrash / Nick Chapsas"),", covering both similarities and differences between Mediator and MediatR"),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=aaFLtcf8cO4"},(0,r.kt)("img",{parentName:"a",src:"https://img.youtube.com/vi/aaFLtcf8cO4/0.jpg",alt:"Using MediatR in .NET? Maybe replace it with this"}))),(0,r.kt)("h2",{parentName:"admonition",id:"table-of-contents"},"Table of Contents"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#mediator"},"Mediator"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#table-of-contents"},"Table of Contents")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#2-benchmarks"},"2. Benchmarks")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#3-usage-and-abstractions"},"3. Usage and abstractions"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#31-message-types"},"3.1. Message types")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#32-handler-types"},"3.2. Handler types")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#33-pipeline-types"},"3.3. Pipeline types"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#331-message-validation-example"},"3.3.1. Message validation example")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#332-error-logging-example"},"3.3.2. Error logging example")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#34-configuration"},"3.4. Configuration")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#4-getting-started"},"4. Getting started"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#41-add-package"},"4.1. Add package")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#42-add-mediator-to-di-container"},"4.2. Add Mediator to DI container")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#43-create-irequest-type"},"4.3. Create ",(0,r.kt)("inlineCode",{parentName:"a"},"IRequest<>")," type")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#44-use-pipeline-behaviors"},"4.4. Use pipeline behaviors")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#45-constrain-ipipelinebehavior-message-with-open-generics"},"4.5. Constrain ",(0,r.kt)("inlineCode",{parentName:"a"},"IPipelineBehavior<,>")," message with open generics")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#46-use-notifications"},"4.6. Use notifications")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#47-polymorphic-dispatch-with-notification-handlers"},"4.7. Polymorphic dispatch with notification handlers")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#48-notification-handlers-also-support-open-generics"},"4.8. Notification handlers also support open generics")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#49-use-streaming-messages"},"4.9. Use streaming messages")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#5-diagnostics"},"5. Diagnostics")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#6-differences-from-mediatr"},"6. Differences from MediatR"))))),(0,r.kt)("h2",{parentName:"admonition",id:"2-benchmarks"},"2. Benchmarks"),(0,r.kt)("p",{parentName:"admonition"},"This benchmark exposes the perf overhead of the libraries.\nMediator (this library) and MediatR methods show the overhead of the respective mediator implementations.\nI've also included the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Cysharp/MessagePipe"},"MessagePipe")," library as it also has great performance."),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<SendRequest | Stream>_Baseline"),": simple method call into the handler class"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<SendRequest | Stream>_Mediator"),": the concrete ",(0,r.kt)("inlineCode",{parentName:"li"},"Mediator")," class generated by this library"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<SendRequest | Stream>_MessagePipe"),": the ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Cysharp/MessagePipe"},"MessagePipe")," library"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<SendRequest | Stream>_IMediator"),": call through the ",(0,r.kt)("inlineCode",{parentName:"li"},"IMediator")," interface in this library"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<SendRequest | Stream>_MediatR"),": the ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/jbogard/MediatR"},"MediatR")," library")),(0,r.kt)("p",{parentName:"admonition"},"See benchmarks code for more details on the measurement."),(0,r.kt)("blockquote",{parentName:"admonition"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Warning")),(0,r.kt)("p",{parentName:"blockquote"},"A current limitation of this library is that performance degrades significantly for projects with a large number of messages (>500)\nThere is ongoing work on resolving this for version 3.0 (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/martinothamar/Mediator/issues/48"},"#48"),").")),(0,r.kt)("h2",{parentName:"admonition",id:"3-usage-and-abstractions"},"3. Usage and abstractions"),(0,r.kt)("p",{parentName:"admonition"},"There are two NuGet packages needed to use this library"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Mediator.SourceGenerator",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"To generate the ",(0,r.kt)("inlineCode",{parentName:"li"},"IMediator")," implementation and dependency injection setup."))),(0,r.kt)("li",{parentName:"ul"},"Mediator.Abstractions",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Message types (",(0,r.kt)("inlineCode",{parentName:"li"},"IRequest<,>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"INotification"),"), handler types (",(0,r.kt)("inlineCode",{parentName:"li"},"IRequestHandler<,>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"INotificationHandler<>"),"), pipeline types (",(0,r.kt)("inlineCode",{parentName:"li"},"IPipelineBehavior"),")")))),(0,r.kt)("p",{parentName:"admonition"},"You install the source generator package into your edge/outermost project (i.e. ASP.NET Core application, Background worker project),\nand then use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Mediator.Abstractions")," package wherever you define message types and handlers.\nStandard message handlers are automatically picked up and added to the DI container in the generated ",(0,r.kt)("inlineCode",{parentName:"p"},"AddMediator")," method.\n",(0,r.kt)("em",{parentName:"p"},"Pipeline behaviors need to be added manually (including pre/post/exception behaviors).")),(0,r.kt)("p",{parentName:"admonition"},"For example implementations, see the samples folder.\nSee the ASP.NET Core clean architecture sample for a more real world setup."),(0,r.kt)("h3",{parentName:"admonition",id:"31-message-types"},"3.1. Message types"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IMessage")," - marker interface"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IStreamMessage")," - marker interface"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IBaseRequest")," - marker interface for requests"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IRequest")," - a request message, no return value (",(0,r.kt)("inlineCode",{parentName:"li"},"ValueTask<Unit>"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IRequest<out TResponse>")," - a request message with a response (",(0,r.kt)("inlineCode",{parentName:"li"},"ValueTask<TResponse>"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IStreamRequest<out TResponse>")," - a request message with a streaming response (",(0,r.kt)("inlineCode",{parentName:"li"},"IAsyncEnumerable<TResponse>"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IBaseCommand")," - marker interface for commands"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ICommand")," - a command message, no return value (",(0,r.kt)("inlineCode",{parentName:"li"},"ValueTask<Unit>"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ICommand<out TResponse>")," - a command message with a response (",(0,r.kt)("inlineCode",{parentName:"li"},"ValueTask<TResponse>"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IStreamCommand<out TResponse>")," - a command message with a streaming response (",(0,r.kt)("inlineCode",{parentName:"li"},"IAsyncEnumerable<TResponse>"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IBaseQuery")," - marker interface for queries"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IQuery<out TResponse>")," - a query message with a response (",(0,r.kt)("inlineCode",{parentName:"li"},"ValueTask<TResponse>"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IStreamQuery<out TResponse>")," - a query message with a streaming response (",(0,r.kt)("inlineCode",{parentName:"li"},"IAsyncEnumerable<TResponse>"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"INotification")," - a notification message, no return value (",(0,r.kt)("inlineCode",{parentName:"li"},"ValueTask"),")")),(0,r.kt)("p",{parentName:"admonition"},"As you can see, you can achieve the exact same thing with requests, commands and queries. But I find the distinction in naming useful if you for example use the CQRS pattern or for some reason have a preference on naming in your application."),(0,r.kt)("h3",{parentName:"admonition",id:"32-handler-types"},"3.2. Handler types"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IRequestHandler<in TRequest>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IRequestHandler<in TRequest, TResponse>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IStreamRequestHandler<in TRequest, out TResponse>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ICommandHandler<in TCommand>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ICommandHandler<in TCommand, TResponse>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IStreamCommandHandler<in TCommand, out TResponse>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IQueryHandler<in TQuery, TResponse>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IStreamQueryHandler<in TQuery, out TResponse>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"INotificationHandler<in TNotification>"))),(0,r.kt)("p",{parentName:"admonition"},"These types are used in correlation with the message types above."),(0,r.kt)("h3",{parentName:"admonition",id:"33-pipeline-types"},"3.3. Pipeline types"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IPipelineBehavior<TMessage, TResponse>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IStreamPipelineBehavior<TMessage, TResponse>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MessagePreProcessor<TMessage, TResponse>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MessagePostProcessor<TMessage, TResponse>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MessageExceptionHandler<TMessage, TResponse, TException>"))),(0,r.kt)("h4",{parentName:"admonition",id:"331-message-validation-example"},"3.3.1. Message validation example"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// As a normal pipeline behavior\npublic sealed class MessageValidatorBehaviour<TMessage, TResponse> : IPipelineBehavior<TMessage, TResponse>\n    where TMessage : IValidate\n{\n    public ValueTask<TResponse> Handle(\n        TMessage message,\n        CancellationToken cancellationToken,\n        MessageHandlerDelegate<TMessage, TResponse> next\n    )\n    {\n        if (!message.IsValid(out var validationError))\n            throw new ValidationException(validationError);\n\n        return next(message, cancellationToken);\n    }\n}\n\n// Or as a pre-processor\npublic sealed class MessageValidatorBehaviour<TMessage, TResponse> : MessagePreProcessor<TMessage, TResponse>\n    where TMessage : IValidate\n{\n    protected override ValueTask Handle(TMessage message, CancellationToken cancellationToken)\n    {\n        if (!message.IsValid(out var validationError))\n            throw new ValidationException(validationError);\n\n        return default;\n    }\n}\n\n// Register as IPipelineBehavior<,> in either case\nservices.AddSingleton(typeof(IPipelineBehavior<,>), typeof(MessageValidatorBehaviour<,>))\n")),(0,r.kt)("h4",{parentName:"admonition",id:"332-error-logging-example"},"3.3.2. Error logging example"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'// As a normal pipeline behavior\npublic sealed class ErrorLoggingBehaviour<TMessage, TResponse> : IPipelineBehavior<TMessage, TResponse>\n    where TMessage : IMessage\n{\n    private readonly ILogger<ErrorLoggingBehaviour<TMessage, TResponse>> _logger;\n\n    public ErrorLoggingBehaviour(ILogger<ErrorLoggingBehaviour<TMessage, TResponse>> logger)\n    {\n        _logger = logger;\n    }\n\n    public async ValueTask<TResponse> Handle(\n        TMessage message,\n        CancellationToken cancellationToken,\n        MessageHandlerDelegate<TMessage, TResponse> next\n    )\n    {\n        try\n        {\n            return await next(message, cancellationToken);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, "Error handling message of type {messageType}", message.GetType().Name);\n            throw;\n        }\n    }\n}\n\n// Or as an exception handler\npublic sealed class ErrorLoggingBehaviour<TMessage, TResponse> : MessageExceptionHandler<TMessage, TResponse>\n    where TMessage : notnull, IMessage\n{\n    private readonly ILogger<ErrorLoggingBehaviour<TMessage, TResponse>> _logger;\n\n    public ErrorLoggingBehaviour(ILogger<ErrorLoggingBehaviour<TMessage, TResponse>> logger)\n    {\n        _logger = logger;\n    }\n\n    protected override ValueTask<ExceptionHandlingResult<TResponse>> Handle(\n        TMessage message,\n        Exception exception,\n        CancellationToken cancellationToken\n    )\n    {\n        _logger.LogError(exception, "Error handling message of type {messageType}", message.GetType().Name);\n        // Let the exception bubble up by using the base class helper NotHandled:\n        return NotHandled;\n        // Or if the exception is properly handled, you can just return your own response,\n        // using the base class helper Handle().\n        // This requires you to know something about TResponse,\n        // so TResponse needs to be constrained to something,\n        // typically with a static abstract member acting as a consructor on an interface or abstract class.\n        return Handled(null!);\n    }\n}\n\n// Register as IPipelineBehavior<,> in either case\nservices.AddSingleton(typeof(IPipelineBehavior<,>), typeof(ErrorLoggingBehaviour<,>))\n')),(0,r.kt)("h3",{parentName:"admonition",id:"34-configuration"},"3.4. Configuration"),(0,r.kt)("p",{parentName:"admonition"},"There are two ways to configure Mediator. Configuration values are needed during compile-time since this is a source generator:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Assembly level attribute for configuration: ",(0,r.kt)("inlineCode",{parentName:"li"},"MediatorOptionsAttribute")),(0,r.kt)("li",{parentName:"ul"},"Options configuration delegate in ",(0,r.kt)("inlineCode",{parentName:"li"},"AddMediator")," function.")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'services.AddMediator(options =>\n{\n    options.Namespace = "SimpleConsole.Mediator";\n    options.DefaultServiceLifetime = ServiceLifetime.Transient;\n});\n\n// or\n\n[assembly: MediatorOptions(Namespace = "SimpleConsole.Mediator", DefaultServiceLifetime = ServiceLifetime.Transient)]\n')),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Namespace")," - where the ",(0,r.kt)("inlineCode",{parentName:"li"},"IMediator")," implementation is generated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DefaultServiceLifetime")," - the DI service lifetime",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Singleton")," - (default value) everything registered as singletons, minimal allocations"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Transient")," - handlers registered as transient, ",(0,r.kt)("inlineCode",{parentName:"li"},"IMediator"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"Mediator"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"ISender"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"IPublisher")," still singleton"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Scoped"),"    - mediator and handlers registered as scoped")))),(0,r.kt)("h2",{parentName:"admonition",id:"4-getting-started"},"4. Getting started"),(0,r.kt)("p",{parentName:"admonition"},"In this section we will get started with Mediator and go through a sample\nillustrating the various ways the Mediator pattern can be used in an application."),(0,r.kt)("p",{parentName:"admonition"},"See the full runnable sample code in the SimpleEndToEnd sample."),(0,r.kt)("h3",{parentName:"admonition",id:"41-add-package"},"4.1. Add package"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-pwsh"},"dotnet add package Mediator.SourceGenerator --version 2.0.*\ndotnet add package Mediator.Abstractions --version 2.0.*\n")),(0,r.kt)("p",{parentName:"admonition"},"or"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<PackageReference Include="Mediator.SourceGenerator" Version="2.0.*">\n  <PrivateAssets>all</PrivateAssets>\n  <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>\n</PackageReference>\n<PackageReference Include="Mediator.Abstractions" Version="2.0.*" />\n')),(0,r.kt)("h3",{parentName:"admonition",id:"42-add-mediator-to-di-container"},"4.2. Add Mediator to DI container"),(0,r.kt)("p",{parentName:"admonition"},"In ",(0,r.kt)("inlineCode",{parentName:"p"},"ConfigureServices")," or equivalent, call ",(0,r.kt)("inlineCode",{parentName:"p"},"AddMediator")," (unless ",(0,r.kt)("inlineCode",{parentName:"p"},"MediatorOptions")," is configured, default namespace is ",(0,r.kt)("inlineCode",{parentName:"p"},"Mediator"),").\nThis registers your handler below."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using Mediator;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\n\nvar services = new ServiceCollection(); // Most likely IServiceCollection comes from IHostBuilder/Generic host abstraction in Microsoft.Extensions.Hosting\n\nservices.AddMediator();\nvar serviceProvider = services.BuildServiceProvider();\n")),(0,r.kt)("h3",{parentName:"admonition",id:"43-create-irequest-type"},"4.3. Create ",(0,r.kt)("inlineCode",{parentName:"h3"},"IRequest<>")," type"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"var mediator = serviceProvider.GetRequiredService<IMediator>();\nvar ping = new Ping(Guid.NewGuid());\nvar pong = await mediator.Send(ping);\nDebug.Assert(ping.Id == pong.Id);\n\n// ...\n\npublic sealed record Ping(Guid Id) : IRequest<Pong>;\n\npublic sealed record Pong(Guid Id);\n\npublic sealed class PingHandler : IRequestHandler<Ping, Pong>\n{\n    public ValueTask<Pong> Handle(Ping request, CancellationToken cancellationToken)\n    {\n        return new ValueTask<Pong>(new Pong(request.Id));\n    }\n}\n")),(0,r.kt)("p",{parentName:"admonition"},"As soon as you code up message types, the source generator will add DI registrations automatically (inside ",(0,r.kt)("inlineCode",{parentName:"p"},"AddMediator"),").\nP.S - You can inspect the code yourself - open ",(0,r.kt)("inlineCode",{parentName:"p"},"Mediator.g.cs")," in VS from Project -> Dependencies -> Analyzers -> Mediator.SourceGenerator -> Mediator.SourceGenerator.MediatorGenerator,\nor just F12 through the code."),(0,r.kt)("h3",{parentName:"admonition",id:"44-use-pipeline-behaviors"},"4.4. Use pipeline behaviors"),(0,r.kt)("p",{parentName:"admonition"},"The pipeline behavior below validates all incoming ",(0,r.kt)("inlineCode",{parentName:"p"},"Ping")," messages.\nPipeline behaviors currently must be added manually."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'services.AddMediator();\nservices.AddSingleton<IPipelineBehavior<Ping, Pong>, PingValidator>();\n\npublic sealed class PingValidator : IPipelineBehavior<Ping, Pong>\n{\n    public ValueTask<Pong> Handle(Ping request, MessageHandlerDelegate<Ping, Pong> next, CancellationToken cancellationToken)\n    {\n        if (request is null || request.Id == default)\n            throw new ArgumentException("Invalid input");\n\n        return next(request, cancellationToken);\n    }\n}\n')),(0,r.kt)("h3",{parentName:"admonition",id:"45-constrain-ipipelinebehavior-message-with-open-generics"},"4.5. Constrain ",(0,r.kt)("inlineCode",{parentName:"h3"},"IPipelineBehavior<,>")," message with open generics"),(0,r.kt)("p",{parentName:"admonition"},"Add open generic handler to process all or a subset of messages passing through Mediator.\nThis handler will log any error that is thrown from message handlers (",(0,r.kt)("inlineCode",{parentName:"p"},"IRequest"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ICommand"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"IQuery"),").\nIt also publishes a notification allowing notification handlers to react to errors.\nMessage pre- and post-processors along with the exception handlers can also constrain the generic type parameters in the same way."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'services.AddMediator();\nservices.AddSingleton(typeof(IPipelineBehavior<,>), typeof(ErrorLoggerHandler<,>));\n\npublic sealed record ErrorMessage(Exception Exception) : INotification;\npublic sealed record SuccessfulMessage() : INotification;\n\npublic sealed class ErrorLoggerHandler<TMessage, TResponse> : IPipelineBehavior<TMessage, TResponse>\n    where TMessage : IMessage // Constrained to IMessage, or constrain to IBaseCommand or any custom interface you\'ve implemented\n{\n    private readonly ILogger<ErrorLoggerHandler<TMessage, TResponse>> _logger;\n    private readonly IMediator _mediator;\n\n    public ErrorLoggerHandler(ILogger<ErrorLoggerHandler<TMessage, TResponse>> logger, IMediator mediator)\n    {\n        _logger = logger;\n        _mediator = mediator;\n    }\n\n    public async ValueTask<TResponse> Handle(TMessage message, MessageHandlerDelegate<TMessage, TResponse> next, CancellationToken cancellationToken)\n    {\n        try\n        {\n            var response = await next(message, cancellationToken);\n            return response;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, "Error handling message");\n            await _mediator.Publish(new ErrorMessage(ex));\n            throw;\n        }\n    }\n}\n')),(0,r.kt)("h3",{parentName:"admonition",id:"46-use-notifications"},"4.6. Use notifications"),(0,r.kt)("p",{parentName:"admonition"},"We can define a notification handler to catch errors from the above pipeline behavior."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// Notification handlers are automatically added to DI container\n\npublic sealed class ErrorNotificationHandler : INotificationHandler<ErrorMessage>\n{\n    public ValueTask Handle(ErrorMessage error, CancellationToken cancellationToken)\n    {\n        // Could log to application insights or something...\n        return default;\n    }\n}\n")),(0,r.kt)("h3",{parentName:"admonition",id:"47-polymorphic-dispatch-with-notification-handlers"},"4.7. Polymorphic dispatch with notification handlers"),(0,r.kt)("p",{parentName:"admonition"},"We can also define a notification handler that receives all notifications."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"\npublic sealed class StatsNotificationHandler : INotificationHandler<INotification> // or any other interface deriving from INotification\n{\n    private long _messageCount;\n    private long _messageErrorCount;\n\n    public (long MessageCount, long MessageErrorCount) Stats => (_messageCount, _messageErrorCount);\n\n    public ValueTask Handle(INotification notification, CancellationToken cancellationToken)\n    {\n        Interlocked.Increment(ref _messageCount);\n        if (notification is ErrorMessage)\n            Interlocked.Increment(ref _messageErrorCount);\n        return default;\n    }\n}\n")),(0,r.kt)("h3",{parentName:"admonition",id:"48-notification-handlers-also-support-open-generics"},"4.8. Notification handlers also support open generics"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public sealed class GenericNotificationHandler<TNotification> : INotificationHandler<TNotification>\n    where TNotification : INotification // Generic notification handlers will be registered as open constrained types automatically\n{\n    public ValueTask Handle(TNotification notification, CancellationToken cancellationToken)\n    {\n        return default;\n    }\n}\n")),(0,r.kt)("h3",{parentName:"admonition",id:"49-use-streaming-messages"},"4.9. Use streaming messages"),(0,r.kt)("p",{parentName:"admonition"},"Since version 1.* of this library there is support for streaming using ",(0,r.kt)("inlineCode",{parentName:"p"},"IAsyncEnumerable"),"."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var mediator = serviceProvider.GetRequiredService<IMediator>();\n\nvar ping = new StreamPing(Guid.NewGuid());\n\nawait foreach (var pong in mediator.CreateStream(ping))\n{\n    Debug.Assert(ping.Id == pong.Id);\n    Console.WriteLine("Received pong!"); // Should log 5 times\n}\n\n// ...\n\npublic sealed record StreamPing(Guid Id) : IStreamRequest<Pong>;\n\npublic sealed record Pong(Guid Id);\n\npublic sealed class PingHandler : IStreamRequestHandler<StreamPing, Pong>\n{\n    public async IAsyncEnumerable<Pong> Handle(StreamPing request, [EnumeratorCancellation] CancellationToken cancellationToken)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            await Task.Delay(1000, cancellationToken);\n            yield return new Pong(request.Id);\n        }\n    }\n}\n')),(0,r.kt)("h2",{parentName:"admonition",id:"5-diagnostics"},"5. Diagnostics"),(0,r.kt)("p",{parentName:"admonition"},"Since this is a source generator, diagnostics are also included. Examples below"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Missing request handler")),(0,r.kt)("p",{parentName:"admonition"},"Missing request handler"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Multiple request handlers found")),(0,r.kt)("p",{parentName:"admonition"},"Multiple request handlers found"),(0,r.kt)("h2",{parentName:"admonition",id:"6-differences-from-mediatr"},"6. Differences from ",(0,r.kt)("a",{parentName:"h2",href:"https://github.com/jbogard/MediatR"},"MediatR")),(0,r.kt)("p",{parentName:"admonition"},"This is a work in progress list on the differences between this library and MediatR."),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RequestHandlerDelegate<TResponse>()")," -> ",(0,r.kt)("inlineCode",{parentName:"li"},"MessageHandlerDelegate<TMessage, TResponse>(TMessage message, CancellationToken cancellationToken)"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This is to avoid excessive closure allocations. I thin it's worthwhile when the cost is simply passing along the message and the cancellationtoken."))),(0,r.kt)("li",{parentName:"ul"},"No ",(0,r.kt)("inlineCode",{parentName:"li"},"ServiceFactory"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This library relies on the ",(0,r.kt)("inlineCode",{parentName:"li"},"Microsoft.Extensions.DependencyInjection"),", so it only works with DI containers that integrate with those abstractions."))),(0,r.kt)("li",{parentName:"ul"},"Singleton service lifetime by default",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"MediatR in combination with ",(0,r.kt)("inlineCode",{parentName:"li"},"MediatR.Extensions.Microsoft.DependencyInjection")," does transient service registration by default, which leads to a lot of allocations. Even if it is configured for singleton lifetime, ",(0,r.kt)("inlineCode",{parentName:"li"},"IMediator")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"ServiceFactory")," services are registered as transient (not configurable)."))),(0,r.kt)("li",{parentName:"ul"},"Methods return ",(0,r.kt)("inlineCode",{parentName:"li"},"ValueTask<T>")," instead of ",(0,r.kt)("inlineCode",{parentName:"li"},"Task<T>"),", to allow for fewer allocations (for example if the handler completes synchronously, or using async method builder pooling/",(0,r.kt)("inlineCode",{parentName:"li"},"PoolingAsyncValueTaskMethodBuilder<T>"),")"),(0,r.kt)("li",{parentName:"ul"},"This library doesn't support generic requests/notifications"))),(0,r.kt)("h3",{id:"about"},"About"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Gnerating mediator data without reflection")),(0,r.kt)("h2",{id:"how-to-use"},"How to use"),(0,r.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,r.kt)("p",null,"This is the CSharp Project that references ",(0,r.kt)("strong",{parentName:"p"},"Mediator")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {15}",showLineNumbers:!0,"{15}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net7.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n    <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n    <ItemGroup>\n        <PackageReference Include="Mediator.Abstractions" Version="2.1.5" />\n        <PackageReference Include="Mediator.SourceGenerator" Version="2.1.5" OutputItemType="Analyzer">\n          <PrivateAssets>all</PrivateAssets>\n          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n        </PackageReference>\n        <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="7.0.0" />\n        \n    </ItemGroup>\n\n</Project>\n\n'))),(0,r.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"Mediator")," in ",(0,r.kt)("em",{parentName:"p"},"Program.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'Console.WriteLine("Hello, World!");\nvar services = new ServiceCollection();\nservices.AddMediator();\nservices.AddSingleton(typeof(IPipelineBehavior<,>), typeof(GenericLoggerHandler<,>)); // This will run 1st\n\nvar serviceProvider = services.BuildServiceProvider();\n\nvar mediator = serviceProvider.GetRequiredService<IMediator>();\nvar id = Guid.NewGuid();\nvar request = new Ping(id);\n\nvar response = await mediator.Send(request);\n\nConsole.WriteLine("-----------------------------------");\nConsole.WriteLine("ID: " + id);\nConsole.WriteLine(request);\nConsole.WriteLine(response);\n\n\n'))),(0,r.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\GenericLoggerHandler.cs",label:"GenericLoggerHandler.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"Mediator")," in ",(0,r.kt)("em",{parentName:"p"},"GenericLoggerHandler.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'public sealed class GenericLoggerHandler<TMessage, TResponse> : IPipelineBehavior<TMessage, TResponse>\n    where TMessage : IMessage\n{\n    public async ValueTask<TResponse> Handle(TMessage message, CancellationToken cancellationToken, MessageHandlerDelegate<TMessage, TResponse> next)    \n    {\n        Console.WriteLine("1) Running logger handler");\n        try\n        {\n            var response = await next(message, cancellationToken);\n            Console.WriteLine("5) No error!");\n            return response;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine("error:"+ex.Message);\n            throw;\n        }\n    }\n\n}\n'))),(0,r.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\PingPong.cs",label:"PingPong.cs",mdxType:"TabItem"},(0,r.kt)("p",null,"  This is the use of ",(0,r.kt)("strong",{parentName:"p"},"Mediator")," in ",(0,r.kt)("em",{parentName:"p"},"PingPong.cs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'\npublic sealed record Ping(Guid Id) : IRequest<Pong>;\n\npublic sealed record Pong(Guid Id);\n\n\npublic sealed class PingHandler : IRequestHandler<Ping, Pong>\n{\n    public ValueTask<Pong> Handle(Ping request, CancellationToken cancellationToken)\n    {\n        Console.WriteLine("4) Returning pong!");\n        return new ValueTask<Pong>(new Pong(request.Id));\n    }\n}\n\n')))),(0,r.kt)("h3",{id:"generated-files"},"Generated Files"),(0,r.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\obj\\GX\\Mediator.SourceGenerator.Roslyn40\\Mediator.SourceGenerator.IncrementalMediatorGenerator\\Mediator.g.cs",label:"Mediator.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated>\n//     Generated by the Mediator source generator.\n// </auto-generated>\n\n#pragma warning disable CS8019 // Unused usings\n#pragma warning disable CS8321 // Unused local function\n#pragma warning disable CS1998 // Async method lacks \'await\' operators and will run synchronously\n\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.DependencyInjection.Extensions;\nusing System.Linq;\n\nusing SD = global::Microsoft.Extensions.DependencyInjection.ServiceDescriptor;\n\nnamespace Microsoft.Extensions.DependencyInjection\n{\n    /// <summary>\n    /// DI extensions for Mediator.\n    /// </summary>\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    public static class MediatorDependencyInjectionExtensions\n    {\n        /// <summary>\n        /// Adds the Mediator implementation and handlers of your application.\n        /// </summary>\n        public static IServiceCollection AddMediator(this IServiceCollection services)\n        {\n            return AddMediator(services, null);\n        }\n\n        internal sealed class Dummy { }\n\n        /// <summary>\n        /// Adds the Mediator implementation and handlers of your application, with specified options.\n        /// </summary>\n        public static IServiceCollection AddMediator(this IServiceCollection services, global::System.Action<global::Mediator.MediatorOptions> options)\n        {\n            var opts = new global::Mediator.MediatorOptions();\n            if (options != null)\n                options(opts);\n\n            var configuredViaAttribute = false;\n            if (opts.ServiceLifetime != global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton && !configuredViaAttribute)\n            {\n                var errMsg = "Invalid configuration detected for Mediator. ";\n                errMsg += "Generated code for \'Singleton\' lifetime, but got \'" + opts.ServiceLifetime + "\' lifetime from options. ";\n                errMsg += "This means that the source generator hasn\'t seen the \'AddMediator\' method call during compilation. ";\n                errMsg += "Make sure that the \'AddMediator\' method is called from the project that references the Mediator.SourceGenerator package.";\n                throw new global::System.Exception(errMsg);\n            }\n\n\n            services.Add(new SD(typeof(global::Mediator.Mediator), typeof(global::Mediator.Mediator), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton));\n            services.TryAdd(new SD(typeof(global::Mediator.IMediator), sp => sp.GetRequiredService<global::Mediator.Mediator>(), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton));\n            services.TryAdd(new SD(typeof(global::Mediator.ISender), sp => sp.GetRequiredService<global::Mediator.Mediator>(), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton));\n            services.TryAdd(new SD(typeof(global::Mediator.IPublisher), sp => sp.GetRequiredService<global::Mediator.Mediator>(), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton));\n\n            services.TryAdd(new SD(typeof(global::PingHandler), typeof(global::PingHandler), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton));\n            services.Add(new SD(\n                typeof(global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong>),\n                sp =>\n                {\n                    return new global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong>(\n                        sp.GetRequiredService<global::PingHandler>(),\n                        sp.GetServices<global::Mediator.IPipelineBehavior<global::Ping, global::Pong>>()\n                    );\n                },\n                global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton\n            ));\n\n\n\n\n            services.AddSingleton<Dummy>();\n\n            return services;\n\n        }\n    }\n}\n\nnamespace Mediator\n{\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class RequestClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.IRequest<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public RequestClassHandlerWrapper(\n            global::Mediator.IRequestHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class RequestStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.IRequest<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public RequestStructHandlerWrapper(\n            global::Mediator.IRequestHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamRequestClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.IStreamRequest<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamRequestClassHandlerWrapper(\n            global::Mediator.IStreamRequestHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamRequestStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.IStreamRequest<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamRequestStructHandlerWrapper(\n            global::Mediator.IStreamRequestHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class CommandClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.ICommand<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public CommandClassHandlerWrapper(\n            global::Mediator.ICommandHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class CommandStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.ICommand<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public CommandStructHandlerWrapper(\n            global::Mediator.ICommandHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamCommandClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.IStreamCommand<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamCommandClassHandlerWrapper(\n            global::Mediator.IStreamCommandHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamCommandStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.IStreamCommand<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamCommandStructHandlerWrapper(\n            global::Mediator.IStreamCommandHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class QueryClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.IQuery<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public QueryClassHandlerWrapper(\n            global::Mediator.IQueryHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class QueryStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.IQuery<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public QueryStructHandlerWrapper(\n            global::Mediator.IQueryHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamQueryClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.IStreamQuery<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamQueryClassHandlerWrapper(\n            global::Mediator.IStreamQueryHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamQueryStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.IStreamQuery<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamQueryStructHandlerWrapper(\n            global::Mediator.IStreamQueryHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n\n    /// <summary>\n    /// Generated code for Mediator implementation.\n    /// This type is also registered as a DI service.\n    /// Can be used directly for high performance scenarios.\n    /// </summary>\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    public sealed partial class Mediator : global::Mediator.IMediator, global::Mediator.ISender, global::Mediator.IPublisher\n    {\n        private readonly global::System.IServiceProvider _sp;\n        private FastLazyValue<DICache> _diCacheLazy;\n\n        /// <summary>\n        /// The lifetime of Mediator-related service registrations in DI container.\n        /// </summary>\n        public static global::Microsoft.Extensions.DependencyInjection.ServiceLifetime ServiceLifetime { get; } = global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton;\n\n        private readonly global::System.Func<global::System.Collections.Generic.IEnumerable<object>, int> _getServicesLength;\n\n        /// <summary>\n        /// Constructor for DI, should not be used by consumer.\n        /// </summary>\n        public Mediator(global::System.IServiceProvider sp)\n        {\n            _sp = sp;\n            _diCacheLazy = new FastLazyValue<DICache>(() => new DICache(_sp));\n\n            global::System.Func<global::System.Collections.Generic.IEnumerable<object>, int> fastGetLength = s => ((object[])s).Length;\n            global::System.Func<global::System.Collections.Generic.IEnumerable<object>, int> slowGetLength = s => s.Count();\n\n            var dummy = sp.GetServices<global::Microsoft.Extensions.DependencyInjection.MediatorDependencyInjectionExtensions.Dummy>();\n            _getServicesLength = dummy.GetType() == typeof(global::Microsoft.Extensions.DependencyInjection.MediatorDependencyInjectionExtensions.Dummy[])\n                 ? fastGetLength : slowGetLength;\n        }\n\n        private struct FastLazyValue<T>\n            where T : struct\n        {\n            private const long UNINIT = 0;\n            private const long INITING = 1;\n            private const long INITD = 2;\n            \n            \n\n            private global::System.Func<T> _generator;\n            private long _state;\n            private T _value;\n\n            public T Value\n            {\n                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]\n                get\n                {\n                    if (_state != INITD)\n                        return ValueSlow;\n\n                    return _value;\n                }\n            }\n\n            private T ValueSlow\n            {\n                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\n                get\n                {\n                    var prevState = global::System.Threading.Interlocked.CompareExchange(ref _state, INITING, UNINIT);\n                    switch (prevState)\n                    {\n                        case INITD:\n                            // Someone has already completed init\n                            return _value;\n                        case INITING:\n                            // Wait for someone else to complete\n                            var spinWait = default(global::System.Threading.SpinWait);\n                            while (global::System.Threading.Interlocked.Read(ref _state) < INITD)\n                                spinWait.SpinOnce();\n                            return _value;\n                        case UNINIT:\n                            _value = _generator();\n                            global::System.Threading.Interlocked.Exchange(ref _state, INITD);\n                            return _value;\n                    }\n\n                    return _value;\n                }\n            }\n\n\n            public FastLazyValue(global::System.Func<T> generator)\n            {\n                _generator = generator;\n                _state = UNINIT;\n                _value = default;\n            }\n        }\n\n                private readonly struct DICache\n        {\n            private readonly global::System.IServiceProvider _sp;\n\n            public readonly global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong> Wrapper_For_Ping;\n\n            public DICache(global::System.IServiceProvider sp)\n            {\n                _sp = sp;\n\n                Wrapper_For_Ping = sp.GetRequiredService<global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong>>();\n            }\n        }\n\n        /// <summary>\n        /// Send a message of type global::Ping.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// </summary>\n        /// <param name="message">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask<global::Pong> Send(\n            global::Ping message,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowIfNull(message, nameof(message));\n            \n            return _diCacheLazy.Value.Wrapper_For_Ping.Handle(message, cancellationToken);\n        }\n\n        /// <summary>\n        /// Send request.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="request">Incoming request</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(\n            global::Mediator.IRequest<TResponse> request,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            switch (request)\n            {\n                case global::Ping r:\n                {\n                    if(typeof(TResponse) == typeof(global::Pong))\n                    {\n                        var task = Send(r, cancellationToken);\n                        return global::System.Runtime.CompilerServices.Unsafe.As<global::System.Threading.Tasks.ValueTask<global::Pong>, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);\n                    }\n                    else\n                    {\n                        return SendAsync(request, cancellationToken);\n                    }\n                }\n                default:\n                {\n                    ThrowArgumentNullOrInvalidMessage(request, nameof(request));\n                    return default;\n                }\n            }\n            \n        }\n\n        /// <summary>\n        /// Send request.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="request">Incoming request</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        private async global::System.Threading.Tasks.ValueTask<TResponse> SendAsync<TResponse>(\n            global::Mediator.IRequest<TResponse> request,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            switch (request)\n            {\n                case global::Ping r:\n                {\n                    var response = await Send(r, cancellationToken);\n                    return global::System.Runtime.CompilerServices.Unsafe.As<global::Pong, TResponse>(ref response);\n                }\n                default:\n                {\n                    ThrowArgumentNullOrInvalidMessage(request, nameof(request));\n                    return default;\n                }\n            }\n            \n        }\n\n        /// <summary>\n        /// Create stream for request.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="request">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Async enumerable</returns>\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(\n            global::Mediator.IStreamRequest<TResponse> request,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(request);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Send command.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="command">Incoming command</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(\n            global::Mediator.ICommand<TResponse> command,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(command);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Send command.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="command">Incoming command</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        private async global::System.Threading.Tasks.ValueTask<TResponse> SendAsync<TResponse>(\n            global::Mediator.ICommand<TResponse> command,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(command);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Create stream for command.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="command">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Async enumerable</returns>\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(\n            global::Mediator.IStreamCommand<TResponse> command,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(command);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Send query.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="query">Incoming query</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(\n            global::Mediator.IQuery<TResponse> query,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(query);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Send query.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="query">Incoming query</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        private async global::System.Threading.Tasks.ValueTask<TResponse> SendAsync<TResponse>(\n            global::Mediator.IQuery<TResponse> query,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(query);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Create stream for query.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="query">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Async enumerable</returns>\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(\n            global::Mediator.IStreamQuery<TResponse> query,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(query);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Send message.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="message">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public async global::System.Threading.Tasks.ValueTask<object> Send(\n            object message,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            switch (message)\n            {\n                case global::Ping m: return await Send(m, cancellationToken);\n                default:\n                {\n                    ThrowArgumentNullOrInvalidMessage(message as global::Mediator.IMessage, nameof(message));\n                    return default;\n                }\n            }\n            \n        }\n\n        /// <summary>\n        /// Create stream.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="message">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Async enumerable</returns>\n        public global::System.Collections.Generic.IAsyncEnumerable<object> CreateStream(\n            object message,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(message as global::Mediator.IStreamMessage);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Publish notification.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// </summary>\n        /// <param name="notification">Incoming notification</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask Publish(\n            object notification,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            return default;\n            \n        }\n\n\n        /// <summary>\n        /// Publish notification.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// </summary>\n        /// <param name="notification">Incoming notification</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask Publish<TNotification>(\n            TNotification notification,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n            where TNotification : global::Mediator.INotification\n        {\n            return default;\n            \n        }\n\n        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        private static void ThrowInvalidMessage(object msg) =>\n            throw new global::Mediator.MissingMessageHandlerException(msg);\n\n        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        private static void ThrowArgumentNull(string paramName) =>\n            throw new global::System.ArgumentNullException(paramName);\n\n        private static void ThrowIfNull<T>(T argument, string paramName)\n        {\n            if (argument is null)\n            {\n                ThrowArgumentNull(paramName);\n            }\n        }\n\n        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        private static void ThrowArgumentNullOrInvalidMessage(object msg, string paramName)\n        {\n            if (msg is null)\n            {\n                ThrowArgumentNull(paramName);\n            }\n            else\n            {\n                ThrowInvalidMessage(msg);\n            }\n        }\n\n        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        private static void ThrowAggregateException(global::System.Collections.Generic.List<global::System.Exception> exceptions) =>\n            throw new global::System.AggregateException(exceptions);\n\n        private static void MaybeThrowAggregateException(global::System.Collections.Generic.List<global::System.Exception> exceptions)\n        {\n            if (exceptions != null)\n            {\n                ThrowAggregateException(exceptions);\n            }\n        }\n    }\n}\n\n'))),(0,r.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\obj\\GX\\Mediator.SourceGenerator.Roslyn40\\Mediator.SourceGenerator.IncrementalMediatorGenerator\\MediatorOptions.g.cs",label:"MediatorOptions.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated>\n//     Generated by the Mediator source generator.\n// </auto-generated>\n\nnamespace Mediator\n{\n    /// <summary>\n    /// Provide options for the Mediator source generator.\n    /// </summary>\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    public sealed class MediatorOptions\n    {\n        /// <summary>\n        /// The namespace in which the Mediator implementation is generated.\n        /// </summary>\n        public string Namespace { get; set; } = "Mediator";\n\n        /// <summary>\n        /// The default lifetime of the services registered in the DI container by\n        /// the Mediator source generator.\n        /// Singleton by default.\n        /// </summary>\n        public global::Microsoft.Extensions.DependencyInjection.ServiceLifetime ServiceLifetime { get; set; } =\n            global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton;\n    }\n}\n\n'))),(0,r.kt)(i.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\obj\\GX\\Mediator.SourceGenerator.Roslyn40\\Mediator.SourceGenerator.IncrementalMediatorGenerator\\MediatorOptionsAttribute.g.cs",label:"MediatorOptionsAttribute.g.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated>\n//     Generated by the Mediator source generator.\n// </auto-generated>\n\nnamespace Mediator\n{\n    /// <summary>\n    /// Provide options for the Mediator source generator.\n    /// </summary>\n    [global::System.AttributeUsage(global::System.AttributeTargets.Assembly, AllowMultiple = false)]\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    public sealed class MediatorOptionsAttribute : global::System.Attribute\n    {\n        /// <summary>\n        /// The namespace in which the Mediator implementation is generated.\n        /// </summary>\n        public string Namespace { get; set; } = "Mediator";\n\n        /// <summary>\n        /// The default lifetime of the services registered in the DI container by\n        /// the Mediator source generator.\n        /// Singleton by default.\n        /// </summary>\n        public global::Microsoft.Extensions.DependencyInjection.ServiceLifetime ServiceLifetime { get; set; } =\n            global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton;\n    }\n}\n\n')))),(0,r.kt)("h2",{id:"usefull"},"Usefull"),(0,r.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{target:"_blank",href:a(57545).Z},"Download Example project Mediator "))),(0,r.kt)("h3",{id:"share-mediator"},"Share Mediator"),(0,r.kt)("ul",null,(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator&quote=Mediator",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator&text=Mediator:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator&title=Mediator",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,r.kt)("li",null,(0,r.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator&title=Mediator&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/Mediator"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/Mediator")),(0,r.kt)("h2",{id:"in-the-same-category-enhancementproject"},"In the same category (EnhancementProject)"),(0,r.kt)("h3",{id:"buildinfo"},(0,r.kt)("a",{parentName:"h3",href:"/docs/BuildInfo"},"BuildInfo")),(0,r.kt)("h3",{id:"com"},(0,r.kt)("a",{parentName:"h3",href:"/docs/Com"},"Com")),(0,r.kt)("h3",{id:"commandline"},(0,r.kt)("a",{parentName:"h3",href:"/docs/CommandLine"},"CommandLine")),(0,r.kt)("h3",{id:"deedee"},(0,r.kt)("a",{parentName:"h3",href:"/docs/DeeDee"},"DeeDee")),(0,r.kt)("h3",{id:"plantumlclassdiagramgenerator"},(0,r.kt)("a",{parentName:"h3",href:"/docs/PlantUmlClassDiagramGenerator"},"PlantUmlClassDiagramGenerator")),(0,r.kt)("h3",{id:"rscg_ams"},(0,r.kt)("a",{parentName:"h3",href:"/docs/RSCG_AMS"},"RSCG_AMS")),(0,r.kt)("h3",{id:"rscg_functionswithdi"},(0,r.kt)("a",{parentName:"h3",href:"/docs/RSCG_FunctionsWithDI"},"RSCG_FunctionsWithDI")),(0,r.kt)("h3",{id:"rscg_timebombcomment"},(0,r.kt)("a",{parentName:"h3",href:"/docs/RSCG_TimeBombComment"},"RSCG_TimeBombComment")),(0,r.kt)("h3",{id:"sourcegeneratorhelpercopycode"},(0,r.kt)("a",{parentName:"h3",href:"/docs/SourceGenerator.Helper.CopyCode"},"SourceGenerator.Helper.CopyCode")),(0,r.kt)("h3",{id:"thisassembly"},(0,r.kt)("a",{parentName:"h3",href:"/docs/ThisAssembly"},"ThisAssembly")))}h.isMDXComponent=!0},57545:(e,n,a)=>{a.d(n,{Z:()=>t});const t=a.p+"assets/files/Mediator-eda32ba59c0664c33238b33b8e6fb5f8.zip"}}]);