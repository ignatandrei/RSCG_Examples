"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[948],{4421:(e,n,a)=>{a.d(n,{Ay:()=>o,RM:()=>i});var r=a(74848),s=a(28453);const i=[{value:"Category &quot;Mediator&quot; has the following generators:",id:"category-mediator-has-the-following-generators",level:3},{value:"See category",id:"see-category",level:3}];function t(e){const n={a:"a",h3:"h3",img:"img",p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h3,{id:"category-mediator-has-the-following-generators",children:'Category "Mediator" has the following generators:'}),"\n",(0,r.jsxs)(n.p,{children:["1 ",(0,r.jsx)(n.a,{href:"/docs/DeeDee",children:"DeeDee"})," ",(0,r.jsx)(n.a,{href:"https://www.nuget.org/packages/DeeDee/",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/nuget/dt/DeeDee?label=DeeDee",alt:"Nuget"})})," ",(0,r.jsx)(n.img,{src:"https://img.shields.io/github/stars/joh-pot/DeeDee?style=social",alt:"GitHub Repo stars"})," 2023-08-05"]}),"\n",(0,r.jsxs)(n.p,{children:["2 ",(0,r.jsx)(n.a,{href:"/docs/Immediate.Handlers",children:"Immediate.Handlers"})," ",(0,r.jsx)(n.a,{href:"https://www.nuget.org/packages/Immediate.Handlers/",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/nuget/dt/Immediate.Handlers?label=Immediate.Handlers",alt:"Nuget"})})," ",(0,r.jsx)(n.img,{src:"https://img.shields.io/github/stars/immediateplatform/Immediate.Handlers?style=social",alt:"GitHub Repo stars"})," 2024-09-20"]}),"\n",(0,r.jsxs)(n.p,{children:["3 ",(0,r.jsx)(n.a,{href:"/docs/Mediator",children:"Mediator"})," ",(0,r.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.SourceGenerator",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/nuget/dt/Mediator.SourceGenerator?label=Mediator.SourceGenerator",alt:"Nuget"})}),(0,r.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.Abstractions",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/nuget/dt/Mediator.Abstractions?label=Mediator.Abstractions",alt:"Nuget"})})," ",(0,r.jsx)(n.img,{src:"https://img.shields.io/github/stars/martinothamar/Mediator?style=social",alt:"GitHub Repo stars"})," 2023-08-02"]}),"\n",(0,r.jsx)(n.h3,{id:"see-category",children:"See category"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"/docs/Categories/Mediator",children:"Mediator"})})]})}function o(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}},16533:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>g,default:()=>m,frontMatter:()=>c,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"RSCG-Examples/Mediator","title":"32 - Mediator","description":"Gnerating mediator data without reflection","source":"@site/docs/RSCG-Examples/Mediator.md","sourceDirName":"RSCG-Examples","slug":"/Mediator","permalink":"/RSCG_Examples/v2/docs/Mediator","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":320,"frontMatter":{"sidebar_position":320,"title":"32 - Mediator","description":"Gnerating mediator data without reflection","slug":"/Mediator"},"sidebar":"tutorialSidebar","previous":{"title":"31 - MorrisMoxy","permalink":"/RSCG_Examples/v2/docs/MorrisMoxy"},"next":{"title":"33 - Matryoshki","permalink":"/RSCG_Examples/v2/docs/Matryoshki"}}');var s=a(74848),i=a(28453),t=a(11470),o=a(19365),l=a(14252),d=a(4421);const c={sidebar_position:320,title:"32 - Mediator",description:"Gnerating mediator data without reflection",slug:"/Mediator"},g="Mediator  by Martin Othamar",p={},h=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"2. Benchmarks",id:"2-benchmarks",level:2},{value:"3. Usage and abstractions",id:"3-usage-and-abstractions",level:2},{value:"3.1. Message types",id:"31-message-types",level:3},{value:"3.2. Handler types",id:"32-handler-types",level:3},{value:"3.3. Pipeline types",id:"33-pipeline-types",level:3},{value:"3.3.1. Message validation example",id:"331-message-validation-example",level:4},{value:"3.3.2. Error logging example",id:"332-error-logging-example",level:4},{value:"3.4. Configuration",id:"34-configuration",level:3},{value:"4. Getting started",id:"4-getting-started",level:2},{value:"4.1. Add package",id:"41-add-package",level:3},{value:"4.2. Add Mediator to DI container",id:"42-add-mediator-to-di-container",level:3},{value:"4.3. Create <code>IRequest&lt;&gt;</code> type",id:"43-create-irequest-type",level:3},{value:"4.4. Use pipeline behaviors",id:"44-use-pipeline-behaviors",level:3},{value:"4.5. Constrain <code>IPipelineBehavior&lt;,&gt;</code> message with open generics",id:"45-constrain-ipipelinebehavior-message-with-open-generics",level:3},{value:"4.6. Use notifications",id:"46-use-notifications",level:3},{value:"4.7. Polymorphic dispatch with notification handlers",id:"47-polymorphic-dispatch-with-notification-handlers",level:3},{value:"4.8. Notification handlers also support open generics",id:"48-notification-handlers-also-support-open-generics",level:3},{value:"4.9. Use streaming messages",id:"49-use-streaming-messages",level:3},{value:"5. Diagnostics",id:"5-diagnostics",level:2},{value:"6. Differences from MediatR",id:"6-differences-from-mediatr",level:2},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example (source csproj, source files)",id:"example-source-csproj-source-files",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C#)",id:"download-example-net--c",level:3},{value:"Share Mediator",id:"share-mediator",level:3},...d.RM];function u(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"mediator--by-martin-othamar",children:"Mediator  by Martin Othamar"})}),"\n",(0,s.jsx)(l.A,{toc:h}),"\n",(0,s.jsx)(n.h2,{id:"nuget--site-data",children:"NuGet / site data"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.SourceGenerator",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/nuget/dt/Mediator.SourceGenerator?label=Mediator.SourceGenerator",alt:"Nuget"})}),(0,s.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.Abstractions",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/nuget/dt/Mediator.Abstractions?label=Mediator.Abstractions",alt:"Nuget"})}),"\n",(0,s.jsx)(n.a,{href:"https://github.com/martinothamar/Mediator",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/github/last-commit/martinothamar/Mediator?label=updated",alt:"GitHub last commit"})}),"\n",(0,s.jsx)(n.img,{src:"https://img.shields.io/github/stars/martinothamar/Mediator?style=social",alt:"GitHub Repo stars"})]}),"\n",(0,s.jsx)(n.h2,{id:"details",children:"Details"}),"\n",(0,s.jsx)(n.h3,{id:"info",children:"Info"}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["Name: ",(0,s.jsx)(n.strong,{children:"Mediator"})]}),(0,s.jsx)(n.p,{children:"A high performance .NET Mediator pattern implemenation using source generation."}),(0,s.jsx)(n.p,{children:"Author: Martin Othamar"}),(0,s.jsxs)(n.p,{children:["NuGet:\n",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.SourceGenerator",children:"https://www.nuget.org/packages/Mediator.SourceGenerator"})})]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.Abstractions",children:"https://www.nuget.org/packages/Mediator.Abstractions"})})}),(0,s.jsxs)(n.p,{children:["You can find more details at ",(0,s.jsx)(n.a,{href:"https://github.com/martinothamar/Mediator",children:"https://github.com/martinothamar/Mediator"})]}),(0,s.jsxs)(n.p,{children:["Source: ",(0,s.jsx)(n.a,{href:"https://github.com/martinothamar/Mediator",children:"https://github.com/martinothamar/Mediator"})]})]}),"\n",(0,s.jsx)(n.h3,{id:"original-readme",children:"Original Readme"}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/martinothamar/Mediator/actions",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/github/actions/workflow/status/martinothamar/Mediator/build.yml?branch=main",alt:"GitHub Workflow Status"})}),"\n",(0,s.jsx)(n.a,{href:"https://github.com/martinothamar/Mediator/blob/main/LICENSE",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/github/license/martinothamar/Mediator?style=flat-square",alt:"GitHub"})}),"\n",(0,s.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.Abstractions/",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/nuget/dt/mediator.abstractions?style=flat-square",alt:"Downloads"})}),(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.Abstractions",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/nuget/v/Mediator.Abstractions?label=Mediator.Abstractions",alt:"Abstractions NuGet current"})}),"\n",(0,s.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.SourceGenerator",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/nuget/v/Mediator.SourceGenerator?label=Mediator.SourceGenerator",alt:"SourceGenerator NuGet current"})}),"\n",(0,s.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.Abstractions",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/nuget/vpre/Mediator.Abstractions?label=Mediator.Abstractions",alt:"Abstractions NuGet prerelease"})}),"\n",(0,s.jsx)(n.a,{href:"https://www.nuget.org/packages/Mediator.SourceGenerator",children:(0,s.jsx)(n.img,{src:"https://img.shields.io/nuget/vpre/Mediator.SourceGenerator?label=Mediator.SourceGenerator",alt:"SourceGenerator NuGet prerelease"})}),(0,s.jsx)("br",{})]}),(0,s.jsx)(n.h1,{id:"mediator",children:"Mediator"}),(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Note"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Version 3.0"})," is currently being developed. See status and provide feedback ",(0,s.jsx)(n.a,{href:"https://github.com/martinothamar/Mediator/issues/98",children:"here (#98)"})]}),"\n"]}),(0,s.jsxs)(n.p,{children:["This is a high performance .NET implementation of the Mediator pattern using the ",(0,s.jsx)(n.a,{href:"https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/",children:"source generators"})," feature introduced in .NET 5.\nThe API and usage is mostly based on the great ",(0,s.jsx)(n.a,{href:"https://github.com/jbogard/MediatR",children:"MediatR"})," library, with some deviations to allow for better performance.\nPackages are .NET Standard 2.1 compatible."]}),(0,s.jsx)(n.p,{children:'The mediator pattern is great for implementing cross cutting concern (logging, metrics, etc) and avoiding "fat" constructors due to lots of injected services.'}),(0,s.jsx)(n.p,{children:"Goals for this library"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["High performance","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Runtime performance can be the same for both runtime reflection and source generator based approaches, but it's easier to optimize in the latter case"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["AOT friendly","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"MS are investing time in various AOT scenarios, and for example iOS requirees AOT compilation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Build time errors instead of runtime errors","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The generator includes diagnostics, i.e. if a handler is not defined for a request, a warning is emitted"}),"\n"]}),"\n"]}),"\n"]}),(0,s.jsx)(n.p,{children:"In particular, source generators in this library is used to"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Generate code for DI registration"}),"\n",(0,s.jsxs)(n.li,{children:["Generate code for ",(0,s.jsx)(n.code,{children:"IMediator"})," implementation","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Request/Command/Query ",(0,s.jsx)(n.code,{children:"Send"})," methods are monomorphized (1 method per T), the generic ",(0,s.jsx)(n.code,{children:"ISender.Send"})," methods rely on these"]}),"\n",(0,s.jsxs)(n.li,{children:["You can use both ",(0,s.jsx)(n.code,{children:"IMediator"})," and ",(0,s.jsx)(n.code,{children:"Mediator"}),", the latter allows for better performance"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Generate diagnostics related messages and message handlers"}),"\n"]}),(0,s.jsxs)(n.p,{children:["See this great video by ",(0,s.jsx)(n.a,{href:"https://github.com/Elfocrash",children:"@Elfocrash / Nick Chapsas"}),", covering both similarities and differences between Mediator and MediatR"]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=aaFLtcf8cO4",children:(0,s.jsx)(n.img,{src:"https://img.youtube.com/vi/aaFLtcf8cO4/0.jpg",alt:"Using MediatR in .NET? Maybe replace it with this"})})}),(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#mediator",children:"Mediator"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#table-of-contents",children:"Table of Contents"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#2-benchmarks",children:"2. Benchmarks"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#3-usage-and-abstractions",children:"3. Usage and abstractions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#31-message-types",children:"3.1. Message types"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#32-handler-types",children:"3.2. Handler types"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#33-pipeline-types",children:"3.3. Pipeline types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#331-message-validation-example",children:"3.3.1. Message validation example"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#332-error-logging-example",children:"3.3.2. Error logging example"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#34-configuration",children:"3.4. Configuration"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#4-getting-started",children:"4. Getting started"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#41-add-package",children:"4.1. Add package"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#42-add-mediator-to-di-container",children:"4.2. Add Mediator to DI container"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"#43-create-irequest-type",children:["4.3. Create ",(0,s.jsx)(n.code,{children:"IRequest<>"})," type"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#44-use-pipeline-behaviors",children:"4.4. Use pipeline behaviors"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"#45-constrain-ipipelinebehavior-message-with-open-generics",children:["4.5. Constrain ",(0,s.jsx)(n.code,{children:"IPipelineBehavior<,>"})," message with open generics"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#46-use-notifications",children:"4.6. Use notifications"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#47-polymorphic-dispatch-with-notification-handlers",children:"4.7. Polymorphic dispatch with notification handlers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#48-notification-handlers-also-support-open-generics",children:"4.8. Notification handlers also support open generics"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#49-use-streaming-messages",children:"4.9. Use streaming messages"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#5-diagnostics",children:"5. Diagnostics"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#6-differences-from-mediatr",children:"6. Differences from MediatR"})}),"\n"]}),"\n"]}),"\n"]}),(0,s.jsx)(n.h2,{id:"2-benchmarks",children:"2. Benchmarks"}),(0,s.jsxs)(n.p,{children:["This benchmark exposes the perf overhead of the libraries.\nMediator (this library) and MediatR methods show the overhead of the respective mediator implementations.\nI've also included the ",(0,s.jsx)(n.a,{href:"https://github.com/Cysharp/MessagePipe",children:"MessagePipe"})," library as it also has great performance."]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<SendRequest | Stream>_Baseline"}),": simple method call into the handler class"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<SendRequest | Stream>_Mediator"}),": the concrete ",(0,s.jsx)(n.code,{children:"Mediator"})," class generated by this library"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<SendRequest | Stream>_MessagePipe"}),": the ",(0,s.jsx)(n.a,{href:"https://github.com/Cysharp/MessagePipe",children:"MessagePipe"})," library"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<SendRequest | Stream>_IMediator"}),": call through the ",(0,s.jsx)(n.code,{children:"IMediator"})," interface in this library"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<SendRequest | Stream>_MediatR"}),": the ",(0,s.jsx)(n.a,{href:"https://github.com/jbogard/MediatR",children:"MediatR"})," library"]}),"\n"]}),(0,s.jsx)(n.p,{children:"See benchmarks code for more details on the measurement."}),(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Warning"})}),"\n",(0,s.jsxs)(n.p,{children:["A current limitation of this library is that performance degrades significantly for projects with a large number of messages (>500)\nThere is ongoing work on resolving this for version 3.0 (",(0,s.jsx)(n.a,{href:"https://github.com/martinothamar/Mediator/issues/48",children:"#48"}),")."]}),"\n"]}),(0,s.jsx)(n.h2,{id:"3-usage-and-abstractions",children:"3. Usage and abstractions"}),(0,s.jsx)(n.p,{children:"There are two NuGet packages needed to use this library"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Mediator.SourceGenerator","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["To generate the ",(0,s.jsx)(n.code,{children:"IMediator"})," implementation and dependency injection setup."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Mediator.Abstractions","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Message types (",(0,s.jsx)(n.code,{children:"IRequest<,>"}),", ",(0,s.jsx)(n.code,{children:"INotification"}),"), handler types (",(0,s.jsx)(n.code,{children:"IRequestHandler<,>"}),", ",(0,s.jsx)(n.code,{children:"INotificationHandler<>"}),"), pipeline types (",(0,s.jsx)(n.code,{children:"IPipelineBehavior"}),")"]}),"\n"]}),"\n"]}),"\n"]}),(0,s.jsxs)(n.p,{children:["You install the source generator package into your edge/outermost project (i.e. ASP.NET Core application, Background worker project),\nand then use the ",(0,s.jsx)(n.code,{children:"Mediator.Abstractions"})," package wherever you define message types and handlers.\nStandard message handlers are automatically picked up and added to the DI container in the generated ",(0,s.jsx)(n.code,{children:"AddMediator"})," method.\n",(0,s.jsx)(n.em,{children:"Pipeline behaviors need to be added manually (including pre/post/exception behaviors)."})]}),(0,s.jsx)(n.p,{children:"For example implementations, see the samples folder.\nSee the ASP.NET Core clean architecture sample for a more real world setup."}),(0,s.jsx)(n.h3,{id:"31-message-types",children:"3.1. Message types"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IMessage"})," - marker interface"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IStreamMessage"})," - marker interface"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IBaseRequest"})," - marker interface for requests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IRequest"})," - a request message, no return value (",(0,s.jsx)(n.code,{children:"ValueTask<Unit>"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IRequest<out TResponse>"})," - a request message with a response (",(0,s.jsx)(n.code,{children:"ValueTask<TResponse>"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IStreamRequest<out TResponse>"})," - a request message with a streaming response (",(0,s.jsx)(n.code,{children:"IAsyncEnumerable<TResponse>"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IBaseCommand"})," - marker interface for commands"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ICommand"})," - a command message, no return value (",(0,s.jsx)(n.code,{children:"ValueTask<Unit>"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ICommand<out TResponse>"})," - a command message with a response (",(0,s.jsx)(n.code,{children:"ValueTask<TResponse>"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IStreamCommand<out TResponse>"})," - a command message with a streaming response (",(0,s.jsx)(n.code,{children:"IAsyncEnumerable<TResponse>"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IBaseQuery"})," - marker interface for queries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IQuery<out TResponse>"})," - a query message with a response (",(0,s.jsx)(n.code,{children:"ValueTask<TResponse>"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IStreamQuery<out TResponse>"})," - a query message with a streaming response (",(0,s.jsx)(n.code,{children:"IAsyncEnumerable<TResponse>"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"INotification"})," - a notification message, no return value (",(0,s.jsx)(n.code,{children:"ValueTask"}),")"]}),"\n"]}),(0,s.jsx)(n.p,{children:"As you can see, you can achieve the exact same thing with requests, commands and queries. But I find the distinction in naming useful if you for example use the CQRS pattern or for some reason have a preference on naming in your application."}),(0,s.jsx)(n.h3,{id:"32-handler-types",children:"3.2. Handler types"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IRequestHandler<in TRequest>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IRequestHandler<in TRequest, TResponse>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IStreamRequestHandler<in TRequest, out TResponse>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ICommandHandler<in TCommand>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ICommandHandler<in TCommand, TResponse>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IStreamCommandHandler<in TCommand, out TResponse>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IQueryHandler<in TQuery, TResponse>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IStreamQueryHandler<in TQuery, out TResponse>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"INotificationHandler<in TNotification>"})}),"\n"]}),(0,s.jsx)(n.p,{children:"These types are used in correlation with the message types above."}),(0,s.jsx)(n.h3,{id:"33-pipeline-types",children:"3.3. Pipeline types"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IPipelineBehavior<TMessage, TResponse>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"IStreamPipelineBehavior<TMessage, TResponse>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"MessagePreProcessor<TMessage, TResponse>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"MessagePostProcessor<TMessage, TResponse>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"MessageExceptionHandler<TMessage, TResponse, TException>"})}),"\n"]}),(0,s.jsx)(n.h4,{id:"331-message-validation-example",children:"3.3.1. Message validation example"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// As a normal pipeline behavior\npublic sealed class MessageValidatorBehaviour<TMessage, TResponse> : IPipelineBehavior<TMessage, TResponse>\n    where TMessage : IValidate\n{\n    public ValueTask<TResponse> Handle(\n        TMessage message,\n        CancellationToken cancellationToken,\n        MessageHandlerDelegate<TMessage, TResponse> next\n    )\n    {\n        if (!message.IsValid(out var validationError))\n            throw new ValidationException(validationError);\n\n        return next(message, cancellationToken);\n    }\n}\n\n// Or as a pre-processor\npublic sealed class MessageValidatorBehaviour<TMessage, TResponse> : MessagePreProcessor<TMessage, TResponse>\n    where TMessage : IValidate\n{\n    protected override ValueTask Handle(TMessage message, CancellationToken cancellationToken)\n    {\n        if (!message.IsValid(out var validationError))\n            throw new ValidationException(validationError);\n\n        return default;\n    }\n}\n\n// Register as IPipelineBehavior<,> in either case\nservices.AddSingleton(typeof(IPipelineBehavior<,>), typeof(MessageValidatorBehaviour<,>))\n"})}),(0,s.jsx)(n.h4,{id:"332-error-logging-example",children:"3.3.2. Error logging example"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// As a normal pipeline behavior\npublic sealed class ErrorLoggingBehaviour<TMessage, TResponse> : IPipelineBehavior<TMessage, TResponse>\n    where TMessage : IMessage\n{\n    private readonly ILogger<ErrorLoggingBehaviour<TMessage, TResponse>> _logger;\n\n    public ErrorLoggingBehaviour(ILogger<ErrorLoggingBehaviour<TMessage, TResponse>> logger)\n    {\n        _logger = logger;\n    }\n\n    public async ValueTask<TResponse> Handle(\n        TMessage message,\n        CancellationToken cancellationToken,\n        MessageHandlerDelegate<TMessage, TResponse> next\n    )\n    {\n        try\n        {\n            return await next(message, cancellationToken);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, "Error handling message of type {messageType}", message.GetType().Name);\n            throw;\n        }\n    }\n}\n\n// Or as an exception handler\npublic sealed class ErrorLoggingBehaviour<TMessage, TResponse> : MessageExceptionHandler<TMessage, TResponse>\n    where TMessage : notnull, IMessage\n{\n    private readonly ILogger<ErrorLoggingBehaviour<TMessage, TResponse>> _logger;\n\n    public ErrorLoggingBehaviour(ILogger<ErrorLoggingBehaviour<TMessage, TResponse>> logger)\n    {\n        _logger = logger;\n    }\n\n    protected override ValueTask<ExceptionHandlingResult<TResponse>> Handle(\n        TMessage message,\n        Exception exception,\n        CancellationToken cancellationToken\n    )\n    {\n        _logger.LogError(exception, "Error handling message of type {messageType}", message.GetType().Name);\n        // Let the exception bubble up by using the base class helper NotHandled:\n        return NotHandled;\n        // Or if the exception is properly handled, you can just return your own response,\n        // using the base class helper Handle().\n        // This requires you to know something about TResponse,\n        // so TResponse needs to be constrained to something,\n        // typically with a static abstract member acting as a consructor on an interface or abstract class.\n        return Handled(null!);\n    }\n}\n\n// Register as IPipelineBehavior<,> in either case\nservices.AddSingleton(typeof(IPipelineBehavior<,>), typeof(ErrorLoggingBehaviour<,>))\n'})}),(0,s.jsx)(n.h3,{id:"34-configuration",children:"3.4. Configuration"}),(0,s.jsx)(n.p,{children:"There are two ways to configure Mediator. Configuration values are needed during compile-time since this is a source generator:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Assembly level attribute for configuration: ",(0,s.jsx)(n.code,{children:"MediatorOptionsAttribute"})]}),"\n",(0,s.jsxs)(n.li,{children:["Options configuration delegate in ",(0,s.jsx)(n.code,{children:"AddMediator"})," function."]}),"\n"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'services.AddMediator(options =>\n{\n    options.Namespace = "SimpleConsole.Mediator";\n    options.DefaultServiceLifetime = ServiceLifetime.Transient;\n});\n\n// or\n\n[assembly: MediatorOptions(Namespace = "SimpleConsole.Mediator", DefaultServiceLifetime = ServiceLifetime.Transient)]\n'})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Namespace"})," - where the ",(0,s.jsx)(n.code,{children:"IMediator"})," implementation is generated"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DefaultServiceLifetime"})," - the DI service lifetime","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Singleton"})," - (default value) everything registered as singletons, minimal allocations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Transient"})," - handlers registered as transient, ",(0,s.jsx)(n.code,{children:"IMediator"}),"/",(0,s.jsx)(n.code,{children:"Mediator"}),"/",(0,s.jsx)(n.code,{children:"ISender"}),"/",(0,s.jsx)(n.code,{children:"IPublisher"})," still singleton"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Scoped"}),"    - mediator and handlers registered as scoped"]}),"\n"]}),"\n"]}),"\n"]}),(0,s.jsx)(n.h2,{id:"4-getting-started",children:"4. Getting started"}),(0,s.jsx)(n.p,{children:"In this section we will get started with Mediator and go through a sample\nillustrating the various ways the Mediator pattern can be used in an application."}),(0,s.jsx)(n.p,{children:"See the full runnable sample code in the SimpleEndToEnd sample."}),(0,s.jsx)(n.h3,{id:"41-add-package",children:"4.1. Add package"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-pwsh",children:"dotnet add package Mediator.SourceGenerator --version 2.0.*\ndotnet add package Mediator.Abstractions --version 2.0.*\n"})}),(0,s.jsx)(n.p,{children:"or"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<PackageReference Include="Mediator.SourceGenerator" Version="2.0.*">\n  <PrivateAssets>all</PrivateAssets>\n  <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>\n</PackageReference>\n<PackageReference Include="Mediator.Abstractions" Version="2.0.*" />\n'})}),(0,s.jsx)(n.h3,{id:"42-add-mediator-to-di-container",children:"4.2. Add Mediator to DI container"}),(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"ConfigureServices"})," or equivalent, call ",(0,s.jsx)(n.code,{children:"AddMediator"})," (unless ",(0,s.jsx)(n.code,{children:"MediatorOptions"})," is configured, default namespace is ",(0,s.jsx)(n.code,{children:"Mediator"}),").\nThis registers your handler below."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using Mediator;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\n\nvar services = new ServiceCollection(); // Most likely IServiceCollection comes from IHostBuilder/Generic host abstraction in Microsoft.Extensions.Hosting\n\nservices.AddMediator();\nvar serviceProvider = services.BuildServiceProvider();\n"})}),(0,s.jsxs)(n.h3,{id:"43-create-irequest-type",children:["4.3. Create ",(0,s.jsx)(n.code,{children:"IRequest<>"})," type"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var mediator = serviceProvider.GetRequiredService<IMediator>();\nvar ping = new Ping(Guid.NewGuid());\nvar pong = await mediator.Send(ping);\nDebug.Assert(ping.Id == pong.Id);\n\n// ...\n\npublic sealed record Ping(Guid Id) : IRequest<Pong>;\n\npublic sealed record Pong(Guid Id);\n\npublic sealed class PingHandler : IRequestHandler<Ping, Pong>\n{\n    public ValueTask<Pong> Handle(Ping request, CancellationToken cancellationToken)\n    {\n        return new ValueTask<Pong>(new Pong(request.Id));\n    }\n}\n"})}),(0,s.jsxs)(n.p,{children:["As soon as you code up message types, the source generator will add DI registrations automatically (inside ",(0,s.jsx)(n.code,{children:"AddMediator"}),").\nP.S - You can inspect the code yourself - open ",(0,s.jsx)(n.code,{children:"Mediator.g.cs"})," in VS from Project -> Dependencies -> Analyzers -> Mediator.SourceGenerator -> Mediator.SourceGenerator.MediatorGenerator,\nor just F12 through the code."]}),(0,s.jsx)(n.h3,{id:"44-use-pipeline-behaviors",children:"4.4. Use pipeline behaviors"}),(0,s.jsxs)(n.p,{children:["The pipeline behavior below validates all incoming ",(0,s.jsx)(n.code,{children:"Ping"})," messages.\nPipeline behaviors currently must be added manually."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'services.AddMediator();\nservices.AddSingleton<IPipelineBehavior<Ping, Pong>, PingValidator>();\n\npublic sealed class PingValidator : IPipelineBehavior<Ping, Pong>\n{\n    public ValueTask<Pong> Handle(Ping request, MessageHandlerDelegate<Ping, Pong> next, CancellationToken cancellationToken)\n    {\n        if (request is null || request.Id == default)\n            throw new ArgumentException("Invalid input");\n\n        return next(request, cancellationToken);\n    }\n}\n'})}),(0,s.jsxs)(n.h3,{id:"45-constrain-ipipelinebehavior-message-with-open-generics",children:["4.5. Constrain ",(0,s.jsx)(n.code,{children:"IPipelineBehavior<,>"})," message with open generics"]}),(0,s.jsxs)(n.p,{children:["Add open generic handler to process all or a subset of messages passing through Mediator.\nThis handler will log any error that is thrown from message handlers (",(0,s.jsx)(n.code,{children:"IRequest"}),", ",(0,s.jsx)(n.code,{children:"ICommand"}),", ",(0,s.jsx)(n.code,{children:"IQuery"}),").\nIt also publishes a notification allowing notification handlers to react to errors.\nMessage pre- and post-processors along with the exception handlers can also constrain the generic type parameters in the same way."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'services.AddMediator();\nservices.AddSingleton(typeof(IPipelineBehavior<,>), typeof(ErrorLoggerHandler<,>));\n\npublic sealed record ErrorMessage(Exception Exception) : INotification;\npublic sealed record SuccessfulMessage() : INotification;\n\npublic sealed class ErrorLoggerHandler<TMessage, TResponse> : IPipelineBehavior<TMessage, TResponse>\n    where TMessage : IMessage // Constrained to IMessage, or constrain to IBaseCommand or any custom interface you\'ve implemented\n{\n    private readonly ILogger<ErrorLoggerHandler<TMessage, TResponse>> _logger;\n    private readonly IMediator _mediator;\n\n    public ErrorLoggerHandler(ILogger<ErrorLoggerHandler<TMessage, TResponse>> logger, IMediator mediator)\n    {\n        _logger = logger;\n        _mediator = mediator;\n    }\n\n    public async ValueTask<TResponse> Handle(TMessage message, MessageHandlerDelegate<TMessage, TResponse> next, CancellationToken cancellationToken)\n    {\n        try\n        {\n            var response = await next(message, cancellationToken);\n            return response;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, "Error handling message");\n            await _mediator.Publish(new ErrorMessage(ex));\n            throw;\n        }\n    }\n}\n'})}),(0,s.jsx)(n.h3,{id:"46-use-notifications",children:"4.6. Use notifications"}),(0,s.jsx)(n.p,{children:"We can define a notification handler to catch errors from the above pipeline behavior."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Notification handlers are automatically added to DI container\n\npublic sealed class ErrorNotificationHandler : INotificationHandler<ErrorMessage>\n{\n    public ValueTask Handle(ErrorMessage error, CancellationToken cancellationToken)\n    {\n        // Could log to application insights or something...\n        return default;\n    }\n}\n"})}),(0,s.jsx)(n.h3,{id:"47-polymorphic-dispatch-with-notification-handlers",children:"4.7. Polymorphic dispatch with notification handlers"}),(0,s.jsx)(n.p,{children:"We can also define a notification handler that receives all notifications."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"\npublic sealed class StatsNotificationHandler : INotificationHandler<INotification> // or any other interface deriving from INotification\n{\n    private long _messageCount;\n    private long _messageErrorCount;\n\n    public (long MessageCount, long MessageErrorCount) Stats => (_messageCount, _messageErrorCount);\n\n    public ValueTask Handle(INotification notification, CancellationToken cancellationToken)\n    {\n        Interlocked.Increment(ref _messageCount);\n        if (notification is ErrorMessage)\n            Interlocked.Increment(ref _messageErrorCount);\n        return default;\n    }\n}\n"})}),(0,s.jsx)(n.h3,{id:"48-notification-handlers-also-support-open-generics",children:"4.8. Notification handlers also support open generics"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public sealed class GenericNotificationHandler<TNotification> : INotificationHandler<TNotification>\n    where TNotification : INotification // Generic notification handlers will be registered as open constrained types automatically\n{\n    public ValueTask Handle(TNotification notification, CancellationToken cancellationToken)\n    {\n        return default;\n    }\n}\n"})}),(0,s.jsx)(n.h3,{id:"49-use-streaming-messages",children:"4.9. Use streaming messages"}),(0,s.jsxs)(n.p,{children:["Since version 1.* of this library there is support for streaming using ",(0,s.jsx)(n.code,{children:"IAsyncEnumerable"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'var mediator = serviceProvider.GetRequiredService<IMediator>();\n\nvar ping = new StreamPing(Guid.NewGuid());\n\nawait foreach (var pong in mediator.CreateStream(ping))\n{\n    Debug.Assert(ping.Id == pong.Id);\n    Console.WriteLine("Received pong!"); // Should log 5 times\n}\n\n// ...\n\npublic sealed record StreamPing(Guid Id) : IStreamRequest<Pong>;\n\npublic sealed record Pong(Guid Id);\n\npublic sealed class PingHandler : IStreamRequestHandler<StreamPing, Pong>\n{\n    public async IAsyncEnumerable<Pong> Handle(StreamPing request, [EnumeratorCancellation] CancellationToken cancellationToken)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            await Task.Delay(1000, cancellationToken);\n            yield return new Pong(request.Id);\n        }\n    }\n}\n'})}),(0,s.jsx)(n.h2,{id:"5-diagnostics",children:"5. Diagnostics"}),(0,s.jsx)(n.p,{children:"Since this is a source generator, diagnostics are also included. Examples below"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Missing request handler"}),"\n"]}),(0,s.jsx)(n.p,{children:"Missing request handler"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple request handlers found"}),"\n"]}),(0,s.jsx)(n.p,{children:"Multiple request handlers found"}),(0,s.jsxs)(n.h2,{id:"6-differences-from-mediatr",children:["6. Differences from ",(0,s.jsx)(n.a,{href:"https://github.com/jbogard/MediatR",children:"MediatR"})]}),(0,s.jsx)(n.p,{children:"This is a work in progress list on the differences between this library and MediatR."}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RequestHandlerDelegate<TResponse>()"})," -> ",(0,s.jsx)(n.code,{children:"MessageHandlerDelegate<TMessage, TResponse>(TMessage message, CancellationToken cancellationToken)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This is to avoid excessive closure allocations. I thin it's worthwhile when the cost is simply passing along the message and the cancellationtoken."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["No ",(0,s.jsx)(n.code,{children:"ServiceFactory"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["This library relies on the ",(0,s.jsx)(n.code,{children:"Microsoft.Extensions.DependencyInjection"}),", so it only works with DI containers that integrate with those abstractions."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Singleton service lifetime by default","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["MediatR in combination with ",(0,s.jsx)(n.code,{children:"MediatR.Extensions.Microsoft.DependencyInjection"})," does transient service registration by default, which leads to a lot of allocations. Even if it is configured for singleton lifetime, ",(0,s.jsx)(n.code,{children:"IMediator"})," and ",(0,s.jsx)(n.code,{children:"ServiceFactory"})," services are registered as transient (not configurable)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Methods return ",(0,s.jsx)(n.code,{children:"ValueTask<T>"})," instead of ",(0,s.jsx)(n.code,{children:"Task<T>"}),", to allow for fewer allocations (for example if the handler completes synchronously, or using async method builder pooling/",(0,s.jsx)(n.code,{children:"PoolingAsyncValueTaskMethodBuilder<T>"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"This library doesn't support generic requests/notifications"}),"\n"]})]}),"\n",(0,s.jsx)(n.h3,{id:"about",children:"About"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Gnerating mediator data without reflection"})}),"\n",(0,s.jsx)(n.h2,{id:"how-to-use",children:"How to use"}),"\n",(0,s.jsx)(n.h3,{id:"example-source-csproj-source-files",children:"Example (source csproj, source files)"}),"\n",(0,s.jsxs)(t.A,{children:[(0,s.jsxs)(o.A,{value:"csproj",label:"CSharp Project",children:[(0,s.jsxs)(n.p,{children:["This is the CSharp Project that references ",(0,s.jsx)(n.strong,{children:"Mediator"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",metastring:"showLineNumbers {15}",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net7.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\t<PropertyGroup>\n\t\t<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n\t\t<CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n\t</PropertyGroup>\n\t<ItemGroup>\n\t\t<PackageReference Include="Mediator.Abstractions" Version="2.1.5" />\n\t\t<PackageReference Include="Mediator.SourceGenerator" Version="2.1.5" OutputItemType="Analyzer">\n\t\t  <PrivateAssets>all</PrivateAssets>\n\t\t  <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n\t\t</PackageReference>\n\t\t<PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="7.0.0" />\n\t\t\n\t</ItemGroup>\n\n</Project>\n\n'})})]}),(0,s.jsxs)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\Program.cs",label:"Program.cs",children:[(0,s.jsxs)(n.p,{children:["This is the use of ",(0,s.jsx)(n.strong,{children:"Mediator"})," in ",(0,s.jsx)(n.em,{children:"Program.cs"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'Console.WriteLine("Hello, World!");\nvar services = new ServiceCollection();\nservices.AddMediator();\nservices.AddSingleton(typeof(IPipelineBehavior<,>), typeof(GenericLoggerHandler<,>)); // This will run 1st\n\nvar serviceProvider = services.BuildServiceProvider();\n\nvar mediator = serviceProvider.GetRequiredService<IMediator>();\nvar id = Guid.NewGuid();\nvar request = new Ping(id);\n\nvar response = await mediator.Send(request);\n\nConsole.WriteLine("-----------------------------------");\nConsole.WriteLine("ID: " + id);\nConsole.WriteLine(request);\nConsole.WriteLine(response);\n\n\n'})})]}),(0,s.jsxs)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\GenericLoggerHandler.cs",label:"GenericLoggerHandler.cs",children:[(0,s.jsxs)(n.p,{children:["This is the use of ",(0,s.jsx)(n.strong,{children:"Mediator"})," in ",(0,s.jsx)(n.em,{children:"GenericLoggerHandler.cs"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'public sealed class GenericLoggerHandler<TMessage, TResponse> : IPipelineBehavior<TMessage, TResponse>\n    where TMessage : IMessage\n{\n    public async ValueTask<TResponse> Handle(TMessage message, CancellationToken cancellationToken, MessageHandlerDelegate<TMessage, TResponse> next)    \n    {\n        Console.WriteLine("1) Running logger handler");\n        try\n        {\n            var response = await next(message, cancellationToken);\n            Console.WriteLine("5) No error!");\n            return response;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine("error:"+ex.Message);\n            throw;\n        }\n    }\n\n}\n'})})]}),(0,s.jsxs)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\PingPong.cs",label:"PingPong.cs",children:[(0,s.jsxs)(n.p,{children:["This is the use of ",(0,s.jsx)(n.strong,{children:"Mediator"})," in ",(0,s.jsx)(n.em,{children:"PingPong.cs"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'\npublic sealed record Ping(Guid Id) : IRequest<Pong>;\n\npublic sealed record Pong(Guid Id);\n\n\npublic sealed class PingHandler : IRequestHandler<Ping, Pong>\n{\n    public ValueTask<Pong> Handle(Ping request, CancellationToken cancellationToken)\n    {\n        Console.WriteLine("4) Returning pong!");\n        return new ValueTask<Pong>(new Pong(request.Id));\n    }\n}\n\n'})})]})]}),"\n",(0,s.jsx)(n.h3,{id:"generated-files",children:"Generated Files"}),"\n",(0,s.jsx)(n.p,{children:"Those are taken from $(BaseIntermediateOutputPath)\\GX"}),"\n",(0,s.jsxs)(t.A,{children:[(0,s.jsx)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\obj\\GX\\Mediator.SourceGenerator.Roslyn40\\Mediator.SourceGenerator.IncrementalMediatorGenerator\\Mediator.g.cs",label:"Mediator.g.cs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated>\n//     Generated by the Mediator source generator.\n// </auto-generated>\n\n#pragma warning disable CS8019 // Unused usings\n#pragma warning disable CS8321 // Unused local function\n#pragma warning disable CS1998 // Async method lacks \'await\' operators and will run synchronously\n\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.DependencyInjection.Extensions;\nusing System.Linq;\n\nusing SD = global::Microsoft.Extensions.DependencyInjection.ServiceDescriptor;\n\nnamespace Microsoft.Extensions.DependencyInjection\n{\n    /// <summary>\n    /// DI extensions for Mediator.\n    /// </summary>\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    public static class MediatorDependencyInjectionExtensions\n    {\n        /// <summary>\n        /// Adds the Mediator implementation and handlers of your application.\n        /// </summary>\n        public static IServiceCollection AddMediator(this IServiceCollection services)\n        {\n            return AddMediator(services, null);\n        }\n\n        internal sealed class Dummy { }\n\n        /// <summary>\n        /// Adds the Mediator implementation and handlers of your application, with specified options.\n        /// </summary>\n        public static IServiceCollection AddMediator(this IServiceCollection services, global::System.Action<global::Mediator.MediatorOptions> options)\n        {\n            var opts = new global::Mediator.MediatorOptions();\n            if (options != null)\n                options(opts);\n\n            var configuredViaAttribute = false;\n            if (opts.ServiceLifetime != global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton && !configuredViaAttribute)\n            {\n                var errMsg = "Invalid configuration detected for Mediator. ";\n                errMsg += "Generated code for \'Singleton\' lifetime, but got \'" + opts.ServiceLifetime + "\' lifetime from options. ";\n                errMsg += "This means that the source generator hasn\'t seen the \'AddMediator\' method call during compilation. ";\n                errMsg += "Make sure that the \'AddMediator\' method is called from the project that references the Mediator.SourceGenerator package.";\n                throw new global::System.Exception(errMsg);\n            }\n\n\n            services.Add(new SD(typeof(global::Mediator.Mediator), typeof(global::Mediator.Mediator), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton));\n            services.TryAdd(new SD(typeof(global::Mediator.IMediator), sp => sp.GetRequiredService<global::Mediator.Mediator>(), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton));\n            services.TryAdd(new SD(typeof(global::Mediator.ISender), sp => sp.GetRequiredService<global::Mediator.Mediator>(), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton));\n            services.TryAdd(new SD(typeof(global::Mediator.IPublisher), sp => sp.GetRequiredService<global::Mediator.Mediator>(), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton));\n\n            services.TryAdd(new SD(typeof(global::PingHandler), typeof(global::PingHandler), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton));\n            services.Add(new SD(\n                typeof(global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong>),\n                sp =>\n                {\n                    return new global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong>(\n                        sp.GetRequiredService<global::PingHandler>(),\n                        sp.GetServices<global::Mediator.IPipelineBehavior<global::Ping, global::Pong>>()\n                    );\n                },\n                global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton\n            ));\n\n\n\n\n            services.AddSingleton<Dummy>();\n\n            return services;\n\n        }\n    }\n}\n\nnamespace Mediator\n{\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class RequestClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.IRequest<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public RequestClassHandlerWrapper(\n            global::Mediator.IRequestHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class RequestStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.IRequest<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public RequestStructHandlerWrapper(\n            global::Mediator.IRequestHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamRequestClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.IStreamRequest<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamRequestClassHandlerWrapper(\n            global::Mediator.IStreamRequestHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamRequestStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.IStreamRequest<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamRequestStructHandlerWrapper(\n            global::Mediator.IStreamRequestHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class CommandClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.ICommand<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public CommandClassHandlerWrapper(\n            global::Mediator.ICommandHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class CommandStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.ICommand<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public CommandStructHandlerWrapper(\n            global::Mediator.ICommandHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamCommandClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.IStreamCommand<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamCommandClassHandlerWrapper(\n            global::Mediator.IStreamCommandHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamCommandStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.IStreamCommand<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamCommandStructHandlerWrapper(\n            global::Mediator.IStreamCommandHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class QueryClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.IQuery<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public QueryClassHandlerWrapper(\n            global::Mediator.IQueryHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class QueryStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.IQuery<TResponse>\n    {\n        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public QueryStructHandlerWrapper(\n            global::Mediator.IQueryHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamQueryClassHandlerWrapper<TRequest, TResponse>\n        where TRequest : class, global::Mediator.IStreamQuery<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamQueryClassHandlerWrapper(\n            global::Mediator.IStreamQueryHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    internal sealed class StreamQueryStructHandlerWrapper<TRequest, TResponse>\n        where TRequest : struct, global::Mediator.IStreamQuery<TResponse>\n    {\n        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;\n\n        public StreamQueryStructHandlerWrapper(\n            global::Mediator.IStreamQueryHandler<TRequest, TResponse> concreteHandler,\n            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours\n        )\n        {\n            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;\n\n            foreach (var pipeline in pipelineBehaviours.Reverse())\n            {\n                var handlerCopy = handler;\n                var pipelineCopy = pipeline;\n                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);\n            }\n\n            _rootHandler = handler;\n        }\n\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>\n            _rootHandler(request, cancellationToken);\n    }\n\n    /// <summary>\n    /// Generated code for Mediator implementation.\n    /// This type is also registered as a DI service.\n    /// Can be used directly for high performance scenarios.\n    /// </summary>\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    [global::System.Diagnostics.DebuggerStepThroughAttribute]\n    public sealed partial class Mediator : global::Mediator.IMediator, global::Mediator.ISender, global::Mediator.IPublisher\n    {\n        private readonly global::System.IServiceProvider _sp;\n        private FastLazyValue<DICache> _diCacheLazy;\n\n        /// <summary>\n        /// The lifetime of Mediator-related service registrations in DI container.\n        /// </summary>\n        public static global::Microsoft.Extensions.DependencyInjection.ServiceLifetime ServiceLifetime { get; } = global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton;\n\n        private readonly global::System.Func<global::System.Collections.Generic.IEnumerable<object>, int> _getServicesLength;\n\n        /// <summary>\n        /// Constructor for DI, should not be used by consumer.\n        /// </summary>\n        public Mediator(global::System.IServiceProvider sp)\n        {\n            _sp = sp;\n            _diCacheLazy = new FastLazyValue<DICache>(() => new DICache(_sp));\n\n            global::System.Func<global::System.Collections.Generic.IEnumerable<object>, int> fastGetLength = s => ((object[])s).Length;\n            global::System.Func<global::System.Collections.Generic.IEnumerable<object>, int> slowGetLength = s => s.Count();\n\n            var dummy = sp.GetServices<global::Microsoft.Extensions.DependencyInjection.MediatorDependencyInjectionExtensions.Dummy>();\n            _getServicesLength = dummy.GetType() == typeof(global::Microsoft.Extensions.DependencyInjection.MediatorDependencyInjectionExtensions.Dummy[])\n                 ? fastGetLength : slowGetLength;\n        }\n\n        private struct FastLazyValue<T>\n            where T : struct\n        {\n            private const long UNINIT = 0;\n            private const long INITING = 1;\n            private const long INITD = 2;\n            \n            \n\n            private global::System.Func<T> _generator;\n            private long _state;\n            private T _value;\n\n            public T Value\n            {\n                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]\n                get\n                {\n                    if (_state != INITD)\n                        return ValueSlow;\n\n                    return _value;\n                }\n            }\n\n            private T ValueSlow\n            {\n                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\n                get\n                {\n                    var prevState = global::System.Threading.Interlocked.CompareExchange(ref _state, INITING, UNINIT);\n                    switch (prevState)\n                    {\n                        case INITD:\n                            // Someone has already completed init\n                            return _value;\n                        case INITING:\n                            // Wait for someone else to complete\n                            var spinWait = default(global::System.Threading.SpinWait);\n                            while (global::System.Threading.Interlocked.Read(ref _state) < INITD)\n                                spinWait.SpinOnce();\n                            return _value;\n                        case UNINIT:\n                            _value = _generator();\n                            global::System.Threading.Interlocked.Exchange(ref _state, INITD);\n                            return _value;\n                    }\n\n                    return _value;\n                }\n            }\n\n\n            public FastLazyValue(global::System.Func<T> generator)\n            {\n                _generator = generator;\n                _state = UNINIT;\n                _value = default;\n            }\n        }\n\n                private readonly struct DICache\n        {\n            private readonly global::System.IServiceProvider _sp;\n\n            public readonly global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong> Wrapper_For_Ping;\n\n            public DICache(global::System.IServiceProvider sp)\n            {\n                _sp = sp;\n\n                Wrapper_For_Ping = sp.GetRequiredService<global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong>>();\n            }\n        }\n\n        /// <summary>\n        /// Send a message of type global::Ping.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// </summary>\n        /// <param name="message">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask<global::Pong> Send(\n            global::Ping message,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowIfNull(message, nameof(message));\n            \n            return _diCacheLazy.Value.Wrapper_For_Ping.Handle(message, cancellationToken);\n        }\n\n        /// <summary>\n        /// Send request.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="request">Incoming request</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(\n            global::Mediator.IRequest<TResponse> request,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            switch (request)\n            {\n                case global::Ping r:\n                {\n                    if(typeof(TResponse) == typeof(global::Pong))\n                    {\n                        var task = Send(r, cancellationToken);\n                        return global::System.Runtime.CompilerServices.Unsafe.As<global::System.Threading.Tasks.ValueTask<global::Pong>, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);\n                    }\n                    else\n                    {\n                        return SendAsync(request, cancellationToken);\n                    }\n                }\n                default:\n                {\n                    ThrowArgumentNullOrInvalidMessage(request, nameof(request));\n                    return default;\n                }\n            }\n            \n        }\n\n        /// <summary>\n        /// Send request.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="request">Incoming request</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        private async global::System.Threading.Tasks.ValueTask<TResponse> SendAsync<TResponse>(\n            global::Mediator.IRequest<TResponse> request,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            switch (request)\n            {\n                case global::Ping r:\n                {\n                    var response = await Send(r, cancellationToken);\n                    return global::System.Runtime.CompilerServices.Unsafe.As<global::Pong, TResponse>(ref response);\n                }\n                default:\n                {\n                    ThrowArgumentNullOrInvalidMessage(request, nameof(request));\n                    return default;\n                }\n            }\n            \n        }\n\n        /// <summary>\n        /// Create stream for request.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="request">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Async enumerable</returns>\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(\n            global::Mediator.IStreamRequest<TResponse> request,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(request);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Send command.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="command">Incoming command</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(\n            global::Mediator.ICommand<TResponse> command,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(command);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Send command.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="command">Incoming command</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        private async global::System.Threading.Tasks.ValueTask<TResponse> SendAsync<TResponse>(\n            global::Mediator.ICommand<TResponse> command,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(command);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Create stream for command.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="command">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Async enumerable</returns>\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(\n            global::Mediator.IStreamCommand<TResponse> command,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(command);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Send query.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="query">Incoming query</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(\n            global::Mediator.IQuery<TResponse> query,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(query);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Send query.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="query">Incoming query</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        private async global::System.Threading.Tasks.ValueTask<TResponse> SendAsync<TResponse>(\n            global::Mediator.IQuery<TResponse> query,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(query);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Create stream for query.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="query">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Async enumerable</returns>\n        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(\n            global::Mediator.IStreamQuery<TResponse> query,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(query);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Send message.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="message">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public async global::System.Threading.Tasks.ValueTask<object> Send(\n            object message,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            switch (message)\n            {\n                case global::Ping m: return await Send(m, cancellationToken);\n                default:\n                {\n                    ThrowArgumentNullOrInvalidMessage(message as global::Mediator.IMessage, nameof(message));\n                    return default;\n                }\n            }\n            \n        }\n\n        /// <summary>\n        /// Create stream.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.\n        /// </summary>\n        /// <param name="message">Incoming message</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Async enumerable</returns>\n        public global::System.Collections.Generic.IAsyncEnumerable<object> CreateStream(\n            object message,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            ThrowInvalidMessage(message as global::Mediator.IStreamMessage);\n            return default;\n            \n        }\n\n        /// <summary>\n        /// Publish notification.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// </summary>\n        /// <param name="notification">Incoming notification</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask Publish(\n            object notification,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n        {\n            return default;\n            \n        }\n\n\n        /// <summary>\n        /// Publish notification.\n        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.\n        /// </summary>\n        /// <param name="notification">Incoming notification</param>\n        /// <param name="cancellationToken">Cancellation token</param>\n        /// <returns>Awaitable task</returns>\n        public global::System.Threading.Tasks.ValueTask Publish<TNotification>(\n            TNotification notification,\n            global::System.Threading.CancellationToken cancellationToken = default\n        )\n            where TNotification : global::Mediator.INotification\n        {\n            return default;\n            \n        }\n\n        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        private static void ThrowInvalidMessage(object msg) =>\n            throw new global::Mediator.MissingMessageHandlerException(msg);\n\n        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        private static void ThrowArgumentNull(string paramName) =>\n            throw new global::System.ArgumentNullException(paramName);\n\n        private static void ThrowIfNull<T>(T argument, string paramName)\n        {\n            if (argument is null)\n            {\n                ThrowArgumentNull(paramName);\n            }\n        }\n\n        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        private static void ThrowArgumentNullOrInvalidMessage(object msg, string paramName)\n        {\n            if (msg is null)\n            {\n                ThrowArgumentNull(paramName);\n            }\n            else\n            {\n                ThrowInvalidMessage(msg);\n            }\n        }\n\n        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        private static void ThrowAggregateException(global::System.Collections.Generic.List<global::System.Exception> exceptions) =>\n            throw new global::System.AggregateException(exceptions);\n\n        private static void MaybeThrowAggregateException(global::System.Collections.Generic.List<global::System.Exception> exceptions)\n        {\n            if (exceptions != null)\n            {\n                ThrowAggregateException(exceptions);\n            }\n        }\n    }\n}\n\n'})})}),(0,s.jsx)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\obj\\GX\\Mediator.SourceGenerator.Roslyn40\\Mediator.SourceGenerator.IncrementalMediatorGenerator\\MediatorOptions.g.cs",label:"MediatorOptions.g.cs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated>\n//     Generated by the Mediator source generator.\n// </auto-generated>\n\nnamespace Mediator\n{\n    /// <summary>\n    /// Provide options for the Mediator source generator.\n    /// </summary>\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    public sealed class MediatorOptions\n    {\n        /// <summary>\n        /// The namespace in which the Mediator implementation is generated.\n        /// </summary>\n        public string Namespace { get; set; } = "Mediator";\n\n        /// <summary>\n        /// The default lifetime of the services registered in the DI container by\n        /// the Mediator source generator.\n        /// Singleton by default.\n        /// </summary>\n        public global::Microsoft.Extensions.DependencyInjection.ServiceLifetime ServiceLifetime { get; set; } =\n            global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton;\n    }\n}\n\n'})})}),(0,s.jsx)(o.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\Mediator\\src\\MediatorDemo\\obj\\GX\\Mediator.SourceGenerator.Roslyn40\\Mediator.SourceGenerator.IncrementalMediatorGenerator\\MediatorOptionsAttribute.g.cs",label:"MediatorOptionsAttribute.g.cs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated>\n//     Generated by the Mediator source generator.\n// </auto-generated>\n\nnamespace Mediator\n{\n    /// <summary>\n    /// Provide options for the Mediator source generator.\n    /// </summary>\n    [global::System.AttributeUsage(global::System.AttributeTargets.Assembly, AllowMultiple = false)]\n    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]\n    public sealed class MediatorOptionsAttribute : global::System.Attribute\n    {\n        /// <summary>\n        /// The namespace in which the Mediator implementation is generated.\n        /// </summary>\n        public string Namespace { get; set; } = "Mediator";\n\n        /// <summary>\n        /// The default lifetime of the services registered in the DI container by\n        /// the Mediator source generator.\n        /// Singleton by default.\n        /// </summary>\n        public global::Microsoft.Extensions.DependencyInjection.ServiceLifetime ServiceLifetime { get; set; } =\n            global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Singleton;\n    }\n}\n\n'})})})]}),"\n",(0,s.jsx)(n.h2,{id:"useful",children:"Useful"}),"\n",(0,s.jsx)(n.h3,{id:"download-example-net--c",children:"Download Example (.NET  C#)"}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:a(63527).A+"",children:"Download Example project Mediator "})})}),"\n",(0,s.jsx)(n.h3,{id:"share-mediator",children:"Share Mediator"}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsx)("li",{children:(0,s.jsx)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator&quote=Mediator",title:"Share on Facebook",target:"_blank",children:"Share on Facebook"})}),(0,s.jsx)("li",{children:(0,s.jsx)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator&text=Mediator:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator",target:"_blank",title:"Tweet",children:"Share in Twitter"})}),(0,s.jsx)("li",{children:(0,s.jsx)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator&title=Mediator",target:"_blank",title:"Submit to Reddit",children:"Share on Reddit"})}),(0,s.jsx)("li",{children:(0,s.jsx)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator&title=Mediator&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FMediator",target:"_blank",title:"Share on LinkedIn",children:"Share on Linkedin"})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/Mediator",children:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/Mediator"})}),"\n",(0,s.jsx)(n.p,{children:"aaa"}),"\n",(0,s.jsx)(d.Ay,{})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},63527:(e,n,a)=>{a.d(n,{A:()=>r});const r=a.p+"assets/files/Mediator-eda32ba59c0664c33238b33b8e6fb5f8.zip"}}]);