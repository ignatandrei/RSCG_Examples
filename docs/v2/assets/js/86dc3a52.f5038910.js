"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[44947],{319:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/files/KnockOff-ecd1c3b31d2618d2db0bf19f831baaf1.zip"},19383:(e,t,n)=>{n.d(t,{Ay:()=>a,RM:()=>i});var s=n(74848),r=n(28453);const i=[{value:"Category &quot;Tests&quot; has the following generators:",id:"category-tests-has-the-following-generators",level:3},{value:"See category",id:"see-category",level:3}];function o(e){const t={a:"a",h3:"h3",img:"img",p:"p",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h3,{id:"category-tests-has-the-following-generators",children:'Category "Tests" has the following generators:'}),"\n",(0,s.jsxs)(t.p,{children:["1 ",(0,s.jsx)(t.a,{href:"/docs/Imposter",children:"Imposter"})," ",(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/Imposter/",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/Imposter?label=Imposter",alt:"Nuget"})})," ",(0,s.jsx)(t.img,{src:"https://img.shields.io/github/stars/themidnightgospel/Imposter?style=social",alt:"GitHub Repo stars"})," 2025-12-13"]}),"\n",(0,s.jsxs)(t.p,{children:["2 ",(0,s.jsx)(t.a,{href:"/docs/KnockOff",children:"KnockOff"})," ",(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/KnockOff/",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/KnockOff?label=KnockOff",alt:"Nuget"})})," ",(0,s.jsx)(t.img,{src:"https://img.shields.io/github/stars/NeatooDotNet/KnockOff?style=social",alt:"GitHub Repo stars"})," 2026-02-13"]}),"\n",(0,s.jsxs)(t.p,{children:["3 ",(0,s.jsx)(t.a,{href:"/docs/mocklis",children:"mocklis"})," ",(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/mocklis/",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/mocklis?label=mocklis",alt:"Nuget"})})," ",(0,s.jsx)(t.img,{src:"https://img.shields.io/github/stars/mocklis/mocklis?style=social",alt:"GitHub Repo stars"})," 2024-01-03"]}),"\n",(0,s.jsxs)(t.p,{children:["4 ",(0,s.jsx)(t.a,{href:"/docs/MockMe",children:"MockMe"})," ",(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/MockMe/",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/MockMe?label=MockMe",alt:"Nuget"})})," ",(0,s.jsx)(t.img,{src:"https://img.shields.io/github/stars/connorivy/MockMe?style=social",alt:"GitHub Repo stars"})," 2025-02-10"]}),"\n",(0,s.jsxs)(t.p,{children:["5 ",(0,s.jsx)(t.a,{href:"/docs/MSTest",children:"MSTest"})," ",(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/MSTest.SourceGeneration/",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/MSTest.SourceGeneration?label=MSTest.SourceGeneration",alt:"Nuget"})})," ",(0,s.jsx)(t.img,{src:"https://img.shields.io/github/stars/microsoft/testfx?style=social",alt:"GitHub Repo stars"})," 2024-04-04"]}),"\n",(0,s.jsxs)(t.p,{children:["6 ",(0,s.jsx)(t.a,{href:"/docs/Ridge",children:"Ridge"})," ",(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/Ridge/",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/Ridge?label=Ridge",alt:"Nuget"})})," ",(0,s.jsx)(t.img,{src:"https://img.shields.io/github/stars/Melchy/Ridge?style=social",alt:"GitHub Repo stars"})," 2023-08-20"]}),"\n",(0,s.jsxs)(t.p,{children:["7 ",(0,s.jsx)(t.a,{href:"/docs/Rocks",children:"Rocks"})," ",(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/Rocks/",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/Rocks?label=Rocks",alt:"Nuget"})})," ",(0,s.jsx)(t.img,{src:"https://img.shields.io/github/stars/JasonBock/Rocks?style=social",alt:"GitHub Repo stars"})," 2023-04-16"]}),"\n",(0,s.jsxs)(t.p,{children:["8 ",(0,s.jsx)(t.a,{href:"/docs/TUnit",children:"TUnit"})," ",(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/TUnit/",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/TUnit?label=TUnit",alt:"Nuget"})})," ",(0,s.jsx)(t.img,{src:"https://img.shields.io/github/stars/thomhurst/TUnit?style=social",alt:"GitHub Repo stars"})," 2025-11-08"]}),"\n",(0,s.jsx)(t.h3,{id:"see-category",children:"See category"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"/docs/Categories/Tests",children:"Tests"})})]})}function a(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},86377:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>u,default:()=>g,frontMatter:()=>d,metadata:()=>s,toc:()=>f});const s=JSON.parse('{"id":"RSCG-Examples/KnockOff","title":"255 - KnockOff","description":"Generating test stubs with mocking for interfaces","source":"@site/docs/RSCG-Examples/KnockOff.md","sourceDirName":"RSCG-Examples","slug":"/KnockOff","permalink":"/RSCG_Examples/v2/docs/KnockOff","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2550,"frontMatter":{"sidebar_position":2550,"title":"255 - KnockOff","description":"Generating test stubs with mocking for interfaces","slug":"/KnockOff"},"sidebar":"tutorialSidebar","previous":{"title":"254 - ErrorOrX","permalink":"/RSCG_Examples/v2/docs/ErrorOrX"},"next":{"title":"v1","permalink":"/RSCG_Examples/v2/docs/v1"}}');var r=n(74848),i=n(28453),o=n(11470),a=n(19365),l=n(14252),c=n(19383);const d={sidebar_position:2550,title:"255 - KnockOff",description:"Generating test stubs with mocking for interfaces",slug:"/KnockOff"},u="KnockOff  by Keith Voels",h={},f=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Author",id:"author",level:3},{value:"Original Readme",id:"original-readme",level:2},{value:"KnockOff",id:"knockoff",level:3},{value:"KnockOff Stub",id:"knockoff-stub",level:6},{value:"Why I Wrote KnockOff",id:"why-i-wrote-knockoff",level:6},{value:"So I Created KnockOff",id:"so-i-created-knockoff",level:6},{value:"What Sets KnockOff Apart",id:"what-sets-knockoff-apart",level:6},{value:"Quick Start",id:"quick-start",level:6},{value:"The Difference",id:"the-difference",level:6},{value:"Argument Matching",id:"argument-matching",level:6},{value:"Method Overload Resolution",id:"method-overload-resolution",level:6},{value:"Three Stub Patterns",id:"three-stub-patterns",level:6},{value:"Roslyn Source Generation",id:"roslyn-source-generation",level:6},{value:"AI",id:"ai",level:6},{value:"Documentation",id:"documentation",level:6},{value:"License",id:"license",level:6},{value:"Contributing",id:"contributing",level:6},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example (source csproj, source files)",id:"example-source-csproj-source-files",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C#)",id:"download-example-net--c",level:3},{value:"Share KnockOff",id:"share-knockoff",level:3},...c.RM];function m(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h6:"h6",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"knockoff--by-keith-voels",children:"KnockOff  by Keith Voels"})}),"\n",(0,r.jsx)(l.A,{toc:f,minHeadingLevel:2,maxHeadingLevel:2}),"\n",(0,r.jsx)(t.h2,{id:"nuget--site-data",children:"NuGet / site data"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://www.nuget.org/packages/KnockOff/",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/KnockOff?label=KnockOff",alt:"Nuget"})}),"\n",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/github/last-commit/NeatooDotNet/KnockOff?label=updated",alt:"GitHub last commit"})}),"\n",(0,r.jsx)(t.img,{src:"https://img.shields.io/github/stars/NeatooDotNet/KnockOff?style=social",alt:"GitHub Repo stars"})]}),"\n",(0,r.jsx)(t.h2,{id:"details",children:"Details"}),"\n",(0,r.jsx)(t.h3,{id:"info",children:"Info"}),"\n",(0,r.jsxs)(t.admonition,{type:"info",children:[(0,r.jsxs)(t.p,{children:["Name: ",(0,r.jsx)(t.strong,{children:"KnockOff"})]}),(0,r.jsx)(t.p,{children:"A Roslyn Source Generator for creating unit test stubs. Unlike Moq's fluent runtime configuration, KnockOff uses partial classes for compile-time setup\u2014trading flexibility for readability and performance."}),(0,r.jsx)(t.p,{children:"Author: Keith Voels"}),(0,r.jsxs)(t.p,{children:["NuGet:\n",(0,r.jsx)(t.em,{children:(0,r.jsx)(t.a,{href:"https://www.nuget.org/packages/KnockOff/",children:"https://www.nuget.org/packages/KnockOff/"})})]}),(0,r.jsxs)(t.p,{children:["You can find more details at ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff",children:"https://github.com/NeatooDotNet/KnockOff"})]}),(0,r.jsxs)(t.p,{children:["Source: ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff",children:"https://github.com/NeatooDotNet/KnockOff"})]})]}),"\n",(0,r.jsx)(t.h3,{id:"author",children:"Author"}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["Keith Voels\n",(0,r.jsx)(t.img,{src:"https://github.com/NeatooDotNet.png",alt:"Alt text"})]})}),"\n",(0,r.jsx)(t.h2,{id:"original-readme",children:"Original Readme"}),"\n",(0,r.jsxs)(t.admonition,{type:"note",children:[(0,r.jsx)(t.h3,{id:"knockoff",children:"KnockOff"}),(0,r.jsx)(t.p,{children:"A .NET mocking library that lets you define reusable stub classes \u2014 with full mocking capabilities built in."}),(0,r.jsxs)(t.p,{children:["Define your test double once. Reuse it across your test project. Customize it per-test with Return, Call, Verify, and When chains. No more copying mock setups between tests or maintaining shared factory methods full of ",(0,r.jsx)(t.code,{children:"Arg.Any<>()"}),"."]}),(0,r.jsxs)(t.p,{children:["Powered by Roslyn source generation for ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/type-safety.md",children:"tighter type safety"})," \u2014 more issues surface as compile errors instead of runtime surprises."]}),(0,r.jsxs)(t.p,{children:["Claude Code was used to write this library. Skip to more ",(0,r.jsx)(t.a,{href:"#ai",children:"AI discussion"}),"."]}),(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://www.nuget.org/packages/KnockOff/",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/nuget/v/KnockOff.svg",alt:"NuGet"})}),"\n",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/actions",children:(0,r.jsx)(t.img,{src:"https://github.com/NeatooDotNet/KnockOff/workflows/Build,%20Test%20&%20Publish/badge.svg",alt:"Build Status"})}),"\n",(0,r.jsx)(t.a,{href:"https://opensource.org/licenses/MIT",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/badge/License-MIT-yellow.svg",alt:"License: MIT"})})]}),(0,r.jsx)(t.h6,{id:"knockoff-stub",children:"KnockOff Stub"}),(0,r.jsxs)(t.p,{children:["There are ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/stub-patterns.md",children:"9 patterns"})," total, including a ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/stub-patterns.md#inline-interface-pattern",children:"standard fluent mocking approach"})," with inline stubs. But reusable stub classes are where KnockOff stands apart:"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"[KnockOff]\npublic partial class MyRepoStub(List<User> Users) : IMyRepo\n{\n    protected override User? GetUser_(int id)\n    {\n        return Users.Single(u => u.Id == id);\n    }\n\n    protected override void Update_(User user)\n    {\n        Assert.Contains(user, Users);\n    }\n}\n"})}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsxs)(t.strong,{children:[(0,r.jsx)(t.code,{children:"[KnockOff]"})," + ",(0,r.jsx)(t.code,{children:"partial class"})]})," \u2014 KnockOff generates a base class that implements every member of ",(0,r.jsx)(t.code,{children:"IMyRepo"}),". Your stub is a real class \u2014 define it once, reuse it across your entire test project. Pass it around, register it in DI, share it between test fixtures."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Constructor parameters"})," \u2014 ",(0,r.jsx)(t.code,{children:"List<User> Users"})," is a primary constructor. Test data flows in naturally, just like any other C# class."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Overrides are optional"})," \u2014 ",(0,r.jsx)(t.code,{children:"GetUser_"})," and ",(0,r.jsx)(t.code,{children:"Update_"})," override the generated defaults. Only override what you need \u2014 everything else still works with ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/methods.md",children:"Return/Call"}),", ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/reference/interceptor-api.md",children:"Return(value)"}),", or ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/parameter-matching.md",children:"When chains"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Tighter type safety"})," \u2014 Every Return, Call, and When call is complete in a single step \u2014 no forgotten ",(0,r.jsx)(t.code,{children:".Returns()"})," that ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/type-safety.md",children:"silently breaks at runtime"}),". No manual ",(0,r.jsx)(t.code,{children:"<T1, T2>"})," type parameters that can drift. ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/type-safety.md",children:"Details \u2192"})]}),"\n"]}),(0,r.jsxs)(t.p,{children:["This stub is also a full mock. It has ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/verification.md",children:"Verify"}),", ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/strict-mode.md",children:"Strict mode"}),", ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/async-patterns.md",children:"Async"}),", and ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/source-delegation.md",children:"Source Delegation"})," \u2014 all on the same reusable class."]}),(0,r.jsx)(t.h6,{id:"why-i-wrote-knockoff",children:"Why I Wrote KnockOff"}),(0,r.jsx)(t.p,{children:"I often wanted to reuse my mocks.\nEspecially in my integration test library where I may even register my mocks.\nI found myself either copying my mock definitions code or creating shared methods like this:"}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"NSubstitute:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"public static IMyRepo NSubstituteMock(List<User> users)\n{\n    var myRepoMock = Substitute.For<IMyRepo>();\n\n    // Setup: configure GetUser to look up from the list based on id\n    myRepoMock.GetUser(Arg.Any<int>())\n        .Returns(callInfo => users.SingleOrDefault(u => u.Id == callInfo.Arg<int>()));\n\n    // Setup: configure Update to assert user exists in list\n    myRepoMock.When(x => x.Update(Arg.Any<User>()))\n        .Do(callInfo => Assert.Contains(callInfo.Arg<User>(), users));\n\n    return myRepoMock;\n}\n"})}),(0,r.jsxs)(t.p,{children:["Here's another ",(0,r.jsx)(t.a,{href:"https://github.com/microsoft/PowerToys/blob/main/src/settings-ui/Settings.UI.UnitTests/Mocks/ISettingsUtilsMocks.cs",children:"example from PowerToys"}),"."]}),(0,r.jsx)(t.p,{children:"But I find that hard to read and unintuitive. Also, my shared methods accumulated extra parameters for variations across different tests."}),(0,r.jsx)(t.h6,{id:"so-i-created-knockoff",children:"So I Created KnockOff"}),(0,r.jsxs)(t.p,{children:["You can create a stub to implement ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/stub-patterns.md",children:"interfaces"})," or non-sealed ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/stub-patterns.md",children:"classes"})," with virtual methods.\nYet, you can still customize the stub per test.\nAll while having the features you would expect with a full mocking library."]}),(0,r.jsx)(t.p,{children:"With the stub above, your tests are:"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"var myRepoKO = new MyRepoStub([new User \\{ Id = 1 }, new User \\{ Id = 2 }]);\nvar userDomainModel = new UserDomainModel(myRepoKO);\n\nAssert.True(userDomainModel.Fetch(1));\n\n// I have Verify on my Stub!\nmyRepoKO.GetUser.Verify(Called.Once);\n"})}),(0,r.jsx)(t.p,{children:"Need different behavior for a specific test? Override with Return/Call:"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"var user1 = new User \\{ Id = 1 }; // Ignored do to per-test configuration\nvar myRepoKO = new MyRepoStub([user1]);\nvar userDomainModel = new UserDomainModel(myRepoKO);\n\nvar user2 = new User \\{ Id = 2 };\n\n// When and Return overrides the stub methods\nmyRepoKO.GetUser.When(2).Return(user2).Verifiable();\nmyRepoKO.Update.Call(u => Assert.Same(u, user2)).Verifiable();\n\nuserDomainModel.Fetch(2);\nuserDomainModel.Update();\n\nmyRepoKO.Verify();\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Now I have my stubs and mocks in one!"})}),(0,r.jsx)(t.hr,{}),(0,r.jsx)(t.h6,{id:"what-sets-knockoff-apart",children:"What Sets KnockOff Apart"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/reusable-stubs.md",children:"Reusable stub classes"})})," \u2014 Define once, customize per-test. Your stub is a real class \u2014 pass it through constructors, register it in DI."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/source-delegation.md",children:"Source delegation"})})," \u2014 Delegate to a real implementation, override only specific methods. No equivalent in Moq or NSubstitute."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/protected-methods.md",children:"Protected methods"})})," \u2014 Same ",(0,r.jsx)(t.code,{children:"Return"}),"/",(0,r.jsx)(t.code,{children:"Call"}),"/",(0,r.jsx)(t.code,{children:"Verify"})," API, fully typed. No string-based names, no manual subclasses."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/ref-out-parameters.md",children:"Ref/out parameters"})})," \u2014 Natural lambda syntax with ",(0,r.jsx)(t.code,{children:"ref"}),"/",(0,r.jsx)(t.code,{children:"out"})," keywords. No special matchers or index-based access."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/multiple-interfaces.md",children:"Multiple interfaces"})})," \u2014 Unified interceptors on one stub. No ",(0,r.jsx)(t.code,{children:".As<T>()"})," references or casting."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/type-safety.md",children:"Tighter type safety"})})," \u2014 Each Return/Call/When call is complete in one step \u2014 no forgotten ",(0,r.jsx)(t.code,{children:".Returns()"})," that silently breaks at runtime."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/parameter-matching-comparison.md",children:"Parameter matching"})})," \u2014 ",(0,r.jsx)(t.code,{children:"Return((a, b) => a > 0 ? 100 : 0)"})," \u2014 standard C# conditionals instead of ",(0,r.jsx)(t.code,{children:"Arg.Is<>"})," or ",(0,r.jsx)(t.code,{children:"It.Is<>"})," per parameter."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Built-in argument capture"})," \u2014 ",(0,r.jsx)(t.code,{children:"LastArg"}),", ",(0,r.jsx)(t.code,{children:"LastArgs"}),", ",(0,r.jsx)(t.code,{children:"LastSetValue"}),", ",(0,r.jsx)(t.code,{children:"LastSetEntry"})," \u2014 no manual ",(0,r.jsx)(t.code,{children:"Arg.Do<>"})," or ",(0,r.jsx)(t.code,{children:"Callback<>"})," setup."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Event verification"})," \u2014 ",(0,r.jsx)(t.code,{children:"VerifyAdd()"})," / ",(0,r.jsx)(t.code,{children:"VerifyRemove()"})," / ",(0,r.jsx)(t.code,{children:"HasSubscribers"})," \u2014 not available in Moq or NSubstitute."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Explicit Get/Set verification"})," \u2014 ",(0,r.jsx)(t.code,{children:"VerifyGet(Called)"})," / ",(0,r.jsx)(t.code,{children:"VerifySet(Called)"})," for properties and indexers."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Stubbing concrete classes"})," \u2014 Override virtual methods on non-sealed classes with the same API."]}),"\n"]}),(0,r.jsx)(t.hr,{}),(0,r.jsx)(t.h6,{id:"quick-start",children:"Quick Start"}),(0,r.jsx)(t.p,{children:"######### Install"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"dotnet add package KnockOff\n"})}),(0,r.jsx)(t.p,{children:"######### Create a Stub"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"public interface IQuickStartRepo\n{\n    User? GetUser(int id);\n}\n\n[KnockOff]\npublic partial class QuickStartRepoStub : IQuickStartRepo \\{ }\n\npublic class QuickStartCreateStubTests\n{\n    [Fact]\n    public void CreateStub_IsReady()\n    {\n        var stub = new QuickStartRepoStub();\n\n        IQuickStartRepo repository = stub;\n        Assert.NotNull(repository);\n    }\n}\n"})}),(0,r.jsx)(t.p,{children:"######### Configure and Verify"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:'[Fact]\npublic void ConfigureStub_WithReturn()\n{\n    var stub = new QuickStartRepoStub();\n\n    stub.GetUser.Return((id) => new User \\{ Id = id, Name = "Test User" });\n\n    IQuickStartRepo repository = stub;\n    var user = repository.GetUser(42);\n\n    Assert.NotNull(user);\n    Assert.Equal(42, user.Id);\n    Assert.Equal("Test User", user.Name);\n}\n'})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:'[Fact]\npublic void VerifyCalls_WithVerifiable()\n{\n    var stub = new QuickStartRepoStub();\n    stub.GetUser.Return((id) => new User \\{ Id = id, Name = "Test" }).Verifiable();\n\n    IQuickStartRepo repository = stub;\n\n    var user = repository.GetUser(42);\n\n    // Verify() checks all members marked with .Verifiable()\n    stub.Verify();\n}\n'})}),(0,r.jsx)(t.hr,{}),(0,r.jsx)(t.h6,{id:"the-difference",children:"The Difference"}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Moq:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"mock.Setup(x => x.GetUser(It.Is<int>(id => id > 0)))\n    .Returns<int>(id => new User \\{ Id = id });\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"NSubstitute:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"var repo = Substitute.For<IUserRepo>();\nrepo.GetUser(Arg.Is<int>(id => id > 0)).Returns(x => new User \\{ Id = x.Arg<int>() });\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"KnockOff:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"var stub = new CompareUserRepoStub();\nstub.GetUser.Return((id) => id > 0 ? new User \\{ Id = id \\} : null);\n"})}),(0,r.jsxs)(t.p,{children:["No ",(0,r.jsx)(t.code,{children:"It.Is<>()"}),". No ",(0,r.jsx)(t.code,{children:"Arg.Is<>()"}),". No ",(0,r.jsx)(t.code,{children:"x.Arg<int>()"}),". The parameter is just ",(0,r.jsx)(t.code,{children:"id"}),"."]}),(0,r.jsx)(t.hr,{}),(0,r.jsxs)(t.p,{children:["For side-by-side comparison tables (methods, properties, events, delegates, indexers), see the ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/comparison.md",children:"complete comparison guide"}),"."]}),(0,r.jsx)(t.hr,{}),(0,r.jsx)(t.h6,{id:"argument-matching",children:"Argument Matching"}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Moq:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// Moq - It.Is<T> per parameter\nmock.Setup(x => x.Add(It.Is<int>(a => a > 0), It.IsAny<int>())).Returns(100);\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"NSubstitute:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// NSubstitute - Arg.Is<T> per parameter (permanent matchers)\ncalc.Add(Arg.Is<int>(a => a > 0), Arg.Any<int>()).Returns(100);\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"KnockOff:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// KnockOff - Returns with conditional (permanent, matches all calls)\nstub.Add.Return((a, b) => a > 0 ? 100 : 0);\n"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// KnockOff - When() for sequential matching (first match returns 100, then falls through)\nstub.Add.When((a, b) => a > 0).Return(100).ThenCall((a, b) => a + b);\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Multiple specific values:"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Moq:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"mock.Setup(x => x.Add(1, 2)).Returns(100);\nmock.Setup(x => x.Add(3, 4)).Returns(200);\n"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// Multiple specific values\ncalc.Add(1, 2).Returns(100);\ncalc.Add(3, 4).Returns(200);\n"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"stub.Add.When(1, 2).Return(100);\nstub.Add.When(3, 4).Return(200);\n"})}),(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Note:"})," Moq and NSubstitute matchers are permanent -- they match all qualifying calls. KnockOff's ",(0,r.jsx)(t.code,{children:"When()"})," is sequential -- matchers are consumed in order. Use ",(0,r.jsx)(t.code,{children:"Return(callback)"})," with conditionals for permanent matching behavior."]}),(0,r.jsx)(t.p,{children:"######### Argument Capture"}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Moq:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// Moq - requires Callback setup\nint capturedA = 0, capturedB = 0;\nmock.Setup(x => x.Add(It.IsAny<int>(), It.IsAny<int>()))\n    .Callback<int, int>((a, b) => \\{ capturedA = a; capturedB = b; });\nmock.Object.Add(1, 2);\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"NSubstitute:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// NSubstitute - requires Arg.Do in setup\nint capturedA = 0, capturedB = 0;\ncalc.Add(Arg.Do<int>(x => capturedA = x), Arg.Do<int>(x => capturedB = x));\ncalc.Add(1, 2);\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"KnockOff:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// KnockOff - built-in, no pre-setup\nvar tracking = stub.Add.Return((a, b) => a + b);\nICalculator calc = stub;\ncalc.Add(1, 2);\nvar (a, b) = tracking.LastArgs;  // Named tuple: a = 1, b = 2\n"})}),(0,r.jsxs)(t.p,{children:["For full comparisons of properties, events, delegates, and indexers, see the ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/comparison.md",children:"complete comparison guide"}),"."]}),(0,r.jsx)(t.hr,{}),(0,r.jsx)(t.h6,{id:"method-overload-resolution",children:"Method Overload Resolution"}),(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"The Problem:"})," When an interface has overloaded methods with the same parameter count but different types:"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"public interface IFormatter\n{\n    string Format(string input, bool uppercase);\n    string Format(string input, int maxLength);\n}\n"})}),(0,r.jsx)(t.p,{children:"######### Any-Value Matching"}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Moq:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:'// It.IsAny<T>() required - compiler needs the types to resolve overload\nmock.Setup(x => x.Format(It.IsAny<string>(), It.IsAny<bool>())).Returns("bool overload");\nmock.Setup(x => x.Format(It.IsAny<string>(), It.IsAny<int>())).Returns("int overload");\n'})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"NSubstitute:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:'// Arg.Any<T>() required - compiler needs the types to resolve overload\nformatter.Format(Arg.Any<string>(), Arg.Any<bool>()).Returns("bool overload");\nformatter.Format(Arg.Any<string>(), Arg.Any<int>()).Returns("int overload");\n'})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"KnockOff:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:'// Explicit parameter types resolve the overload - standard C# syntax\nstub.Format.Return((string input, bool uppercase) => "bool overload");\nstub.Format.Return((string input, int maxLength) => "int overload");\n'})}),(0,r.jsx)(t.p,{children:"######### Specific-Value Matching"}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"NSubstitute:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:'// Specific value matching - literals work when all args are specific\nformatter.Format("test", true).Returns("UPPERCASE");\nformatter.Format("test", 10).Returns("truncated");\n'})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"KnockOff:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:'// Specific value matching - parameter types resolve the overload\nstub.Format.When("test", true).Return("UPPERCASE");\nstub.Format.When("test", 10).Return("truncated");\n'})}),(0,r.jsx)(t.p,{children:"######### Argument Access"}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Moq:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// To use argument values, extract via Returns<T1, T2>:\nmock.Setup(x => x.Format(It.IsAny<string>(), It.IsAny<bool>()))\n    .Returns<string, bool>((input, uppercase) => uppercase ? input.ToUpper() : input);\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"NSubstitute:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// To use argument values, extract from CallInfo:\nformatter.Format(Arg.Any<string>(), Arg.Any<bool>())\n    .Returns(x => x.ArgAt<bool>(1) ? x.ArgAt<string>(0).ToUpper() : x.ArgAt<string>(0));\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"KnockOff:"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"// Arguments are directly available with names and types:\nstub.Format.Return((string input, bool uppercase) => uppercase ? input.ToUpper() : input);\n"})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"The Difference:"})}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Moq: ",(0,r.jsx)(t.code,{children:"It.IsAny<bool>()"})," + ",(0,r.jsx)(t.code,{children:".Returns<string, bool>((input, uppercase) => ...)"})," to match any value and access arguments"]}),"\n",(0,r.jsxs)(t.li,{children:["NSubstitute: ",(0,r.jsx)(t.code,{children:"Arg.Any<bool>()"})," + ",(0,r.jsx)(t.code,{children:"x.ArgAt<bool>(1)"})," to match any value and access arguments"]}),"\n",(0,r.jsxs)(t.li,{children:["KnockOff: ",(0,r.jsx)(t.code,{children:"(string input, bool uppercase)"})," - standard C# lambda with named, typed parameters"]}),"\n"]}),(0,r.jsx)(t.hr,{}),(0,r.jsx)(t.h6,{id:"three-stub-patterns",children:"Three Stub Patterns"}),(0,r.jsxs)(t.p,{children:["KnockOff supports ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/stub-patterns.md",children:"9 patterns"})," total. Here are the three most common:"]}),(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/stub-patterns.md#standalone-pattern",children:"Standalone"})})," - Reusable across your project:"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"[KnockOff]\npublic partial class ReadmeStandaloneStub : IUserRepo \\{ }\n"})}),(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/stub-patterns.md#inline-interface-pattern",children:"Inline Interface"})})," - Test-local stubs:"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"[Fact]\npublic void InlineInterface_Pattern()\n{\n    var stub = new Stubs.IUserRepo();\n    stub.GetUser.Return((id) => new User \\{ Id = id });\n\n    IUserRepo repo = stub;\n    Assert.NotNull(repo.GetUser(1));\n}\n"})}),(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/stub-patterns.md#inline-class-pattern",children:"Inline Class"})})," - Stub virtual members:"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cs",children:"[Fact]\npublic void InlineClass_Pattern()\n{\n    var stub = new Stubs.MyService();\n    stub.GetUser.Return((id) => new User \\{ Id = id });\n\n    MyService service = stub.Object;\n    Assert.NotNull(service.GetUser(1));\n}\n"})}),(0,r.jsx)(t.hr,{}),(0,r.jsx)(t.h6,{id:"roslyn-source-generation",children:"Roslyn Source Generation"}),(0,r.jsx)(t.p,{children:"KnockOff uses Roslyn source generation, which means:"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["No more ",(0,r.jsx)(t.code,{children:"Arg.Any<>()"}),". No more ",(0,r.jsx)(t.code,{children:"It.IsAny<>()"}),". Just write C#"]}),"\n",(0,r.jsx)(t.li,{children:"If the method signature changes you get a compile error"}),"\n",(0,r.jsx)(t.li,{children:"There's a small performance gain but honestly it's negligible"}),"\n"]}),(0,r.jsxs)(t.p,{children:["Source generation opens doors beyond traditional mocking \u2014 I've already added ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/stub-patterns.md",children:"9 patterns"})," and features like ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/source-delegation.md",children:"Source Delegation"}),", with more ideas to come."]}),(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"What other ideas do you have?"})," Open a ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/discussions",children:"discussion"}),"."]}),(0,r.jsx)(t.h6,{id:"ai",children:"AI"}),(0,r.jsx)(t.p,{children:"This is an idea I've had for years but never took the time to implement. With my ideas and guidance, Claude Code has written the entirety of this library \u2014 the Roslyn source generator, the runtime library, the tests, and the documentation."}),(0,r.jsx)(t.p,{children:"Source generation turned out to be a great fit for AI code generation. The work is highly patterned: analyze an interface, generate code for each member, handle edge cases across 9 patterns and 4 member types. That's exactly the kind of systematic, repetitive-but-varied work where AI excels. I designed the API and patterns; Claude Code implemented them across every combination."}),(0,r.jsx)(t.p,{children:"######### Claude Code Skill"}),(0,r.jsxs)(t.p,{children:["KnockOff includes a ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/skillsknockoff/",children:"Claude Code skill"})," that teaches Claude how to use the library. Copy the ",(0,r.jsx)(t.code,{children:"skills/knockoff/"})," directory into your project and Claude Code will know how to create stubs, configure behavior, write tests with KnockOff, and migrate from Moq \u2014 without you explaining the API."]}),(0,r.jsx)(t.p,{children:"The skill includes slash commands:"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"/knockoff:create-stub"})})," \u2014 Create a new stub class with the pattern of your choice"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"/knockoff:migrate-from-moq"})})," \u2014 Convert existing Moq tests to KnockOff"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"/knockoff:troubleshoot"})})," \u2014 Diagnose and fix common KnockOff issues"]}),"\n"]}),(0,r.jsx)(t.hr,{}),(0,r.jsx)(t.h6,{id:"documentation",children:"Documentation"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/getting-started.md",children:"Getting Started"})})," - Installation and first stub"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/stub-patterns.md",children:"Stub Patterns"})})," - Standalone, inline interface, inline class"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/reference/interceptor-api.md",children:"Interceptor API"})})," - Complete ",(0,r.jsx)(t.code,{children:"Returns"}),", ",(0,r.jsx)(t.code,{children:"Execute"}),", ",(0,r.jsx)(t.code,{children:"Get"}),", ",(0,r.jsx)(t.code,{children:"Set"})," reference"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/guides/source-delegation.md",children:"Source Delegation"})})," - Delegate to real implementations"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/comparison.md",children:"Full Comparison Guide"})})," - Properties, events, delegates, indexers vs Moq and NSubstitute"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/migration/from-moq.md",children:"Migration from Moq"})})," - Step-by-step migration guide"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/docs/migration/from-nsubstitute.md",children:"Migration from NSubstitute"})})," - Comparison and migration guide"]}),"\n"]}),(0,r.jsx)(t.hr,{}),(0,r.jsx)(t.h6,{id:"license",children:"License"}),(0,r.jsxs)(t.p,{children:["MIT License. See ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/LICENSE",children:"LICENSE"})," for details."]}),(0,r.jsx)(t.hr,{}),(0,r.jsx)(t.h6,{id:"contributing",children:"Contributing"}),(0,r.jsxs)(t.p,{children:["Contributions welcome! See ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/CONTRIBUTING.md",children:"CONTRIBUTING.md"})," for guidelines."]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Issues"}),": ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/issues",children:"GitHub Issues"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Pull Requests"}),": Bug fixes, features, documentation"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Discussions"}),": ",(0,r.jsx)(t.a,{href:"https://github.com/NeatooDotNet/KnockOff/discussions",children:"GitHub Discussions"})]}),"\n"]})]}),"\n",(0,r.jsx)(t.h3,{id:"about",children:"About"}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsx)(t.p,{children:"Generating test stubs with mocking for interfaces"})}),"\n",(0,r.jsx)(t.h2,{id:"how-to-use",children:"How to use"}),"\n",(0,r.jsx)(t.h3,{id:"example-source-csproj-source-files",children:"Example (source csproj, source files)"}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsxs)(a.A,{value:"csproj",label:"CSharp Project",children:[(0,r.jsxs)(t.p,{children:["This is the CSharp Project that references ",(0,r.jsx)(t.strong,{children:"KnockOff"})]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",metastring:"showLineNumbers {13}",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <TargetFramework>net10.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n\n    <IsPackable>false</IsPackable>\n    <IsTestProject>true</IsTestProject>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include="KnockOff" Version="0.49.0" />\n    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.5.0" />\n    <PackageReference Include="MSTest.TestAdapter" Version="2.2.10" />\n    <PackageReference Include="MSTest.TestFramework" Version="2.2.10" />\n    <PackageReference Include="coverlet.collector" Version="3.2.0" />\n  </ItemGroup>\n\n  <ItemGroup>\n    <ProjectReference Include="..\\Mock\\MockData.csproj" />\n  </ItemGroup>\n\t<PropertyGroup>\n\t\t<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n\t\t<CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n\t</PropertyGroup>\n\n</Project>\n\n'})})]}),(0,r.jsxs)(a.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\KnockOff\\src\\Mock\\IMyClock.cs",label:"IMyClock.cs",children:[(0,r.jsxs)(t.p,{children:["This is the use of ",(0,r.jsx)(t.strong,{children:"KnockOff"})," in ",(0,r.jsx)(t.em,{children:"IMyClock.cs"})]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"namespace MockData;\n\npublic interface IMyClock\n{\n    public DateTime GetNow();\n    public DateTime GetUtcNow();\n}\n"})})]}),(0,r.jsxs)(a.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\KnockOff\\src\\TestClock\\TestClock.cs",label:"TestClock.cs",children:[(0,r.jsxs)(t.p,{children:["This is the use of ",(0,r.jsx)(t.strong,{children:"KnockOff"})," in ",(0,r.jsx)(t.em,{children:"TestClock.cs"})]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"\nusing KnockOff;\n\nnamespace TestClock;\n\n[KnockOff]\npublic partial class QuickStartRepoStub : IMyClock \\{ }\n\n\n[TestClass]\npublic class TestClock\n{\n    [TestMethod]\n    public void TestMyClock()\n    {\n        var expectations = new QuickStartRepoStub();\n        expectations.GetNow.Return(DateTime.Now.AddYears(-1));\n        \n        IMyClock mock = expectations;\n        var data= mock.GetNow();\n        Assert.AreEqual(DateTime.Now.Year -1, data.Year);\n        expectations.Verify();\n    }\n}\n\n\n\n"})})]})]}),"\n",(0,r.jsx)(t.h3,{id:"generated-files",children:"Generated Files"}),"\n",(0,r.jsx)(t.p,{children:"Those are taken from $(BaseIntermediateOutputPath)\\GX"}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(a.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\KnockOff\\src\\TestClock\\obj\\GX\\KnockOff.Generator\\KnockOff.KnockOffGenerator\\QuickStartRepoStub.Base.g.cs",label:"QuickStartRepoStub.Base.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"// <auto-generated/>\n#nullable enable\n\nnamespace TestClock;\n\npublic class QuickStartRepoStubBase\n{\n\t/// <summary>Override to provide default implementation for global::MockData.IMyClock.GetNow.</summary>\n\tprotected virtual global::System.DateTime GetNow_() => default!;\n\n\t/// <summary>Override to provide default implementation for global::MockData.IMyClock.GetUtcNow.</summary>\n\tprotected virtual global::System.DateTime GetUtcNow_() => default!;\n\n}\n\n"})})}),(0,r.jsx)(a.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\KnockOff\\src\\TestClock\\obj\\GX\\KnockOff.Generator\\KnockOff.KnockOffGenerator\\QuickStartRepoStub.g.cs",label:"QuickStartRepoStub.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// <auto-generated/>\n#nullable enable\n\nusing System.Linq;\n\nnamespace TestClock;\n\npartial class QuickStartRepoStub : QuickStartRepoStubBase, global::MockData.IMyClock, global::KnockOff.IKnockOffStub\n{\n\t/// <summary>Tracks and configures behavior for GetNow.</summary>\n\tpublic sealed class GetNowInterceptor : global::KnockOff.Interceptors.MethodInterceptorBase<GetNowInterceptor.GetNowDelegate, global::KnockOff.Unit, global::System.DateTime>\n\t{\n\t\t/// <summary>Source object to delegate to when no callback is configured.</summary>\n\t\tinternal global::MockData.IMyClock? _source;\n\n\t\t/// <summary>Delegate for GetNow.</summary>\n\t\tpublic delegate global::System.DateTime GetNowDelegate();\n\n\t\tpublic GetNowInterceptor() : base("GetNow") \\{ }\n\n\t\tprotected override global::System.DateTime InvokeDelegate(GetNowDelegate del, global::KnockOff.Unit args) => del();\n\t\tprotected override GetNowDelegate CreateValueDelegate(global::System.DateTime value) => () => value;\n\t\tprotected override void RecordArgs(global::KnockOff.Unit args, MethodCallBuilderBase tracking) \\{ }\n\t\tprotected override void RecordUnconfiguredArgs(global::KnockOff.Unit args) \\{ }\n\n\t\t/// <summary>Configures callback that repeats indefinitely. Returns builder for sequence chaining.</summary>\n\t\tpublic MethodCallBuilderImpl Return(GetNowDelegate callback)\n\t\t{\n\t\t\tvar builder = new MethodCallBuilderImpl(this);\n\t\t\tSetupReturnCallback(callback, builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\t/// <summary>Configures return value that repeats indefinitely. Returns builder for sequence chaining.</summary>\n\t\tpublic MethodCallBuilderImpl Return(global::System.DateTime value)\n\t\t{\n\t\t\tvar builder = new MethodCallBuilderImpl(this);\n\t\t\tSetupReturnValue(value, builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\t/// <summary>Configures sequence of return values. Each value returned once, last repeats.</summary>\n\t\tpublic ReturnMethodSequenceBase Return(global::System.DateTime first, params global::System.DateTime[] rest)\n\t\t{\n\t\t\tvar builder = Return(() => first);\n\t\t\tif (rest.Length == 0)\n\t\t\t{\n\t\t\t\treturn builder.ThenReturn(first);\n\t\t\t}\n\t\t\tvar seq = builder.ThenReturn(rest[0]);\n\t\t\tfor (int i = 1; i < rest.Length; i++)\n\t\t\t{\n\t\t\t\tseq.ThenReturn(rest[i]);\n\t\t\t}\n\t\t\treturn seq;\n\t\t}\n\n\t\t/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>\n\t\tinternal global::System.DateTime Invoke(bool strict)\n\t\t{\n\t\t\tvar (handled, result) = RunPriorityChain(default);\n\t\t\tif (handled) return result;\n\t\t\t_unconfiguredCallCount++;\n\t\t\tRecordUnconfiguredArgs(default);\n\t\t\tvar (seqHandled, seqResult) = HandleNonVoidSequenceExhaustedRepeat(strict, default);\n\t\t\tif (seqHandled) return seqResult;\n\t\t\t#pragma warning disable CS8601, SYSLIB0050\n\t\t\tif (_source is \\{ \\} src) return src.GetNow();\n\t\t\t#pragma warning restore CS8601, SYSLIB0050\n\t\t\tif (strict) throw global::KnockOff.StubException.NotConfigured("", "GetNow");\n\t\t\treturn default!;\n\t\t}\n\n\t\t/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>\n\t\tpublic override void Reset()\n\t\t{\n\t\t\tbase.Reset();\n\t\t\t_source = null;\n\t\t}\n\n\t\t/// <summary>Builder for callback registration. Supports tracking and lazy elevation to sequence.</summary>\n\t\tpublic sealed class MethodCallBuilderImpl : ReturnMethodCallBuilderBase, global::KnockOff.IMethodReturnBuilder<GetNowDelegate>\n\t\t{\n\t\t\tprivate readonly GetNowInterceptor _typedInterceptor;\n\n\t\t\tpublic MethodCallBuilderImpl(GetNowInterceptor interceptor) : base(interceptor)\n\t\t\t{\n\t\t\t\t_typedInterceptor = interceptor;\n\t\t\t}\n\n\n\t\t\tpublic override void Reset() => base.Reset();\n\n\t\t\t/// <summary>Elevates to sequence mode and adds another callback. Returns sequence for further chaining.</summary>\n\t\t\tpublic ReturnMethodSequenceBase ThenReturn(GetNowDelegate callback)\n\t\t\t{\n\t\t\t\treturn ThenReturnBase(callback);\n\t\t\t}\n\n\t\t\t/// <summary>Elevates to sequence mode and adds a value. Returns sequence for further chaining.</summary>\n\t\t\tpublic ReturnMethodSequenceBase ThenReturn(global::System.DateTime value) => ThenReturn(() => value);\n\n\t\t\t/// <summary>Adds multiple values to the sequence. Each value returned once.</summary>\n\t\t\tpublic ReturnMethodSequenceBase ThenReturn(params global::System.DateTime[] values)\n\t\t\t{\n\t\t\t\tif (values.Length == 0) \\{ ElevateToSequenceBase(); return new ReturnMethodSequenceBase(_typedInterceptor, CreateNextReturnBuilder); }\n\t\t\t\tvar seq = ThenReturn(values[0]);\n\t\t\t\tfor (int i = 1; i < values.Length; i++) seq.ThenReturn(values[i]);\n\t\t\t\treturn seq;\n\t\t\t}\n\n\t\t\t/// <summary>Marks for verification by Stub.Verify().</summary>\n\t\t\tpublic MethodCallBuilderImpl Verifiable() \\{ VerifiableBase(); return this; }\n\t\t\t/// <summary>Marks for verification by Stub.Verify() with Called constraint.</summary>\n\t\t\tpublic MethodCallBuilderImpl Verifiable(global::KnockOff.Called times) \\{ VerifiableBase(times); return this; }\n\n\t\t\tprotected override ReturnMethodCallBuilderBase CreateNextReturnBuilder() => new MethodCallBuilderImpl(_typedInterceptor);\n\n\t\t\tglobal::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();\n\t\t\tglobal::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Called times) => Verifiable(times);\n\t\t\tglobal::KnockOff.IMethodReturnBuilder<GetNowDelegate> global::KnockOff.IMethodReturnBuilder<GetNowDelegate>.Verifiable() => Verifiable();\n\t\t\tglobal::KnockOff.IMethodReturnBuilder<GetNowDelegate> global::KnockOff.IMethodReturnBuilder<GetNowDelegate>.Verifiable(global::KnockOff.Called times) => Verifiable(times);\n\t\t\tglobal::KnockOff.IMethodReturnSequence<GetNowDelegate> global::KnockOff.IMethodReturnBuilder<GetNowDelegate>.ThenReturn(GetNowDelegate callback) => ThenReturn(callback);\n\t\t}\n\n\t}\n\n\t/// <summary>Tracks and configures behavior for GetUtcNow.</summary>\n\tpublic sealed class GetUtcNowInterceptor : global::KnockOff.Interceptors.MethodInterceptorBase<GetUtcNowInterceptor.GetUtcNowDelegate, global::KnockOff.Unit, global::System.DateTime>\n\t{\n\t\t/// <summary>Source object to delegate to when no callback is configured.</summary>\n\t\tinternal global::MockData.IMyClock? _source;\n\n\t\t/// <summary>Delegate for GetUtcNow.</summary>\n\t\tpublic delegate global::System.DateTime GetUtcNowDelegate();\n\n\t\tpublic GetUtcNowInterceptor() : base("GetUtcNow") \\{ }\n\n\t\tprotected override global::System.DateTime InvokeDelegate(GetUtcNowDelegate del, global::KnockOff.Unit args) => del();\n\t\tprotected override GetUtcNowDelegate CreateValueDelegate(global::System.DateTime value) => () => value;\n\t\tprotected override void RecordArgs(global::KnockOff.Unit args, MethodCallBuilderBase tracking) \\{ }\n\t\tprotected override void RecordUnconfiguredArgs(global::KnockOff.Unit args) \\{ }\n\n\t\t/// <summary>Configures callback that repeats indefinitely. Returns builder for sequence chaining.</summary>\n\t\tpublic MethodCallBuilderImpl Return(GetUtcNowDelegate callback)\n\t\t{\n\t\t\tvar builder = new MethodCallBuilderImpl(this);\n\t\t\tSetupReturnCallback(callback, builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\t/// <summary>Configures return value that repeats indefinitely. Returns builder for sequence chaining.</summary>\n\t\tpublic MethodCallBuilderImpl Return(global::System.DateTime value)\n\t\t{\n\t\t\tvar builder = new MethodCallBuilderImpl(this);\n\t\t\tSetupReturnValue(value, builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\t/// <summary>Configures sequence of return values. Each value returned once, last repeats.</summary>\n\t\tpublic ReturnMethodSequenceBase Return(global::System.DateTime first, params global::System.DateTime[] rest)\n\t\t{\n\t\t\tvar builder = Return(() => first);\n\t\t\tif (rest.Length == 0)\n\t\t\t{\n\t\t\t\treturn builder.ThenReturn(first);\n\t\t\t}\n\t\t\tvar seq = builder.ThenReturn(rest[0]);\n\t\t\tfor (int i = 1; i < rest.Length; i++)\n\t\t\t{\n\t\t\t\tseq.ThenReturn(rest[i]);\n\t\t\t}\n\t\t\treturn seq;\n\t\t}\n\n\t\t/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>\n\t\tinternal global::System.DateTime Invoke(bool strict)\n\t\t{\n\t\t\tvar (handled, result) = RunPriorityChain(default);\n\t\t\tif (handled) return result;\n\t\t\t_unconfiguredCallCount++;\n\t\t\tRecordUnconfiguredArgs(default);\n\t\t\tvar (seqHandled, seqResult) = HandleNonVoidSequenceExhaustedRepeat(strict, default);\n\t\t\tif (seqHandled) return seqResult;\n\t\t\t#pragma warning disable CS8601, SYSLIB0050\n\t\t\tif (_source is \\{ \\} src) return src.GetUtcNow();\n\t\t\t#pragma warning restore CS8601, SYSLIB0050\n\t\t\tif (strict) throw global::KnockOff.StubException.NotConfigured("", "GetUtcNow");\n\t\t\treturn default!;\n\t\t}\n\n\t\t/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>\n\t\tpublic override void Reset()\n\t\t{\n\t\t\tbase.Reset();\n\t\t\t_source = null;\n\t\t}\n\n\t\t/// <summary>Builder for callback registration. Supports tracking and lazy elevation to sequence.</summary>\n\t\tpublic sealed class MethodCallBuilderImpl : ReturnMethodCallBuilderBase, global::KnockOff.IMethodReturnBuilder<GetUtcNowDelegate>\n\t\t{\n\t\t\tprivate readonly GetUtcNowInterceptor _typedInterceptor;\n\n\t\t\tpublic MethodCallBuilderImpl(GetUtcNowInterceptor interceptor) : base(interceptor)\n\t\t\t{\n\t\t\t\t_typedInterceptor = interceptor;\n\t\t\t}\n\n\n\t\t\tpublic override void Reset() => base.Reset();\n\n\t\t\t/// <summary>Elevates to sequence mode and adds another callback. Returns sequence for further chaining.</summary>\n\t\t\tpublic ReturnMethodSequenceBase ThenReturn(GetUtcNowDelegate callback)\n\t\t\t{\n\t\t\t\treturn ThenReturnBase(callback);\n\t\t\t}\n\n\t\t\t/// <summary>Elevates to sequence mode and adds a value. Returns sequence for further chaining.</summary>\n\t\t\tpublic ReturnMethodSequenceBase ThenReturn(global::System.DateTime value) => ThenReturn(() => value);\n\n\t\t\t/// <summary>Adds multiple values to the sequence. Each value returned once.</summary>\n\t\t\tpublic ReturnMethodSequenceBase ThenReturn(params global::System.DateTime[] values)\n\t\t\t{\n\t\t\t\tif (values.Length == 0) \\{ ElevateToSequenceBase(); return new ReturnMethodSequenceBase(_typedInterceptor, CreateNextReturnBuilder); }\n\t\t\t\tvar seq = ThenReturn(values[0]);\n\t\t\t\tfor (int i = 1; i < values.Length; i++) seq.ThenReturn(values[i]);\n\t\t\t\treturn seq;\n\t\t\t}\n\n\t\t\t/// <summary>Marks for verification by Stub.Verify().</summary>\n\t\t\tpublic MethodCallBuilderImpl Verifiable() \\{ VerifiableBase(); return this; }\n\t\t\t/// <summary>Marks for verification by Stub.Verify() with Called constraint.</summary>\n\t\t\tpublic MethodCallBuilderImpl Verifiable(global::KnockOff.Called times) \\{ VerifiableBase(times); return this; }\n\n\t\t\tprotected override ReturnMethodCallBuilderBase CreateNextReturnBuilder() => new MethodCallBuilderImpl(_typedInterceptor);\n\n\t\t\tglobal::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();\n\t\t\tglobal::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Called times) => Verifiable(times);\n\t\t\tglobal::KnockOff.IMethodReturnBuilder<GetUtcNowDelegate> global::KnockOff.IMethodReturnBuilder<GetUtcNowDelegate>.Verifiable() => Verifiable();\n\t\t\tglobal::KnockOff.IMethodReturnBuilder<GetUtcNowDelegate> global::KnockOff.IMethodReturnBuilder<GetUtcNowDelegate>.Verifiable(global::KnockOff.Called times) => Verifiable(times);\n\t\t\tglobal::KnockOff.IMethodReturnSequence<GetUtcNowDelegate> global::KnockOff.IMethodReturnBuilder<GetUtcNowDelegate>.ThenReturn(GetUtcNowDelegate callback) => ThenReturn(callback);\n\t\t}\n\n\t}\n\n\t/// <summary>Interceptor for GetNow.</summary>\n\tpublic GetNowInterceptor GetNow \\{ get; \\} = new();\n\n\t/// <summary>Interceptor for GetUtcNow.</summary>\n\tpublic GetUtcNowInterceptor GetUtcNow \\{ get; \\} = new();\n\n\t/// <summary>When true, throws StubException for unconfigured member access.</summary>\n\tpublic bool Strict \\{ get; set; \\} = false;\n\n\t/// <summary>The global::MockData.IMyClock instance. Use for passing to code expecting the interface.</summary>\n\tpublic global::MockData.IMyClock Object => this;\n\n\t/// <summary>Verifies all members marked with .Verifiable() were invoked as expected. Throws VerificationException with all failures if any fail.</summary>\n\tpublic void Verify()\n\t{\n\t\tvar failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();\n\n\t\tif (GetNow.CheckVerification() is \\{ \\} getnowFailure) failures.Add(getnowFailure);\n\t\tif (GetUtcNow.CheckVerification() is \\{ \\} getutcnowFailure) failures.Add(getutcnowFailure);\n\n\t\tif (failures.Count > 0)\n\t\t\tthrow new global::KnockOff.VerificationException(failures);\n\t}\n\n\t/// <summary>Verifies ALL configured members were invoked at least once. Throws VerificationException with all failures if any fail.</summary>\n\tpublic void VerifyAll()\n\t{\n\t\tvar failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();\n\n\t\tif (GetNow.CheckVerificationAll() is \\{ \\} getnowFailure) failures.Add(getnowFailure);\n\t\tif (GetUtcNow.CheckVerificationAll() is \\{ \\} getutcnowFailure) failures.Add(getutcnowFailure);\n\n\t\tif (failures.Count > 0)\n\t\t\tthrow new global::KnockOff.VerificationException(failures);\n\t}\n\n\t// Source(T) methods for interface delegation\n\n\t/// <summary>Delegates unconfigured member access to the provided source object (global::MockData.IMyClock).</summary>\n\t/// <param name="source">The source to delegate to, or null to clear.</param>\n\tpublic void Source(global::MockData.IMyClock? source)\n\t{\n\t\tGetNow._source = source;\n\t\tGetUtcNow._source = source;\n\t}\n\n\tglobal::System.DateTime global::MockData.IMyClock.GetNow()\n\t{\n\t\treturn GetNow.Invoke(Strict);\n\t}\n\n\tglobal::System.DateTime global::MockData.IMyClock.GetUtcNow()\n\t{\n\t\treturn GetUtcNow.Invoke(Strict);\n\t}\n\n}\n\n'})})})]}),"\n",(0,r.jsx)(t.h2,{id:"useful",children:"Useful"}),"\n",(0,r.jsx)(t.h3,{id:"download-example-net--c",children:"Download Example (.NET  C#)"}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(319).A+"",children:"Download Example project KnockOff "})})}),"\n",(0,r.jsx)(t.h3,{id:"share-knockoff",children:"Share KnockOff"}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FKnockOff&quote=KnockOff",title:"Share on Facebook",target:"_blank",children:"Share on Facebook"})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FKnockOff&text=KnockOff:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FKnockOff",target:"_blank",title:"Tweet",children:"Share in Twitter"})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FKnockOff&title=KnockOff",target:"_blank",title:"Submit to Reddit",children:"Share on Reddit"})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FKnockOff&title=KnockOff&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FKnockOff",target:"_blank",title:"Share on LinkedIn",children:"Share on Linkedin"})})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/KnockOff",children:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/KnockOff"})}),"\n",(0,r.jsx)(c.Ay,{})]})}function g(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}}}]);