"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[5559],{10717:(e,n,s)=>{s.d(n,{Ay:()=>l,RM:()=>r});var t=s(74848),a=s(28453);const r=[{value:"Category &quot;Enum&quot; has the following generators:",id:"category-enum-has-the-following-generators",level:3},{value:"See category",id:"see-category",level:3}];function i(e){const n={a:"a",h3:"h3",p:"p",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h3,{id:"category-enum-has-the-following-generators",children:'Category "Enum" has the following generators:'}),"\n",(0,t.jsxs)(n.p,{children:["1 ",(0,t.jsx)(n.a,{href:"/docs/CredFetoEnum",children:"CredFetoEnum"})]}),"\n",(0,t.jsxs)(n.p,{children:["2 ",(0,t.jsx)(n.a,{href:"/docs/EnumClass",children:"EnumClass"})]}),"\n",(0,t.jsxs)(n.p,{children:["3 ",(0,t.jsx)(n.a,{href:"/docs/EnumsEnhanced",children:"EnumsEnhanced"})]}),"\n",(0,t.jsxs)(n.p,{children:["4 ",(0,t.jsx)(n.a,{href:"/docs/EnumUtilities",children:"EnumUtilities"})]}),"\n",(0,t.jsxs)(n.p,{children:["5 ",(0,t.jsx)(n.a,{href:"/docs/Flaggen",children:"Flaggen"})]}),"\n",(0,t.jsxs)(n.p,{children:["6 ",(0,t.jsx)(n.a,{href:"/docs/FusionReactor",children:"FusionReactor"})]}),"\n",(0,t.jsxs)(n.p,{children:["7 ",(0,t.jsx)(n.a,{href:"/docs/Genbox.FastEnum",children:"Genbox.FastEnum"})]}),"\n",(0,t.jsxs)(n.p,{children:["8 ",(0,t.jsx)(n.a,{href:"/docs/jos.enumeration",children:"jos.enumeration"})]}),"\n",(0,t.jsxs)(n.p,{children:["9 ",(0,t.jsx)(n.a,{href:"/docs/NetEscapades.EnumGenerators",children:"NetEscapades.EnumGenerators"})]}),"\n",(0,t.jsxs)(n.p,{children:["10 ",(0,t.jsx)(n.a,{href:"/docs/PMart.Enumeration",children:"PMart.Enumeration"})]}),"\n",(0,t.jsx)(n.h3,{id:"see-category",children:"See category"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"/docs/Categories/Enum",children:"Enum"})})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(i,{...e})}):i(e)}},13570:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>m,default:()=>g,frontMatter:()=>c,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"RSCG-Examples/EnumsEnhanced","title":"217 - EnumsEnhanced","description":"generating enums fast retrieval","source":"@site/docs/RSCG-Examples/EnumsEnhanced.md","sourceDirName":"RSCG-Examples","slug":"/EnumsEnhanced","permalink":"/RSCG_Examples/v2/docs/EnumsEnhanced","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2170,"frontMatter":{"sidebar_position":2170,"title":"217 - EnumsEnhanced","description":"generating enums fast retrieval","slug":"/EnumsEnhanced"},"sidebar":"tutorialSidebar","previous":{"title":"216 - SG4MVC","permalink":"/RSCG_Examples/v2/docs/SG4MVC"},"next":{"title":"218 - Nino","permalink":"/RSCG_Examples/v2/docs/Nino"}}');var a=s(74848),r=s(28453),i=s(11470),l=s(19365),u=s(14252),o=s(10717);const c={sidebar_position:2170,title:"217 - EnumsEnhanced",description:"generating enums fast retrieval",slug:"/EnumsEnhanced"},m="EnumsEnhanced  by VNCC",d={},h=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Author",id:"author",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example (source csproj, source files)",id:"example-source-csproj-source-files",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C#)",id:"download-example-net--c",level:3},{value:"Share EnumsEnhanced",id:"share-enumsenhanced",level:3},...o.RM];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"enumsenhanced--by-vncc",children:"EnumsEnhanced  by VNCC"})}),"\n",(0,a.jsx)(u.A,{toc:h}),"\n",(0,a.jsx)(n.h2,{id:"nuget--site-data",children:"NuGet / site data"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://www.nuget.org/packages/EnumsEnhanced/",children:(0,a.jsx)(n.img,{src:"https://img.shields.io/nuget/dt/EnumsEnhanced?label=EnumsEnhanced",alt:"Nuget"})}),"\n",(0,a.jsx)(n.a,{href:"https://github.com/snowberry-software/EnumsEnhanced",children:(0,a.jsx)(n.img,{src:"https://img.shields.io/github/last-commit/snowberry-software/EnumsEnhanced?label=updated",alt:"GitHub last commit"})}),"\n",(0,a.jsx)(n.img,{src:"https://img.shields.io/github/stars/snowberry-software/EnumsEnhanced?style=social",alt:"GitHub Repo stars"})]}),"\n",(0,a.jsx)(n.h2,{id:"details",children:"Details"}),"\n",(0,a.jsx)(n.h3,{id:"info",children:"Info"}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsxs)(n.p,{children:["Name: ",(0,a.jsx)(n.strong,{children:"EnumsEnhanced"})]}),(0,a.jsx)(n.p,{children:"Source generator for generating common (extension) methods for enums without having the cost of the Reflection API."}),(0,a.jsx)(n.p,{children:"Author: VNCC"}),(0,a.jsxs)(n.p,{children:["NuGet:\n",(0,a.jsx)(n.em,{children:(0,a.jsx)(n.a,{href:"https://www.nuget.org/packages/EnumsEnhanced/",children:"https://www.nuget.org/packages/EnumsEnhanced/"})})]}),(0,a.jsxs)(n.p,{children:["You can find more details at ",(0,a.jsx)(n.a,{href:"https://github.com/snowberry-software/EnumsEnhanced",children:"https://github.com/snowberry-software/EnumsEnhanced"})]}),(0,a.jsxs)(n.p,{children:["Source: ",(0,a.jsx)(n.a,{href:"https://github.com/snowberry-software/EnumsEnhanced",children:"https://github.com/snowberry-software/EnumsEnhanced"})]})]}),"\n",(0,a.jsx)(n.h3,{id:"author",children:"Author"}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["VNCC\n",(0,a.jsx)(n.img,{src:"https://github.com/VNNCC.png",alt:"Alt text"})]})}),"\n",(0,a.jsx)(n.h3,{id:"original-readme",children:"Original Readme"}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/snowberry-software/EnumsEnhanced/blob/master/LICENSE",children:(0,a.jsx)(n.img,{src:"https://img.shields.io/github/license/snowberry-software/EnumsEnhanced",alt:"License"})}),"\n",(0,a.jsx)(n.a,{href:"https://www.nuget.org/packages/EnumsEnhanced/",children:(0,a.jsx)(n.img,{src:"https://img.shields.io/nuget/v/EnumsEnhanced.svg?logo=nuget",alt:"NuGet Version"})})]}),(0,a.jsx)(n.h1,{id:"enumsenhanced",children:"EnumsEnhanced"}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"EnumsEnhanced"})," is a C# ",(0,a.jsx)(n.a,{href:"https://devblogs.microsoft.com/dotnet/introducing-c-source-generators",children:"source generator"})," for generating common (extension) methods for enums without having the cost of the Reflection API (slow and many allocations)."]}),(0,a.jsx)(n.p,{children:"Following extension methods will be generated for each enum:"}),(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Default"}),(0,a.jsx)(n.th,{children:"Equivalent"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"GetName"}),(0,a.jsx)(n.td,{children:"GetNameFast"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"GetNames"}),(0,a.jsx)(n.td,{children:"GetNamesFast"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"GetValues"}),(0,a.jsx)(n.td,{children:"GetValuesFast"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"HasFlag"}),(0,a.jsx)(n.td,{children:"HasFlagFast, HasFlagUnsafe"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"IsDefined"}),(0,a.jsx)(n.td,{children:"IsDefinedFast"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Parse"}),(0,a.jsx)(n.td,{children:"ParseFast"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"TryParse"}),(0,a.jsx)(n.td,{children:"TryParseFast"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"ToString"}),(0,a.jsx)(n.td,{children:"ToStringFast"})]})]})]}),(0,a.jsx)(n.h1,{id:"how-to-use-it",children:"How to use it"}),(0,a.jsxs)(n.p,{children:["The project that makes use of this package must enable ",(0,a.jsx)(n.code,{children:"AllowUnsafeBlocks"})," in order to allow compiling the ",(0,a.jsx)(n.code,{children:"HasFlagUnsafe"})," extension method."]}),(0,a.jsx)(n.p,{children:"Also it will only generate the extension methods if the enum has no containing type."}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"internal class EnumContainingTypeTest\n{\n    // Will not generate any code for this enum.\n    public enum ContainingTypeEnum\n    {\n        Test1\n    }\n}\n"})}),(0,a.jsxs)(n.p,{children:["The generated class will always have the same naming scheme by using your enum type name with an ",(0,a.jsx)(n.code,{children:"Enhanced"})," postfix (e.g. ",(0,a.jsx)(n.strong,{children:"YourEnumName"}),(0,a.jsx)(n.code,{children:"Enhanced"}),")\nor in this example ",(0,a.jsx)(n.strong,{children:"TestEnumEnhanced"}),"."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"namespace EnumsEnhancedTest;\n\n[Flags]\ninternal enum TestEnum\n{\n    Test1 = 1 << 0,\n    Test_1 = 1 << 0,\n\n    Test2 = 1 << 1,\n    Test4 = 1 << 2,\n    Test5 = 1 << 4,\n    Test6 = 1 << 6,\n    Test7\n}\n"})}),(0,a.jsx)(n.p,{children:"Generated code:"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'#nullable enable\n\nusing System.Text;\nusing System.Runtime.CompilerServices;\nusing System.Collections.Generic;\nusing System;\nusing System;\nusing System.Globalization;\n\nnamespace EnumsEnhancedTest {\n  /// <summary>\n  /// Reflection free extension methods for the <see cref="TestEnum"/> type.\n  /// </summary>\n  internal static partial class TestEnumEnhanced {\n\n    /// <summary>\n    /// Determines whether one or more bit fields are set in the current instance.\n    /// </summary>\n    /// <param name="e">The value of the enum.</param>\n    /// <param name="flag">The flag to check.</param>\n    /// <returns><see langword="true"/> if the bit field or bit fields that are set in flag are also set in the current instance; otherwise, false.</returns>\n    #if NETCOREAPP3_0_OR_GREATER\n      [MethodImplAttribute(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]\n    #else\n      [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\n    #endif\n\n    public static bool HasFlagFast(this TestEnum e, TestEnum flag) {\n      return (e & flag) == flag;\n    }\n\n    /// <inheritdoc cref="HasFlagFast(TestEnum, TestEnum)"/>\n    #if NETCOREAPP3_0_OR_GREATER\n      [MethodImplAttribute(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]\n    #else\n      [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\n    #endif\n\n    public static unsafe bool HasFlagFastUnsafe(this TestEnum e, TestEnum flag) {\n      return HasFlagFastUnsafe( & e, & flag);\n    }\n\n    /// <summary>\n    /// Determines whether one or more bit fields are set in the current instance using unsafe pointer type casting.\n    /// </summary>\n    /// <param name="e">The value of the enum.</param>\n    /// <param name="flag">The flag to check.</param>\n    /// <returns><see langword="true"/> if the bit field or bit fields that are set in flag are also set in the current instance; otherwise, false.</returns>\n    #if NETCOREAPP3_0_OR_GREATER\n      [MethodImplAttribute(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]\n    #else\n      [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\n    #endif\n\n    public static unsafe bool HasFlagFastUnsafe(TestEnum * e, TestEnum * flag) {\n      return ( * (int * ) e & * (int * ) flag) == * (int * ) flag;\n    }\n\n    /// <summary>\n    /// Retrieves an array of the names of the constants.\n    /// </summary>\n    /// <returns>A string array of the names of the constants.</returns>\n    public static string[] GetNamesFast() {\n      return new string[] {\n        "Test1",\n        "Test_1",\n        "Test2",\n        "Test4",\n        "Test5",\n        "Test6",\n        "Test7"\n      };\n    }\n\n    /// <summary>\n    /// Retrieves an array of the values of the constants.\n    /// </summary>\n    /// <returns>An array that contains the values of the constants.</returns>\n    public static TestEnum[] GetValuesFast() {\n      return new TestEnum[] {\n        TestEnum.Test1, TestEnum.Test_1, TestEnum.Test2, TestEnum.Test4, TestEnum.Test5, TestEnum.Test6, TestEnum.Test7\n      };\n    }\n\n    /// <inheritdoc cref="IsDefinedFast(TestEnum)"/>\n    public static bool IsDefinedFast(string value) {\n      _ = value ??\n        throw new ArgumentNullException(nameof(value));\n\n      switch (value) {\n      case "Test1":\n        return true;\n      case "Test2":\n        return true;\n      case "Test4":\n        return true;\n      case "Test5":\n        return true;\n      case "Test6":\n        return true;\n      case "Test7":\n        return true;\n      case "Test_1":\n        return true;\n\n      }\n\n      return false;\n    }\n\n    /// <inheritdoc cref="IsDefinedFast(TestEnum)"/>\n    #if NETCOREAPP3_0_OR_GREATER\n      [MethodImplAttribute(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]\n    #else\n      [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\n    #endif\n\n    public static bool IsDefinedFast(Int32 value) {\n      return IsDefinedFast((TestEnum) value);\n    }\n\n    /// <summary>\n    /// Returns a <see cref="bool"/> telling whether its given value exists in the enumeration.\n    /// </summary>\n    /// <param name="value">The value of the enumeration constant.</param>\n    /// <returns><see langword="true"/> if a constant is defined with the given value from the <paramref name="value"/>.</returns>\n    public static bool IsDefinedFast(TestEnum value) {\n      switch (value) {\n      case TestEnum.Test1:\n        return true;\n      case TestEnum.Test2:\n        return true;\n      case TestEnum.Test4:\n        return true;\n      case TestEnum.Test5:\n        return true;\n      case TestEnum.Test6:\n        return true;\n      case TestEnum.Test7:\n        return true;\n        // Skipping duplicated constant value: TestEnum.Test_1 -> 1\n\n      }\n\n      return false;\n    }\n\n    /// <summary>\n    /// Resolves the name of the given enum value.\n    /// </summary>\n    /// <param name="e">The value of a particular enumerated constant in terms of its underlying type.</param>\n    /// <param name="includeFlagNames">Determines whether the value has flags, so it will return `EnumValue, EnumValue2`.</param>\n    /// <returns> A string containing the name of the enumerated constant or <see langword="null"/> if the enum has multiple flags set but <paramref name="includeFlagNames"/> is not enabled.</returns>\n    public static string ? GetNameFast(this TestEnum e, bool includeFlagNames = false) {\n      switch (e) {\n      case TestEnum.Test1:\n        return nameof(TestEnum.Test1);\n\n        // Skipping duplicated constant value: TestEnum.Test_1 -> 1\n\n      case TestEnum.Test2:\n        return nameof(TestEnum.Test2);\n\n      case TestEnum.Test4:\n        return nameof(TestEnum.Test4);\n\n      case TestEnum.Test5:\n        return nameof(TestEnum.Test5);\n\n      case TestEnum.Test6:\n        return nameof(TestEnum.Test6);\n\n      case TestEnum.Test7:\n        return nameof(TestEnum.Test7);\n\n      }\n\n      // Returning null is the default behavior.\n      if (!includeFlagNames)\n        return null;\n      //throw new Exception("Enum name could not be found!");\n\n      var flagBuilder = new StringBuilder();\n      if (e.HasFlagFast(TestEnum.Test1))\n        flagBuilder.Append(TestEnum.Test1.GetNameFast(false) + ", ");\n\n      // Skipping duplicated constant value: TestEnum.Test_1 -> 1\n\n      if (e.HasFlagFast(TestEnum.Test2))\n        flagBuilder.Append(TestEnum.Test2.GetNameFast(false) + ", ");\n\n      if (e.HasFlagFast(TestEnum.Test4))\n        flagBuilder.Append(TestEnum.Test4.GetNameFast(false) + ", ");\n\n      if (e.HasFlagFast(TestEnum.Test5))\n        flagBuilder.Append(TestEnum.Test5.GetNameFast(false) + ", ");\n\n      if (e.HasFlagFast(TestEnum.Test6))\n        flagBuilder.Append(TestEnum.Test6.GetNameFast(false) + ", ");\n\n      if (e.HasFlagFast(TestEnum.Test7))\n        flagBuilder.Append(TestEnum.Test7.GetNameFast(false) + ", ");\n\n      return flagBuilder.ToString().Trim(new char[] {\n        \',\',\n        \' \'\n      });\n    }\n\n    /// <summary>\n    /// Converts the value of this instance to its equivalent string representation.\n    /// </summary>\n    /// <param name="e">The value of a particular enumerated constant in terms of its underlying type.</param>\n    /// <returns>The string representation of the value of this instance.</returns>\n    #if NETCOREAPP3_0_OR_GREATER\n      [MethodImplAttribute(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]\n    #else\n      [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\n    #endif\n\n    public static string ? ToStringFast(this TestEnum e) {\n      return GetNameFast(e, true);\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.\n    /// </summary>\n    /// <param name="value">A string containing the name or value to convert.</param>\n    /// <param name="ignoreCase"><see langword="true"/> to ignore case; false to regard case.</param>\n    /// <param name="result">The result of the enumeration constant.</param>\n    /// <returns><see langword="true"/> if the conversion succeeded; <see langword="false"/> otherwise.</returns>\n    public static bool TryParseFast(string value, bool ignoreCase, out TestEnum result) {\n      result = ParseFast(out\n        var successful, value: value, ignoreCase: ignoreCase, throwOnFailure: false);\n      return successful;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.\n    /// </summary>\n    /// <param name="value">A string containing the name or value to convert.</param>\n    /// <param name="ignoreCase"><see langword="true"/> to ignore case; false to regard case.</param>\n    /// <returns>The enumeration value whose value is represented by the given value.</returns>\n    public static TestEnum ParseFast(string value, bool ignoreCase = false) {\n      return ParseFast(out _, value: value, ignoreCase: ignoreCase, throwOnFailure: true);\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.\n    /// </summary>\n    /// <param name="successful"><see langword="true"/> if the conversion succeeded; <see langword="false"/> otherwise.</param>\n    /// <param name="value">A string containing the name or value to convert.</param>\n    /// <param name="ignoreCase"><see langword="true"/> to ignore case; false to regard case.</param>\n    /// <param name="throwOnFailure">Determines whether to throw an <see cref="Exception"/> on errors or not.</param>\n    /// <returns>The enumeration value whose value is represented by the given value.</returns>\n    public static TestEnum ParseFast(out bool successful, string value, bool ignoreCase = false, bool throwOnFailure = true) {\n      successful = false;\n\n      if (throwOnFailure && (string.IsNullOrEmpty(value) || string.IsNullOrWhiteSpace(value))) {\n        throw new ArgumentException("Value can\'t be null or whitespace!", nameof(value));\n      }\n\n      Int32 localResult = 0;\n      bool parsed = false;\n      string subValue;\n      string originalValue = value;\n      char firstChar = value[0];\n\n      if (char.IsDigit(firstChar) || firstChar == \'-\' || firstChar == \'+\') {\n        if (Int32.TryParse(value, NumberStyles.AllowLeadingSign | NumberStyles.AllowTrailingWhite, null, out\n            var valueNumber))\n          switch (valueNumber) {\n          case (Int32) TestEnum.Test1:\n            successful = true;\n            return TestEnum.Test1;\n\n          case (Int32) TestEnum.Test2:\n            successful = true;\n            return TestEnum.Test2;\n\n          case (Int32) TestEnum.Test4:\n            successful = true;\n            return TestEnum.Test4;\n\n          case (Int32) TestEnum.Test5:\n            successful = true;\n            return TestEnum.Test5;\n\n          case (Int32) TestEnum.Test6:\n            successful = true;\n            return TestEnum.Test6;\n\n          case (Int32) TestEnum.Test7:\n            successful = true;\n            return TestEnum.Test7;\n\n            // Skipping duplicated constant value: TestEnum.Test_1 -> 1\n\n          }\n      \\} else\n        while (value != null && value.Length > 0) {\n          parsed = false;\n\n          int endIndex = value.IndexOf(\',\');\n\n          if (endIndex < 0) {\n            // No next separator; use the remainder as the next value.\n            subValue = value.Trim();\n            value = null!;\n          \\} else if (endIndex != value!.Length - 1) {\n            // Found a separator before the last char.\n            subValue = value.Substring(0, endIndex).Trim();\n            value = value.Substring(endIndex + 1);\n          \\} else {\n            // Last char was a separator, which is invalid.\n            break;\n          }\n\n          if (!ignoreCase) {\n            switch (subValue) {\n            case nameof(TestEnum.Test1):\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test1;\n              break;\n\n            case nameof(TestEnum.Test2):\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test2;\n              break;\n\n            case nameof(TestEnum.Test4):\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test4;\n              break;\n\n            case nameof(TestEnum.Test5):\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test5;\n              break;\n\n            case nameof(TestEnum.Test6):\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test6;\n              break;\n\n            case nameof(TestEnum.Test7):\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test7;\n              break;\n\n            case nameof(TestEnum.Test_1):\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test_1;\n              break;\n\n            }\n          \\} else {\n            if (subValue.Equals("Test1", StringComparison.OrdinalIgnoreCase)) {\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test1;\n            }\n            if (subValue.Equals("Test2", StringComparison.OrdinalIgnoreCase)) {\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test2;\n            }\n            if (subValue.Equals("Test4", StringComparison.OrdinalIgnoreCase)) {\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test4;\n            }\n            if (subValue.Equals("Test5", StringComparison.OrdinalIgnoreCase)) {\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test5;\n            }\n            if (subValue.Equals("Test6", StringComparison.OrdinalIgnoreCase)) {\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test6;\n            }\n            if (subValue.Equals("Test7", StringComparison.OrdinalIgnoreCase)) {\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test7;\n            }\n            if (subValue.Equals("Test_1", StringComparison.OrdinalIgnoreCase)) {\n              parsed = true;\n              localResult |= (Int32) TestEnum.Test_1;\n            }\n\n          }\n\n          if (!parsed)\n            break;\n        }\n\n      successful = true;\n\n      if (!parsed) {\n        successful = false;\n\n        if (throwOnFailure)\n          throw new ArgumentException($"Could not convert the given value `{originalValue}`.", nameof(value));\n      }\n\n      return (TestEnum) localResult;\n    }\n\n  }\n}\n\n#nullable restore\n'})})]}),"\n",(0,a.jsx)(n.h3,{id:"about",children:"About"}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"generating enums fast retrieval"})}),"\n",(0,a.jsx)(n.h2,{id:"how-to-use",children:"How to use"}),"\n",(0,a.jsx)(n.h3,{id:"example-source-csproj-source-files",children:"Example (source csproj, source files)"}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsxs)(l.A,{value:"csproj",label:"CSharp Project",children:[(0,a.jsxs)(n.p,{children:["This is the CSharp Project that references ",(0,a.jsx)(n.strong,{children:"EnumsEnhanced"})]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",metastring:"showLineNumbers {16}",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net9.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <PropertyGroup>\n\t\t<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n\t\t<CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n\t</PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include="EnumsEnhanced" Version="2.0.0">\n    </PackageReference>\n  </ItemGroup>\n\t<PropertyGroup>\n\t\t<AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n\t</PropertyGroup>\n</Project>\n\n'})})]}),(0,a.jsxs)(l.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\EnumsEnhanced\\src\\EnumDemo\\Program.cs",label:"Program.cs",children:[(0,a.jsxs)(n.p,{children:["This is the use of ",(0,a.jsx)(n.strong,{children:"EnumsEnhanced"})," in ",(0,a.jsx)(n.em,{children:"Program.cs"})]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'// See https://aka.ms/new-console-template for more information\nusing EnumDemo;\n\nConsole.WriteLine("Hello, World!");\nConsole.WriteLine("Car types:" + CarTypesEnhanced.GetNamesFast().Length);\nvar cars= CarTypesEnhanced.GetValuesFast();\nforeach (var car in cars)\n{\n    Console.WriteLine( car.ToStringFast());\n}\n'})})]}),(0,a.jsxs)(l.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\EnumsEnhanced\\src\\EnumDemo\\CarTypes.cs",label:"CarTypes.cs",children:[(0,a.jsxs)(n.p,{children:["This is the use of ",(0,a.jsx)(n.strong,{children:"EnumsEnhanced"})," in ",(0,a.jsx)(n.em,{children:"CarTypes.cs"})]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"\nnamespace EnumDemo;\npublic enum CarTypes \n{\n    None,\n    Dacia ,\n    Tesla ,\n    BMW ,\n    Mercedes ,\n}\n\n"})})]})]}),"\n",(0,a.jsx)(n.h3,{id:"generated-files",children:"Generated Files"}),"\n",(0,a.jsx)(n.p,{children:"Those are taken from $(BaseIntermediateOutputPath)\\GX"}),"\n",(0,a.jsx)(i.A,{children:(0,a.jsx)(l.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\EnumsEnhanced\\src\\EnumDemo\\obj\\GX\\EnumsEnhanced\\EnumsEnhanced.EnumsEnhanced\\CarTypesEnhanced.g.cs",label:"CarTypesEnhanced.g.cs",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'#nullable enable\n\n            using System.Text;\n            using System.Runtime.CompilerServices;\n            using System.Collections.Generic;\n            using System;\n            using System;\n            using System.Globalization;\n\n            namespace EnumDemo\n            {\n                /// <summary>\n                /// Reflection free extension methods for the <see cref="CarTypes"/> type.\n                /// </summary>\n                public static partial class CarTypesEnhanced\n                {\n                    \n    /// <summary>\n    /// Determines whether one or more bit fields are set in the current instance.\n    /// </summary>\n    /// <param name="e">The value of the enum.</param>\n    /// <param name="flag">The flag to check.</param>\n    /// <returns><see langword="true"/> if the bit field or bit fields that are set in flag are also set in the current instance; otherwise, false.</returns>\n    #if NETCOREAPP3_0_OR_GREATER\n[MethodImplAttribute(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]\n#else\n[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\n#endif\n\n    public static bool HasFlagFast(this CarTypes e, CarTypes flag)\n    {\n        return (e & flag) == flag;\n    }\n\n    /// <inheritdoc cref="HasFlagFast(CarTypes, CarTypes)"/>\n    #if NETCOREAPP3_0_OR_GREATER\n[MethodImplAttribute(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]\n#else\n[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\n#endif\n\n    public static unsafe bool HasFlagFastUnsafe(this CarTypes e, CarTypes flag)\n    {\n        return HasFlagFastUnsafe(&e, &flag);\n    }\n\n    /// <summary>\n    /// Determines whether one or more bit fields are set in the current instance using unsafe pointer type casting.\n    /// </summary>\n    /// <param name="e">The value of the enum.</param>\n    /// <param name="flag">The flag to check.</param>\n    /// <returns><see langword="true"/> if the bit field or bit fields that are set in flag are also set in the current instance; otherwise, false.</returns>\n    #if NETCOREAPP3_0_OR_GREATER\n[MethodImplAttribute(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]\n#else\n[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\n#endif\n\n    public static unsafe bool HasFlagFastUnsafe(CarTypes* e, CarTypes* flag)\n    {\n        return (*(int*)e & *(int*)flag) == *(int*)flag;\n    }\n\n    /// <summary>\n    /// Retrieves an array of the names of the constants.\n    /// </summary>\n    /// <returns>A string array of the names of the constants.</returns>\n    public static string[] GetNamesFast()\n    {\n        return new string[] {\n            "None", "Dacia", "Tesla", "BMW", "Mercedes"\n        };\n    }\n\n\n    /// <summary>\n    /// Retrieves an array of the values of the constants.\n    /// </summary>\n    /// <returns>An array that contains the values of the constants.</returns>\n    public static CarTypes[] GetValuesFast()\n    {\n        return new CarTypes[] {\n            CarTypes.None, CarTypes.Dacia, CarTypes.Tesla, CarTypes.BMW, CarTypes.Mercedes\n        };\n    }\n\n\n    /// <inheritdoc cref="IsDefinedFast(CarTypes)"/>\n    public static bool IsDefinedFast(string value)\n    {\n        _ = value ?? throw new ArgumentNullException(nameof(value));\n\n        switch(value)\n        {\n            case "BMW":\n\treturn true;\ncase "None":\n\treturn true;\ncase "Dacia":\n\treturn true;\ncase "Tesla":\n\treturn true;\ncase "Mercedes":\n\treturn true;\n\n        }\n\n        return false;\n    }\n\n    /// <inheritdoc cref="IsDefinedFast(CarTypes)"/>\n    #if NETCOREAPP3_0_OR_GREATER\n[MethodImplAttribute(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]\n#else\n[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\n#endif\n\n    public static bool IsDefinedFast(Int32 value)\n    {\n        return IsDefinedFast((CarTypes)value);\n    }\n\n    /// <summary>\n    /// Returns a <see cref="bool"/> telling whether its given value exists in the enumeration.\n    /// </summary>\n    /// <param name="value">The value of the enumeration constant.</param>\n    /// <returns><see langword="true"/> if a constant is defined with the given value from the <paramref name="value"/>.</returns>\n    public static bool IsDefinedFast(CarTypes value)\n    {\n        switch(value)\n        {\n            case CarTypes.BMW:\n\treturn true;\ncase CarTypes.None:\n\treturn true;\ncase CarTypes.Dacia:\n\treturn true;\ncase CarTypes.Tesla:\n\treturn true;\ncase CarTypes.Mercedes:\n\treturn true;\n\n        }\n\n        return false;\n    }\n\n    /// <summary>\n    /// Resolves the name of the given enum value.\n    /// </summary>\n    /// <param name="e">The value of a particular enumerated constant in terms of its underlying type.</param>\n    /// <param name="includeFlagNames">Determines whether the value has flags, so it will return `EnumValue, EnumValue2`.</param>\n    /// <returns> A string containing the name of the enumerated constant or <see langword="null"/> if the enum has multiple flags set but <paramref name="includeFlagNames"/> is not enabled.</returns>\n    public static string? GetNameFast(this CarTypes e, bool includeFlagNames = false)\n    {\n        switch(e)\n        {\n            case CarTypes.None:\n\treturn nameof(CarTypes.None);\n\ncase CarTypes.Dacia:\n\treturn nameof(CarTypes.Dacia);\n\ncase CarTypes.Tesla:\n\treturn nameof(CarTypes.Tesla);\n\ncase CarTypes.BMW:\n\treturn nameof(CarTypes.BMW);\n\ncase CarTypes.Mercedes:\n\treturn nameof(CarTypes.Mercedes);\n\n\n        }\n\n        // Returning null is the default behavior.\n        if(!includeFlagNames)\n            return null;\n            //throw new Exception("Enum name could not be found!");\n\n        var flagBuilder = new StringBuilder();\n        if(e.HasFlagFast(CarTypes.None))\n\tflagBuilder.Append(CarTypes.None.GetNameFast(false) + ", ");\n\nif(e.HasFlagFast(CarTypes.Dacia))\n\tflagBuilder.Append(CarTypes.Dacia.GetNameFast(false) + ", ");\n\nif(e.HasFlagFast(CarTypes.Tesla))\n\tflagBuilder.Append(CarTypes.Tesla.GetNameFast(false) + ", ");\n\nif(e.HasFlagFast(CarTypes.BMW))\n\tflagBuilder.Append(CarTypes.BMW.GetNameFast(false) + ", ");\n\nif(e.HasFlagFast(CarTypes.Mercedes))\n\tflagBuilder.Append(CarTypes.Mercedes.GetNameFast(false) + ", ");\n\n\n\n        return flagBuilder.ToString().Trim(new char[] \\{ \',\', \' \' });\n    }\n\n    /// <summary>\n    /// Converts the value of this instance to its equivalent string representation.\n    /// </summary>\n    /// <param name="e">The value of a particular enumerated constant in terms of its underlying type.</param>\n    /// <returns>The string representation of the value of this instance.</returns>\n    #if NETCOREAPP3_0_OR_GREATER\n[MethodImplAttribute(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]\n#else\n[MethodImplAttribute(MethodImplOptions.AggressiveInlining)]\n#endif\n\n    public static string? ToStringFast(this CarTypes e)\n    {\n        return GetNameFast(e, true);\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.\n    /// </summary>\n    /// <param name="value">A string containing the name or value to convert.</param>\n    /// <param name="ignoreCase"><see langword="true"/> to ignore case; false to regard case.</param>\n    /// <param name="result">The result of the enumeration constant.</param>\n    /// <returns><see langword="true"/> if the conversion succeeded; <see langword="false"/> otherwise.</returns>\n    public static bool TryParseFast(string value, bool ignoreCase, out CarTypes result)\n    {\n        result = ParseFast(out var successful, value: value, ignoreCase: ignoreCase, throwOnFailure: false);\n        return successful;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.\n    /// </summary>\n    /// <param name="value">A string containing the name or value to convert.</param>\n    /// <param name="ignoreCase"><see langword="true"/> to ignore case; false to regard case.</param>\n    /// <returns>The enumeration value whose value is represented by the given value.</returns>\n    public static CarTypes ParseFast(string value, bool ignoreCase = false)\n    {\n        return ParseFast(out _, value: value, ignoreCase: ignoreCase, throwOnFailure: true);\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to an equivalent enumerated object.\n    /// </summary>\n    /// <param name="successful"><see langword="true"/> if the conversion succeeded; <see langword="false"/> otherwise.</param>\n    /// <param name="value">A string containing the name or value to convert.</param>\n    /// <param name="ignoreCase"><see langword="true"/> to ignore case; false to regard case.</param>\n    /// <param name="throwOnFailure">Determines whether to throw an <see cref="Exception"/> on errors or not.</param>\n    /// <returns>The enumeration value whose value is represented by the given value.</returns>\n    public static CarTypes ParseFast(out bool successful, string value, bool ignoreCase = false, bool throwOnFailure = true)\n    {\n        successful = false;\n\n        if (throwOnFailure && (string.IsNullOrEmpty(value) || string.IsNullOrWhiteSpace(value)))\n        {\n            throw new ArgumentException("Value can\'t be null or whitespace!", nameof(value));\n        }\n\n        Int32 localResult = 0;\n        bool parsed = false;\n        string subValue;\n        string originalValue = value;\n        char firstChar = value[0];\n\n        if (char.IsDigit(firstChar) || firstChar == \'-\' || firstChar == \'+\')\n        {\n            if(Int32.TryParse(value, NumberStyles.AllowLeadingSign | NumberStyles.AllowTrailingWhite, null, out var valueNumber))\n                switch(valueNumber)\n                {\n                    case (Int32)CarTypes.BMW:\n\tsuccessful = true;\n\treturn CarTypes.BMW;\n\ncase (Int32)CarTypes.None:\n\tsuccessful = true;\n\treturn CarTypes.None;\n\ncase (Int32)CarTypes.Dacia:\n\tsuccessful = true;\n\treturn CarTypes.Dacia;\n\ncase (Int32)CarTypes.Tesla:\n\tsuccessful = true;\n\treturn CarTypes.Tesla;\n\ncase (Int32)CarTypes.Mercedes:\n\tsuccessful = true;\n\treturn CarTypes.Mercedes;\n\n\n                }\n        }\n        else\n        while(value != null && value.Length > 0)\n        {\n            parsed = false;\n\n            int endIndex = value.IndexOf(\',\');\n\n            if(endIndex < 0)\n            {\n                // No next separator; use the remainder as the next value.\n                subValue = value.Trim();\n                value = null!;\n            }\n            else if(endIndex != value!.Length - 1)\n            {\n                // Found a separator before the last char.\n                subValue = value.Substring(0, endIndex).Trim();\n                value = value.Substring(endIndex + 1);\n            }\n            else\n            {\n                // Last char was a separator, which is invalid.\n                break;\n            }\n\n            if(!ignoreCase)\n            {\n                switch(subValue)\n                {\n                    case nameof(CarTypes.BMW):\n\tparsed = true;\n\tlocalResult |= (Int32)CarTypes.BMW;\n\tbreak;\n\ncase nameof(CarTypes.None):\n\tparsed = true;\n\tlocalResult |= (Int32)CarTypes.None;\n\tbreak;\n\ncase nameof(CarTypes.Dacia):\n\tparsed = true;\n\tlocalResult |= (Int32)CarTypes.Dacia;\n\tbreak;\n\ncase nameof(CarTypes.Tesla):\n\tparsed = true;\n\tlocalResult |= (Int32)CarTypes.Tesla;\n\tbreak;\n\ncase nameof(CarTypes.Mercedes):\n\tparsed = true;\n\tlocalResult |= (Int32)CarTypes.Mercedes;\n\tbreak;\n\n\n                }\n            }\n            else\n            {\n                if(subValue.Equals("BMW", StringComparison.OrdinalIgnoreCase)) {\n\tparsed = true;\n\tlocalResult |= (Int32)CarTypes.BMW; }\nif(subValue.Equals("None", StringComparison.OrdinalIgnoreCase)) {\n\tparsed = true;\n\tlocalResult |= (Int32)CarTypes.None; }\nif(subValue.Equals("Dacia", StringComparison.OrdinalIgnoreCase)) {\n\tparsed = true;\n\tlocalResult |= (Int32)CarTypes.Dacia; }\nif(subValue.Equals("Tesla", StringComparison.OrdinalIgnoreCase)) {\n\tparsed = true;\n\tlocalResult |= (Int32)CarTypes.Tesla; }\nif(subValue.Equals("Mercedes", StringComparison.OrdinalIgnoreCase)) {\n\tparsed = true;\n\tlocalResult |= (Int32)CarTypes.Mercedes; }\n\n            }\n\n            if(!parsed)\n                break;\n        }\n\n        successful = true;\n\n        if (!parsed)\n        {\n            successful = false;\n\n            if (throwOnFailure)\n                throw new ArgumentException($"Could not convert the given value `{originalValue}`.", nameof(value));\n        }\n\n        return (CarTypes)localResult;\n    }\n\n\n                }\n            }\n\n            #nullable restore\n'})})})}),"\n",(0,a.jsx)(n.h2,{id:"useful",children:"Useful"}),"\n",(0,a.jsx)(n.h3,{id:"download-example-net--c",children:"Download Example (.NET  C#)"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:s(39194).A+"",children:"Download Example project EnumsEnhanced "})})}),"\n",(0,a.jsx)(n.h3,{id:"share-enumsenhanced",children:"Share EnumsEnhanced"}),"\n",(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FEnumsEnhanced&quote=EnumsEnhanced",title:"Share on Facebook",target:"_blank",children:"Share on Facebook"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FEnumsEnhanced&text=EnumsEnhanced:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FEnumsEnhanced",target:"_blank",title:"Tweet",children:"Share in Twitter"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FEnumsEnhanced&title=EnumsEnhanced",target:"_blank",title:"Submit to Reddit",children:"Share on Reddit"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FEnumsEnhanced&title=EnumsEnhanced&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FEnumsEnhanced",target:"_blank",title:"Share on LinkedIn",children:"Share on Linkedin"})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/EnumsEnhanced",children:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/EnumsEnhanced"})}),"\n",(0,a.jsx)(n.p,{children:"aaa"}),"\n",(0,a.jsx)(o.Ay,{})]})}function g(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},39194:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/files/EnumsEnhanced-d6d1150da2428776c2bb4cd546b2d3f6.zip"}}]);