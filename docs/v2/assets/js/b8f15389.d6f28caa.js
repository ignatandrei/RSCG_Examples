"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[7138],{4137:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(a),h=r,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||s;return a?n.createElement(m,i(i({ref:t},c),{},{components:a})):n.createElement(m,i({ref:t},c))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,i=new Array(s);i[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<s;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},1735:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var n=a(7462),r=(a(7294),a(4137));const s={},i="Lombok.NET",o={unversionedId:"RSCG-Examples/Lombok.NET_readme",id:"RSCG-Examples/Lombok.NET_readme",title:"Lombok.NET",description:"This library is to .NET what Lombok is to Java.",source:"@site/docs/RSCG-Examples/Lombok.NET_readme.md",sourceDirName:"RSCG-Examples",slug:"/RSCG-Examples/Lombok.NET_readme",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/Lombok.NET_readme",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Gedaq_readme",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/Gedaq_readme"},next:{title:"Matryoshki",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/Matryoshki_readme"}},l={},p=[{value:"Installation",id:"installation",level:3},{value:"Building and Debugging",id:"building-and-debugging",level:3},{value:"Features",id:"features",level:2},{value:"Usage",id:"usage",level:2},{value:"Demo",id:"demo",level:3},{value:"Constructors",id:"constructors",level:3},{value:"Supported types: Classes, Structs (AllArgsConstructor only)",id:"supported-types-classes-structs-allargsconstructor-only",level:4},{value:"With Methods",id:"with-methods",level:3},{value:"Supported types: Classes",id:"supported-types-classes",level:4},{value:"Singletons",id:"singletons",level:3},{value:"Supported types: Classes",id:"supported-types-classes-1",level:4},{value:"Lazy",id:"lazy",level:3},{value:"Supported types: Classes, Structs",id:"supported-types-classes-structs",level:4},{value:"ToString",id:"tostring",level:3},{value:"Supported types: Classes, Structs, Enums",id:"supported-types-classes-structs-enums",level:4},{value:"Properties",id:"properties",level:3},{value:"Supported types: Classes, Structs",id:"supported-types-classes-structs-1",level:4},{value:"Property change pattern",id:"property-change-pattern",level:3},{value:"Supported types: Classes",id:"supported-types-classes-2",level:4},{value:"Async overloads",id:"async-overloads",level:3},{value:"Supported types: Abstract Classes, Interfaces, Methods",id:"supported-types-abstract-classes-interfaces-methods",level:4},{value:"Async methods",id:"async-methods",level:4},{value:"Decorator Pattern",id:"decorator-pattern",level:3},{value:"Supported types: Abstract Classes, Interfaces",id:"supported-types-abstract-classes-interfaces",level:4}],c={toc:p},u="wrapper";function d(e){let{components:t,...a}=e;return(0,r.kt)(u,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lomboknet"},"Lombok.NET"),(0,r.kt)("p",null,"This library is to .NET what Lombok is to Java.\nIt generates constructors and other fun stuff using Source Generators for those classes you specify special attributes for. Check out the examples for more info."),(0,r.kt)("h3",{id:"installation"},"Installation"),(0,r.kt)("p",null,"At least Visual Studio 17.3 (or any JetBrains Rider version) is required for projects using this library. The generators generate code compliant with C# 10.\nYou can install Lombok.NET either via ",(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Lombok.NET"},"NuGet")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Install-Package Lombok.NET\n")),(0,r.kt)("p",null,"Or via the .NET Core command-line interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dotnet add package Lombok.NET\n")),(0,r.kt)("h3",{id:"building-and-debugging"},"Building and Debugging"),(0,r.kt)("p",null,'When building from source in the "Debug" configuration, the build will be suspended until a debugger is attached to the build process.\\\nDuring this time it is possible to set break points inside the generators or analyzers, before attaching to the build process in order for it to continue.\\\nThis behavior does not exist for the "Release" configuration, so if you just want to run tests or see if a build succeeds, this is best done in the "Release" configuration.'),(0,r.kt)("h2",{id:"features"},"Features"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#constructors"},"Constructors")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#with-methods"},'"With" methods')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#singletons"},"Singletons")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#lazy"},"Lazy")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#property-change-pattern"},"INotifyPropertyChanged/INotifyPropertyChanging")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#async-overloads"},"Async overloads")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#tostring"},"ToString")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#decorator-pattern"},"Decorator pattern"))),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("h3",{id:"demo"},"Demo"),(0,r.kt)("p",null,"This demonstrates the generating of the ",(0,r.kt)("inlineCode",{parentName:"p"},"With")," pattern. Simply apply an attribute and the library will do the rest. Remember you are not bound to using fields, but can also use properties and supply the appropriate ",(0,r.kt)("inlineCode",{parentName:"p"},"MemberType")," value to the attribute's constructor."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/14217185/140986601-83424d22-57a5-43cb-a491-9234036d245c.gif",alt:"LombokNetDemo"})),(0,r.kt)("h3",{id:"constructors"},"Constructors"),(0,r.kt)("h4",{id:"supported-types-classes-structs-allargsconstructor-only"},"Supported types: Classes, Structs (AllArgsConstructor only)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"[AllArgsConstructor]\npublic partial class Person {\n    private string _name;\n    private int _age;\n}\n")),(0,r.kt)("p",null,"By supplying the ",(0,r.kt)("inlineCode",{parentName:"p"},"AllArgsConstructor")," attribute and making the type ",(0,r.kt)("inlineCode",{parentName:"p"},"partial"),", you allow the Source Generator to create a constructor for it containing all of the classes private fields.\\\nIf you wish to modify this behavior and would instead like to have a constructor generated off of public properties, you can specify this in the attribute's constructor, e.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"[AllArgsConstructor(MemberType = MemberType.Property, AccessTypes = AccessType.Public)]\npublic partial class Person {\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n")),(0,r.kt)("p",null,"The default is ",(0,r.kt)("inlineCode",{parentName:"p"},"Field")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"MemberType")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Private")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"AccessType"),".\\\nIt is crucial to make the type ",(0,r.kt)("inlineCode",{parentName:"p"},"partial"),", otherwise the Source Generator will not be able to generate a constructor and will throw an exception."),(0,r.kt)("p",null,"If you only wish to have a constructor generated containing the required fields or properties, Lombok.NET offers the ",(0,r.kt)("inlineCode",{parentName:"p"},"RequiredArgsConstructor")," attribute. Fields are required if they are ",(0,r.kt)("inlineCode",{parentName:"p"},"readonly"),", properties are required if they don't have a ",(0,r.kt)("inlineCode",{parentName:"p"},"set")," accessor.\\\nThere is also a ",(0,r.kt)("inlineCode",{parentName:"p"},"NoArgsConstructor")," attribute which generates an empty constructor."),(0,r.kt)("h3",{id:"with-methods"},"With Methods"),(0,r.kt)("h4",{id:"supported-types-classes"},"Supported types: Classes"),(0,r.kt)("p",null,"For modifying objects after they were created, a common pattern using ",(0,r.kt)("inlineCode",{parentName:"p"},"With...")," methods is used. Lombok.NET will generate these methods for you based on members in your class. Here's an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},'[AllArgsConstructor]\n[With]\npublic partial class Person {\n    private string _name;\n    private int _age;\n}\n\nclass Program {\n    public static void Main() {\n        var person = new Person("Steve", 22);\n        person = person.WithName("Collin");\n        \n        Console.WriteLine(person.Name); // Prints "Collin"\n    }\n}\n')),(0,r.kt)("p",null,"With methods will only be generated for properties with a setter and fields without the ",(0,r.kt)("inlineCode",{parentName:"p"},"readonly")," modifier."),(0,r.kt)("h3",{id:"singletons"},"Singletons"),(0,r.kt)("h4",{id:"supported-types-classes-1"},"Supported types: Classes"),(0,r.kt)("p",null,"Apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"Singleton")," attribute to a partial class and Lombok.NET will generate all the boilerplate code required for making your class a thread-safe, lazy singleton. It will create a property called ",(0,r.kt)("inlineCode",{parentName:"p"},"Instance")," in order to access the singleton's instance. Note that the type needs to have a parameterless constructor.\\\n",(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"[Singleton]\npublic partial class PersonRepository {\n}\n\npublic class MyClass {\n    public MyClass() {\n        var personRepository = PersonRepository.Instance;\n    }\n}\n")),(0,r.kt)("h3",{id:"lazy"},"Lazy"),(0,r.kt)("h4",{id:"supported-types-classes-structs"},"Supported types: Classes, Structs"),(0,r.kt)("p",null,"Apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy")," attribute to a partial class or struct and Lombok.NET will generate a ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy<T>")," property which can be used to create an instance of the object lazily. Note that the type needs to have a parameterless constructor.\n",(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"[Lazy]\npublic partial class HeavyInitialization {\n    private HeavyInitialization() {\n        Thread.Sleep(1000);\n    }\n}\n\npublic class Program {\n    public Program() {\n        var lazy = HeavyInitialization.Lazy;\n        if(Random.Shared.Next() == 2) {\n            var value = lazy.Value;\n            // do something with value\n        }\n    }\n}\n")),(0,r.kt)("h3",{id:"tostring"},"ToString"),(0,r.kt)("h4",{id:"supported-types-classes-structs-enums"},"Supported types: Classes, Structs, Enums"),(0,r.kt)("p",null,"To generate a descriptive ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString")," method to your type, make it partial and add the ",(0,r.kt)("inlineCode",{parentName:"p"},"[ToString]")," attribute to it. By default, it will include private fields in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString")," method, but this is customizable in the attribute's constructor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"[ToString]\npublic partial class Person {\n    private string _name;\n    private int _age;\n}\n")),(0,r.kt)("p",null,"When applying this attribute to an enum, Lombok.NET will create an extension class with a ",(0,r.kt)("inlineCode",{parentName:"p"},"ToText")," method. This is due to the fact that enums can't be partial, thus an extension method is needed and the extension method will not be found if it is called ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString"),"."),(0,r.kt)("p",null,"If you have sensitive data in your objects which should not be contained in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString")," method, you can apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"[Masked]")," attribute to the property or field containing sensitive data. This will cause the value to be replaced by four asterisks (****) in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString")," method.   "),(0,r.kt)("h3",{id:"properties"},"Properties"),(0,r.kt)("h4",{id:"supported-types-classes-structs-1"},"Supported types: Classes, Structs"),(0,r.kt)("p",null,"Generating properties from fields while using them as backing fields is possible using the ",(0,r.kt)("inlineCode",{parentName:"p"},"[Property]")," attribute. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"public partial class MyViewModel {\n    \n    [Property]\n    private int _result;\n}\n")),(0,r.kt)("p",null,"This will create the following property:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"public int Result {\n    get => _result;\n    set => _result = value;\n}\n")),(0,r.kt)("h3",{id:"property-change-pattern"},"Property change pattern"),(0,r.kt)("h4",{id:"supported-types-classes-2"},"Supported types: Classes"),(0,r.kt)("p",null,"All of the boilerplate code surrounding ",(0,r.kt)("inlineCode",{parentName:"p"},"\xccNotifyPropertyChanged/\xccNotifyPropertyChanging")," can be generated using a conjunction of the ",(0,r.kt)("inlineCode",{parentName:"p"},"[NotifyPropertyChanged]"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"[NotifyPropertyChanging]")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"[Property]")," attributes.\\\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"[NotifyPropertyChanged]")," attribute will implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"INotifyPropertyChanged")," interface and the ",(0,r.kt)("inlineCode",{parentName:"p"},"PropertyChanged")," event. It will also create a method called ",(0,r.kt)("inlineCode",{parentName:"p"},"SetFieldAndRaisePropertyChanged")," which sets a backing field and raises the event. The event as well as the method can be used in your ViewModels to implement desired behavior.\\\nIf you would like to take it a step further, you can also use the ",(0,r.kt)("inlineCode",{parentName:"p"},"[Property]")," attribute on backing fields while passing the ",(0,r.kt)("inlineCode",{parentName:"p"},"PropertyChangeType")," parameter to generate properties off of backing fields which will include the raising of the specific event in their setters. Here's an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},'[NotifyPropertyChanged]\npublic partial class CustomViewModel {\n\n    private int _result;\n    \n    public int Result {\n        get => _result;\n        set => SetFieldAndRaisePropertyChanged(out _result, value);\n    }\n    \n    // -- OR --\n    \n    [Property(PropertyChangeType = PropertyChangeType.PropertyChanged)]\n    private int _result;\n}\n\npublic class Program {\n\n    public static void Main() {\n        var vm = new CustomViewModel();\n        vm.PropertyChanged += (sender, args) => Console.WriteLine("A property was changed");\n        \n        vm.Result = 42;\n    }\n}\n')),(0,r.kt)("p",null,"If you are using the ",(0,r.kt)("a",{parentName:"p",href:"https://www.reactiveui.net/"},"ReactiveUI")," library (e.g. when using Avalonia), you can also specify the ",(0,r.kt)("inlineCode",{parentName:"p"},"PropertyChangeType.ReactivePropertyChange")," to leverage ReactiveUI's property change handling. "),(0,r.kt)("p",null,"To be able to generate the properties with the property change-raising behavior, the class must have the ",(0,r.kt)("inlineCode",{parentName:"p"},"[NotifyPropertyChanged]")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"[NotifyPropertyChanging]")," (depending on desired behavior) attribute placed above it."),(0,r.kt)("h3",{id:"async-overloads"},"Async overloads"),(0,r.kt)("h4",{id:"supported-types-abstract-classes-interfaces-methods"},"Supported types: Abstract Classes, Interfaces, Methods"),(0,r.kt)("p",null,"If you want to have ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," overloads for every method in your interface, you can add the ",(0,r.kt)("inlineCode",{parentName:"p"},"[AsyncOverloads]")," attribute to it. This also works for abstract classes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"[AsyncOverloads]\npublic partial interface IRepository<T> {\n    T GetById(int id);\n    \n    void Save(T entity);\n}\n")),(0,r.kt)("p",null,"This will add the following methods to your interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"Task<T> GetByIdAsync(int id);\nTask SaveAsync(T entity);\n")),(0,r.kt)("p",null,"For abstract classes, it will do the same for every abstract method. The inheriting class will be forced to implement the async versions as well. This may also be achieved by using the ",(0,r.kt)("a",{parentName:"p",href:"#async-methods"},"[Async]")," attribute."),(0,r.kt)("h4",{id:"async-methods"},"Async methods"),(0,r.kt)("p",null,"If you would like to create a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," version of your method, you can add the ",(0,r.kt)("inlineCode",{parentName:"p"},"[Async]")," attribute to it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"public partial class MyViewModel {\n\n    [Async]\n    public int Square(int i) {\n        return i * i;\n    }\n}\n")),(0,r.kt)("p",null,"This will add the following method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"public Task<int> SquareAsync(int i) => Task.FromResult(Square(i));\n")),(0,r.kt)("p",null,"This works for classes and structs, however it must be ",(0,r.kt)("inlineCode",{parentName:"p"},"partial"),"."),(0,r.kt)("h3",{id:"decorator-pattern"},"Decorator Pattern"),(0,r.kt)("h4",{id:"supported-types-abstract-classes-interfaces"},"Supported types: Abstract Classes, Interfaces"),(0,r.kt)("p",null,"Lombok.NET also provides an option to generate the boilerplate code when it comes to the decorator pattern. Simply apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"Decorator")," attribute to an abstract class or an interface and let the Source Generator do the rest."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"[Decorator]\npublic interface IVehicle {\n    void Drive();\n    int GetNumberOfWheels();\n} \n")),(0,r.kt)("p",null,"This will add the following class to your namespace:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"public class VehicleDecorator {\n\n    private readonly IVehicle _vehicle;\n    \n    public VehicleDecorator(IVehicle vehicle) {\n        _vehicle = vehicle;\n    }\n    \n    public virtual void Drive() {\n        _vehicle.Drive();\n    }\n    \n    public virtual int GetNumberOfWheels() {\n        return _vehicle.GetNumberOfWheels();\n    }\n} \n")),(0,r.kt)("p",null,"Please let me know if there is any other functionality you would like to see in this library. I am happy to add more features."))}d.isMDXComponent=!0}}]);