"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[9532],{4137:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9833:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(4137));const o={},i=void 0,l={unversionedId:"RSCG-Examples/NextGenMapper_readme",id:"RSCG-Examples/NextGenMapper_readme",title:"NextGenMapper_readme",description:"Extremely fast and lightweight minimalistic object mapper generated on the fly",source:"@site/docs/RSCG-Examples/NextGenMapper_readme.md",sourceDirName:"RSCG-Examples",slug:"/RSCG-Examples/NextGenMapper_readme",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/NextGenMapper_readme",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"NetEscapades.EnumGenerators",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/NetEscapades.EnumGenerators_readme"},next:{title:"PartiallyApplied",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/PartiallyApplied_readme"}},s={},p=[],c={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",{align:"center"},(0,r.kt)("img",{src:"https://user-images.githubusercontent.com/36799941/191375272-27b0034d-0418-44a6-95c6-802b863de2b3.svg",width:"242",height:"242"})),(0,r.kt)("p",{align:"center"},(0,r.kt)("a",{href:"https://opensource.org/licenses/MIT"},(0,r.kt)("img",{src:"https://img.shields.io/badge/License-MIT-yellow.svg",alt:"License: MIT"})),(0,r.kt)("img",{alt:"GitHub release (latest by date including pre-releases)",src:"https://img.shields.io/github/v/release/DedAnton/NextGenMapper?include_prereleases"}),(0,r.kt)("a",{href:"https://vk.com/away.php?utf=1&to=https%3A%2F%2Fwww.tinkoff.ru%2Fcf%2F3ySZ9DEsxfL"},(0,r.kt)("img",{src:"https://img.shields.io/badge/%24-donate-9cf",alt:"donate"})),(0,r.kt)("h4",{align:"center"},"Extremely fast and lightweight minimalistic object mapper generated on the fly")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://user-images.githubusercontent.com/36799941/191618500-31f7e179-3510-49dc-ad13-18e07de8309b.mov"},"https://user-images.githubusercontent.com/36799941/191618500-31f7e179-3510-49dc-ad13-18e07de8309b.mov")),(0,r.kt)("h1",{id:"key-features"},"Key features"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Generation of mapping methods on the fly"),(0,r.kt)("li",{parentName:"ul"},"Reflection and expression trees are not used"),(0,r.kt)("li",{parentName:"ul"},"Performance like a hand-written mapper"),(0,r.kt)("li",{parentName:"ul"},"Minimum memory allocation"),(0,r.kt)("li",{parentName:"ul"},"Does not increase application startup time"),(0,r.kt)("li",{parentName:"ul"},"No dependencies in the final assembly"),(0,r.kt)("li",{parentName:"ul"},"No third party tools and IDE dependencies"),(0,r.kt)("li",{parentName:"ul"},"Static analysis support"),(0,r.kt)("li",{parentName:"ul"},"Code navigation support"),(0,r.kt)("li",{parentName:"ul"},"Easy to debug"),(0,r.kt)("li",{parentName:"ul"},"No attributes and fluid API")),(0,r.kt)("p",null,"NextGenMapper is a tool that just solves a problem and tries not to create new ones"),(0,r.kt)("h1",{id:"usage"},"Usage"),(0,r.kt)("p",null,"Add ",(0,r.kt)("inlineCode",{parentName:"p"},"using NextGenMapper")," and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," extension method on the object you want to map"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},'using NextGenMapper;\n\nvar source = new Source("Anton", 25);\n\nvar destination = source.Map<Destination>();\n\nConsole.WriteLine(destination);\n\nrecord Source(string Name, int Age);\nrecord Destination(string Name, int Age);\n')),(0,r.kt)("br",null),(0,r.kt)("p",null,"To customize the mapping of certain properties, call the ",(0,r.kt)("inlineCode",{parentName:"p"},"MapWith")," method and pass the value of the overridden property as an argument"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},'using NextGenMapper;\n\nvar source = new Source("Anton", "Ryabchikov", 25);\n\nvar destination = source.MapWith<Destination>(name: source.FirstName + \' \' + source.LastName);\n\nConsole.WriteLine(destination);\n\nrecord Source(string FirstName, string LastName, int Age);\nrecord Destination(string Name, int Age);\n')),(0,r.kt)("br",null),(0,r.kt)("p",null,"In order for NextGenMapper to use your mapping when mapping other objects, you need to create a partial class ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapper")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"NextGenMapper")," namespace and add the ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," method with your implementation to it"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"namespace NextGenMapper;\n\ninternal static partial class Mapper\n{\n    internal static Destination Map<To>(this Source source) \n        => source.MapWith<Destination>(name: source.FirstName + ' ' + source.LastName);\n}\n")),(0,r.kt)("br",null),(0,r.kt)("p",null,"The following collection types are currently supported: ",(0,r.kt)("inlineCode",{parentName:"p"},"List<T>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Array<T>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ICollection<T>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"IEnumerable<T>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"IList<T>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"IReadOnlyCollection<T>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"IReadOnlyList<T>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ImmutableArray<T>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ImmutableList<T>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"IImmutableList<T>")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},'var sourceCollection = new List<Source> { new("Anton", 25) };\n\nvar destination = sourceCollection.Map<List<Destination>>();\n')),(0,r.kt)("br",null),(0,r.kt)("p",null,"Enums can also be mapped"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"var source = Source.EnumValue;\n\nvar destination = source.Map<Destination>();\n")),(0,r.kt)("br",null),(0,r.kt)("p",null,"Projection for IQueryable supported"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c#"},"_dbContext.Users.Project<UserDestination>().ToList();\n")),(0,r.kt)("br",null),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note"),":\nDue to the use of new technology, some versions of Visual Studio can sometimes experience problems with syntax highlighting if IntelliCode says an error, but the solution was build without errors is to simply restart Visual Studio"),(0,r.kt)("h3",{parentName:"blockquote",id:"installation"},"Installation")),(0,r.kt)("p",null,"Install from the package manager console:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"PM> Install-Package NextGenMapper -prerelease\n")),(0,r.kt)("p",null,"Or from the .NET CLI as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dotnet add package NextGenMapper --prerelease\n")),(0,r.kt)("h1",{id:"how-it-works"},"How it works?"),(0,r.kt)("p",null,"NextGenMapper uses the new C# language feature - ",(0,r.kt)("a",{parentName:"p",href:"https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/"},"Source Code Generators"),". You can describe the work of the Source Code Generator in the following steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Code compiles"),(0,r.kt)("li",{parentName:"ol"},"The source code generator analyzes the assembly"),(0,r.kt)("li",{parentName:"ol"},"Generates new code based on analysis"),(0,r.kt)("li",{parentName:"ol"},"Compiles the new code and adds it to the assembly")),(0,r.kt)("p",null,"This is how the method that is called initially looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C#"},'internal static To Map<To>(this object source) => throw new InvalidOperationException($""Error when mapping {source.GetType()} to {typeof(To)}, mapping function was not found. Create custom mapping function."");\n')),(0,r.kt)("p",null,"When we call it, the generator analyzes this call and generates a mapping function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C#"},"internal static Destination Map<To>(this Source source) \n    => new Destination(source.Name, source.Age);\n")),(0,r.kt)("p",null,"The trick is that the method signatures are identical, but the generated method has more specific parameters and fits better, so it is called (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/dotnet/csharplang/blob/a4c9db9a69ae0d1334ed5675e8faca3b7574c0a1/spec/expressions.md#better-function-member"},"this behavior is described in the specification"),")"),(0,r.kt)("h1",{id:"status"},"Status"),(0,r.kt)("p",null,"At the moment, all the main functionality has been added. But the work isn't over yet."),(0,r.kt)("p",null,"All tasks and their progress can be viewed on the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/users/DedAnton/projects/3"},"project board")))}m.isMDXComponent=!0}}]);