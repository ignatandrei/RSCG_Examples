"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[3407],{4137:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(t),m=r,h=c["".concat(l,".").concat(m)]||c[m]||d[m]||i;return t?a.createElement(h,o(o({ref:n},u),{},{components:t})):a.createElement(h,o({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1273:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(7462),r=(t(7294),t(4137));const i={},o="Dunet",s={unversionedId:"RSCG-Examples/dunet_readme",id:"RSCG-Examples/dunet_readme",title:"Dunet",description:"Build",source:"@site/docs/RSCG-Examples/dunet_readme.md",sourceDirName:"RSCG-Examples",slug:"/RSCG-Examples/dunet_readme",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/dunet_readme",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sync Method Generator",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/Zomp_readme"},next:{title:"Mapperly",permalink:"/RSCG_Examples/v2/docs/RSCG-Examples/mapperly_readme"}},l={},p=[{value:"Install",id:"install",level:2},{value:"Usage",id:"usage",level:2},{value:"Generics",id:"generics",level:2},{value:"Implicit Conversions",id:"implicit-conversions",level:2},{value:"Async Match",id:"async-match",level:2},{value:"Specific Match",id:"specific-match",level:2},{value:"Pretty Print",id:"pretty-print",level:2},{value:"Shared Properties",id:"shared-properties",level:2},{value:"Stateful Matching",id:"stateful-matching",level:2},{value:"Nest Unions",id:"nest-unions",level:2}],u={toc:p},c="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"dunet"},"Dunet"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/domn1995/dunet/actions"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/github/actions/workflow/status/domn1995/dunet/main.yml?branch=main",alt:"Build"})),"\n",(0,r.kt)("a",{parentName:"p",href:"https://nuget.org/packages/dunet"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/v/dunet.svg",alt:"Package"}))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Dunet")," is a simple source generator for ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Tagged_union"},"discriminated unions")," in C#."),(0,r.kt)("h2",{id:"install"},"Install"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.nuget.org/packages/Dunet/"},"NuGet"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"dotnet add package dunet"))),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"// 1. Import the namespace.\nusing Dunet;\n\n// 2. Add the `Union` attribute to a partial record.\n[Union]\npartial record Shape\n{\n    // 3. Define the union variants as inner partial records.\n    partial record Circle(double Radius);\n    partial record Rectangle(double Length, double Width);\n    partial record Triangle(double Base, double Height);\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'// 4. Use the union variants.\nvar shape = new Shape.Rectangle(3, 4);\nvar area = shape.Match(\n    circle => 3.14 * circle.Radius * circle.Radius,\n    rectangle => rectangle.Length * rectangle.Width,\n    triangle => triangle.Base * triangle.Height / 2\n);\nConsole.WriteLine(area); // "12"\n')),(0,r.kt)("h2",{id:"generics"},"Generics"),(0,r.kt)("p",null,"Use generics for more advanced union types. For example, an option monad:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"// 1. Import the namespace.\nusing Dunet;\n// Optional: use static import for more terse code.\nusing static Option<int>;\n\n// 2. Add the `Union` attribute to a partial record.\n// 3. Add one or more type arguments to the union record.\n[Union]\npartial record Option<T>\n{\n    partial record Some(T Value);\n    partial record None();\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'// 4. Use the union variants.\nOption<int> ParseInt(string? value) =>\n    int.TryParse(value, out var number)\n        ? new Some(number)\n        : new None();\n\nstring GetOutput(Option<int> number) =>\n    number.Match(\n        some => some.Value.ToString(),\n        none => "Invalid input!"\n    );\n\nvar input = Console.ReadLine(); // User inputs "not a number".\nvar result = ParseInt(input);\nvar output = GetOutput(result);\nConsole.WriteLine(output); // "Invalid input!"\n\ninput = Console.ReadLine(); // User inputs "12345".\nresult = ParseInt(input);\noutput = GetOutput(result);\nConsole.WriteLine(output); // "12345".\n')),(0,r.kt)("h2",{id:"implicit-conversions"},"Implicit Conversions"),(0,r.kt)("p",null,"Dunet generates implicit conversions between union variants and the union type if your union meets all of the following conditions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The union has no required properties."),(0,r.kt)("li",{parentName:"ul"},"All variants contain a single property."),(0,r.kt)("li",{parentName:"ul"},"Each variant's property is unique within the union."),(0,r.kt)("li",{parentName:"ul"},"No variant's property is an interface type.")),(0,r.kt)("p",null,"For example, consider a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," union type that represents success as a ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," and failure as an ",(0,r.kt)("inlineCode",{parentName:"p"},"Exception"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"// 1. Import the namespace.\nusing Dunet;\n\n// 2. Define a union type with a single unique variant property:\n[Union]\npartial record Result\n{\n    partial record Success(double Value);\n    partial record Failure(Exception Error);\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'// 3. Return union variants directly.\nResult Divide(double numerator, double denominator)\n{\n    if (denominator is 0d)\n    {\n        // No need for `new Result.Failure(new InvalidOperationException("..."));`\n        return new InvalidOperationException("Cannot divide by zero!");\n    }\n\n    // No need for `new Result.Success(...);`\n    return numerator / denominator;\n}\n\nvar result = Divide(42, 0);\nvar output = result.Match(\n    success => success.Value.ToString(),\n    failure => failure.Error.Message\n);\n\nConsole.WriteLine(output); // "Cannot divide by zero!"\n')),(0,r.kt)("h2",{id:"async-match"},"Async Match"),(0,r.kt)("p",null,"Dunet generates a ",(0,r.kt)("inlineCode",{parentName:"p"},"MatchAsync()")," extension method for all ",(0,r.kt)("inlineCode",{parentName:"p"},"Task<T>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ValueTask<T>")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is a union type. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"// Choice.cs\n\nusing Dunet;\n\nnamespace Core;\n\n// 1. Define a union type within a namespace.\n[Union]\npartial record Choice\n{\n    partial record Yes;\n    partial record No(string Reason);\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'// Program.cs\n\nusing Core;\nusing static Core.Choice;\n\n// 2. Define async methods like you would for any other type.\nstatic async Task<Choice> AskAsync()\n{\n    // Simulating network call.\n    await Task.Delay(1000);\n\n    // 3. Return unions from async methods like any other type.\n    return new No("because I don\'t wanna!");\n}\n\n// 4. Asynchronously match any union `Task` or `ValueTask`.\nvar response = await AskAsync()\n    .MatchAsync(\n        yes => "Yes!!!",\n        no => $"No, {no.Reason}"\n    );\n\n// Prints "No, because I don\'t wanna!" after 1 second.\nConsole.WriteLine(response);\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note"),":\n",(0,r.kt)("inlineCode",{parentName:"p"},"MatchAsync()")," can only be generated for namespaced unions.")),(0,r.kt)("h2",{id:"specific-match"},"Specific Match"),(0,r.kt)("p",null,"Dunet generates specific match methods for each union variant. This is useful when unwrapping a union and you only care about transforming a single variant. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"[Union]\npartial record Shape\n{\n    partial record Point(int X, int Y);\n    partial record Line(double Length);\n    partial record Rectangle(double Length, double Width);\n    partial record Sphere(double Radius);\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"public static bool IsZeroDimensional(this Shape shape) =>\n    shape.MatchPoint(\n        point => true,\n        () => false\n    );\n\npublic static bool IsOneDimensional(this Shape shape) =>\n    shape.MatchLine(\n        line => true,\n        () => false\n    );\n\npublic static bool IsTwoDimensional(this Shape shape) =>\n    shape.MatchRectangle(\n        rectangle => true,\n        () => false\n    );\n\npublic static bool IsThreeDimensional(this Shape shape) =>\n    shape.MatchSphere(\n        sphere => true,\n        () => false\n    );\n")),(0,r.kt)("h2",{id:"pretty-print"},"Pretty Print"),(0,r.kt)("p",null,"To control how union variants are printed with their ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString()")," methods, override and seal the union declaration's ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString()")," method. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'[Union]\npublic partial record QueryResult<T>\n{\n    public partial record Ok(T Value);\n    public partial record NotFound;\n    public partial record Unauthorized;\n\n    public sealed override string ToString() =>\n        Match(\n            ok => ok.Value.ToString(),\n            notFound => "Not found.",\n            unauthorized => "Unauthorized access."\n        );\n}\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note"),":\nYou must seal the ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString()")," override to prevent the compiler from synthesizing a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString()")," method for each variant."),(0,r.kt)("p",{parentName:"blockquote"},"More info: ",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#built-in-formatting-for-display"},"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#built-in-formatting-for-display"))),(0,r.kt)("h2",{id:"shared-properties"},"Shared Properties"),(0,r.kt)("p",null,"To create a property shared by all variants, add it to the union declaration. For example, the following code requires all union variants to initialize the ",(0,r.kt)("inlineCode",{parentName:"p"},"StatusCode")," property. This makes ",(0,r.kt)("inlineCode",{parentName:"p"},"StatusCode")," available to anyone with a reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"HttpResponse")," without having to match."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"[Union]\npublic partial record HttpResponse\n{\n    public partial record Success;\n    public partial record Error(string Message);\n    // 1. All variants shall have a status code.\n    public required int StatusCode { get; init; }\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'using var client = new HttpClient();\nvar response = await CreateUserAsync(client, "John", "Smith");\n\n// 2. The `StatusCode` property is available at the union level.\nvar statusCode = response.StatusCode;\n\npublic static async Task<HttpResponse> CreateUserAsync(\n    HttpClient client, string firstName, string lastName\n)\n{\n    using var response = await client.PostJsonAsync(\n        "/users",\n        new { firstName, lastName }\n    );\n\n    var content = await response.Content.ReadAsStringAsync();\n\n    if (!response.IsSuccessStatusCode)\n    {\n        return new HttpResponse.Error(content)\n        {\n            StatusCode = (int)response.StatusCode,\n        };\n    }\n\n    return new HttpResponse.Success()\n    {\n        StatusCode = (int)response.StatusCode,\n    };\n}\n')),(0,r.kt)("h2",{id:"stateful-matching"},"Stateful Matching"),(0,r.kt)("p",null,"To reduce memory allocations, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Match")," overload that accepts a generic state parameter as its first argument. This allows your match parameter lambdas to be ",(0,r.kt)("inlineCode",{parentName:"p"},"static")," but still flow state through:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},'using Dunet;\nusing static Expression;\n\nvar environment = new Dictionary<string, int>()\n{\n    ["a"] = 1,\n    ["b"] = 2,\n    ["c"] = 3,\n};\n\nvar expression = new Add(new Variable("a"), new Multiply(new Number(2), new Variable("b")));\nvar result = Evaluate(environment, expression);\n\nConsole.WriteLine(result); // "5"\n\nstatic int Evaluate(Dictionary<string, int> env, Expression exp) =>\n    exp.Match(\n        // 1. Pass your state "container" as the first parameter.\n        state: env,\n        // 2. Use static lambdas for each variant\'s match method.\n        static (_, number) => number.Value,\n        // 3. Reference the state as the first argument of each lambda.\n        static (state, add) => Evaluate(state, add.Left) + Evaluate(state, add.Right),\n        static (state, mul) => Evaluate(state, mul.Left) * Evaluate(state, mul.Right),\n        static (state, var) => state[var.Value]\n    );\n\n[Union]\npublic partial record Expression\n{\n    public partial record Number(int Value);\n    public partial record Add(Expression Left, Expression Right);\n    public partial record Multiply(Expression Left, Expression Right);\n    public partial record Variable(string Value);\n}\n')),(0,r.kt)("h2",{id:"nest-unions"},"Nest Unions"),(0,r.kt)("p",null,"To declare a union nested within a class or record, the class or record must be ",(0,r.kt)("inlineCode",{parentName:"p"},"partial"),". For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"// This type declaration must be partial.\npublic partial class Parent1\n{\n    // So must this one.\n    public partial class Parent2\n    {\n        // Unions must always be partial.\n        [Union]\n        public partial record Nested\n        {\n            public partial record Variant1;\n            public partial record Variant2;\n        }\n    }\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs"},"// Access variants like any other nested type.\nvar variant1 = new Parent1.Parent2.Nested.Variant1();\n")))}d.isMDXComponent=!0}}]);