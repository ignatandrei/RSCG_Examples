"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[1897],{23222:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>v,default:()=>g,frontMatter:()=>u,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"RSCG-Examples/DomainPrimitives","title":"97 - DomainPrimitives","description":"One of the most complete and mature libraries for DomainPrimitives in  .NET","source":"@site/docs/RSCG-Examples/DomainPrimitives.md","sourceDirName":"RSCG-Examples","slug":"/DomainPrimitives","permalink":"/RSCG_Examples/v2/docs/DomainPrimitives","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/RSCG-Examples/DomainPrimitives.md","tags":[],"version":"current","sidebarPosition":970,"frontMatter":{"sidebar_position":970,"title":"97 - DomainPrimitives","description":"One of the most complete and mature libraries for DomainPrimitives in  .NET","slug":"/DomainPrimitives"},"sidebar":"tutorialSidebar","previous":{"title":"96 - HsuSgSync","permalink":"/RSCG_Examples/v2/docs/HsuSgSync"},"next":{"title":"98 - Funcky.DiscriminatedUnion","permalink":"/RSCG_Examples/v2/docs/Funcky.DiscriminatedUnion"}}');var r=n(74848),a=n(28453),o=n(11470),s=n(19365),l=n(14252);function c(e){const t={a:"a",h3:"h3",p:"p",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h3,{id:"in--the-same-category--todo-andrei",children:"In  the same category -TODO Andrei"}),"\n",(0,r.jsx)(t.p,{children:"Number RSCG: 5"}),"\n",(0,r.jsxs)(t.p,{children:["1 ",(0,r.jsx)(t.a,{href:"/docs/DomainPrimitives",children:"DomainPrimitives"})]}),"\n",(0,r.jsxs)(t.p,{children:["2 ",(0,r.jsx)(t.a,{href:"/docs/Strongly",children:"Strongly"})]}),"\n",(0,r.jsxs)(t.p,{children:["3 ",(0,r.jsx)(t.a,{href:"/docs/StronglyTypedUid",children:"StronglyTypedUid"})]}),"\n",(0,r.jsxs)(t.p,{children:["4 ",(0,r.jsx)(t.a,{href:"/docs/UnitGenerator",children:"UnitGenerator"})]}),"\n",(0,r.jsxs)(t.p,{children:["5 ",(0,r.jsx)(t.a,{href:"/docs/Vogen",children:"Vogen"})]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}const u={sidebar_position:970,title:"97 - DomainPrimitives",description:"One of the most complete and mature libraries for DomainPrimitives in  .NET",slug:"/DomainPrimitives"},v="DomainPrimitives  by Alta Software - Teimuraz Nikolaishvili",m={},p=[{value:"NuGet / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"Introduction",id:"introduction",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Generator Features",id:"generator-features",level:2},{value:"Supported Underlying types",id:"supported-underlying-types",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Installation",id:"installation",level:3},{value:"<strong>Creating your Domain type</strong>",id:"creating-your-domain-type",level:2},{value:"<strong>PositiveInteger.Generated</strong>",id:"positiveintegergenerated",level:2},{value:"<strong>JsonConverter</strong>",id:"jsonconverter",level:2},{value:"<strong>Type Converter</strong>",id:"type-converter",level:2},{value:"<strong>Swagger Mappers</strong>",id:"swagger-mappers",level:2},{value:"Specialized ToString method",id:"specialized-tostring-method",level:2},{value:"Managing Generated Operators for numeric types",id:"managing-generated-operators-for-numeric-types",level:2},{value:"Default numeric types Generated Operators",id:"default-numeric-types-generated-operators",level:3},{value:"using <code>SupportedOperationsAttribute</code>",id:"using-supportedoperationsattribute",level:3},{value:"For further customization of the operators, consider implementing specific interfaces. This action will override the generated operators for the respective domain type:",id:"for-further-customization-of-the-operators-consider-implementing-specific-interfaces-this-action-will-override-the-generated-operators-for-the-respective-domain-type",level:3},{value:"Managing Serialization Format for date-related types",id:"managing-serialization-format-for-date-related-types",level:2},{value:"Implicit Usage of DomainType",id:"implicit-usage-of-domaintype",level:2},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example (source csproj, source files)",id:"example-source-csproj-source-files",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Useful",id:"useful",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share DomainPrimitives",id:"share-domainprimitives",level:3},{value:"In the same category (PrimitiveObsession) - 4 other generators",id:"in-the-same-category-primitiveobsession---4-other-generators",level:3},{value:"In  the same category -TODO Andrei",id:"in--the-same-category--todo-andrei",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"domainprimitives--by-alta-software---teimuraz-nikolaishvili",children:"DomainPrimitives  by Alta Software - Teimuraz Nikolaishvili"})}),"\n",(0,r.jsx)(l.A,{toc:p}),"\n",(0,r.jsx)(t.h2,{id:"nuget--site-data",children:"NuGet / site data"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Generator",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/AltaSoft.DomainPrimitives.Generator?label=AltaSoft.DomainPrimitives.Generator",alt:"Nuget"})}),(0,r.jsx)(t.a,{href:"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Abstractions",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/nuget/dt/AltaSoft.DomainPrimitives.Abstractions?label=AltaSoft.DomainPrimitives.Abstractions",alt:"Nuget"})}),"\n",(0,r.jsx)(t.a,{href:"https://github.com/altasoft/DomainPrimitives",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/github/last-commit/altasoft/DomainPrimitives?label=updated",alt:"GitHub last commit"})}),"\n",(0,r.jsx)(t.img,{src:"https://img.shields.io/github/stars/altasoft/DomainPrimitives?style=social",alt:"GitHub Repo stars"})]}),"\n",(0,r.jsx)(t.h2,{id:"details",children:"Details"}),"\n",(0,r.jsx)(t.h3,{id:"info",children:"Info"}),"\n",(0,r.jsxs)(t.admonition,{type:"info",children:[(0,r.jsxs)(t.p,{children:["Name: ",(0,r.jsx)(t.strong,{children:"DomainPrimitives"})]}),(0,r.jsx)(t.p,{children:"Domain Primitives source generator for C#."}),(0,r.jsx)(t.p,{children:"Author: Alta Software - Teimuraz Nikolaishvili"}),(0,r.jsxs)(t.p,{children:["NuGet:\n",(0,r.jsx)(t.em,{children:(0,r.jsx)(t.a,{href:"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Generator",children:"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Generator"})})]}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:(0,r.jsx)(t.a,{href:"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Abstractions",children:"https://www.nuget.org/packages/AltaSoft.DomainPrimitives.Abstractions"})})}),(0,r.jsxs)(t.p,{children:["You can find more details at ",(0,r.jsx)(t.a,{href:"https://github.com/altasoft/DomainPrimitives",children:"https://github.com/altasoft/DomainPrimitives"})]}),(0,r.jsxs)(t.p,{children:["Source: ",(0,r.jsx)(t.a,{href:"https://github.com/altasoft/DomainPrimitives",children:"https://github.com/altasoft/DomainPrimitives"})]})]}),"\n",(0,r.jsx)(t.h3,{id:"original-readme",children:"Original Readme"}),"\n",(0,r.jsxs)(t.admonition,{type:"note",children:[(0,r.jsx)(t.h1,{id:"domainprimitives-for-c",children:"DomainPrimitives for C#"}),(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://www.nuget.org/profiles/AltaSoft",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/static/v1?label=Version&message=1.0.3&color=0c3c60&style=for-the-badge",alt:"Version"})}),"\n",(0,r.jsx)(t.a,{href:"https://dotnet.microsoft.com",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/static/v1?label=DOTNET&message=7%2B&color=0c3c60&style=for-the-badge",alt:"Dot NET 7+"})})]}),(0,r.jsx)(t.h1,{id:"table-of-contents",children:"Table of Contents"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#key-features",children:"Key Features"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#generator-features",children:"Generator Features"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#supported-underlying-types",children:"Supported Underlying types"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#getting-started",children:"Getting Started"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#prerequisites",children:"Prerequisites"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#installation",children:"Installation"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#creating-your-domain-type",children:"Creating your Domain type"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#json-conversion",children:"Json Conversion"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#contributions",children:"Contributions"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#contact",children:"Contact"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#license",children:"License"})}),"\n"]}),(0,r.jsx)(t.h2,{id:"introduction",children:"Introduction"}),(0,r.jsxs)(t.p,{children:["Welcome to ",(0,r.jsx)(t.strong,{children:"AltaSoft.DomainPrimitives"})," - a C# toolkit purposefully designed to accelerate the development of domain-specific primitives within your applications. This streamlined solution empowers developers to efficiently encapsulate fundamental domain logic. Through this toolkit, you'll significantly reduce code complexity while improving the maintainability of your project."]}),(0,r.jsx)(t.h2,{id:"key-features",children:"Key Features"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Simplified Primitive Creation"})," - Utilize source generators to swiftly create domain-specific primitives with ease and precision."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Versatile Underlying Type Support"})," - Embrace a wide array of underlying types, catering to diverse application requirements."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Enhanced Code Quality"})," - Create clean, maintainable, and thoroughly testable code through encapsulation and robust design principles."]}),"\n"]}),(0,r.jsxs)(t.p,{children:["With ",(0,r.jsx)(t.code,{children:"AltaSoft.DomainPrimitives"}),", experience an accelerated development process while upholding code quality standards. This toolkit empowers developers to focus on the core business logic without compromising on precision or efficiency."]}),(0,r.jsx)(t.h2,{id:"generator-features",children:"Generator Features"}),(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.strong,{children:"AltaSoft.DomainPrimitives.Generator"})," offers a diverse set of features:"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Implicit Operators:"})," Streamlines type conversion to/from the underlying primitive type. ",(0,r.jsx)(t.a,{href:"#implicit-usage-of-domaintype",children:"Example"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Specialized Constructor Generation:"}),"  Automatically validates and constructs instances of this domain type. This constructor, tailored for the domain primitive, utilizes the underlying type as a parameter, ensuring the value's correctness within the domain."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"JsonConverters:"})," Handles JSON serialization and deserialization for the underlying type. ",(0,r.jsx)(t.a,{href:"#json-conversion",children:"Example"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"TypeConverters:"})," Assists in type conversion to/from it's underlying type. ",(0,r.jsx)(t.a,{href:"#type-converter",children:"Please refer to generated type converter below"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Swagger Custom Type Mappings:"})," Facilitates easy integration with Swagger by treating the primitive type as it's underlying type. ",(0,r.jsx)(t.a,{href:"#swagger-mappers",children:"Please refer to generated swagger helper below"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Interface Implementations:"})," All DomainPritmitives Implement ",(0,r.jsx)(t.code,{children:"IConvertible"}),", ",(0,r.jsx)(t.code,{children:"IComparable"}),", ",(0,r.jsx)(t.code,{children:"IComparable<T>"}),", ",(0,r.jsx)(t.code,{children:"IEquatable<T>"}),", ",(0,r.jsx)(t.code,{children:"IEqualityComparer<T>"}),", ",(0,r.jsx)(t.code,{children:"IParsable"})," interfaces."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"NumberType Operations:"})," Automatically generates basic arithmetic and comparison operators, by implementing Static abstract interfaces. ",(0,r.jsx)(t.a,{href:"#number-types-attribute",children:"More details regarding numeric types"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"IParsable Implementation:"})," Automatically generates parsing for non-string types."]}),"\n"]}),(0,r.jsx)(t.h2,{id:"supported-underlying-types",children:"Supported Underlying types"}),(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"string"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"Guid"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"byte"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"sbyte"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"short"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"ushort"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"int"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"uint"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"long"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"ulong"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"decimal"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"double"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"float"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"bool"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"char"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"string"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"TimeSpan"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"Guid"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"DateTime"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"DateTimeOffset"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"DateOnly"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"TimeOnly"})}),"\n"]}),(0,r.jsx)(t.h2,{id:"getting-started",children:"Getting Started"}),(0,r.jsx)(t.h3,{id:"prerequisites",children:"Prerequisites"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:".NET 7 or higher"}),"\n",(0,r.jsx)(t.li,{children:"NuGet Package Manager"}),"\n"]}),(0,r.jsx)(t.h3,{id:"installation",children:"Installation"}),(0,r.jsxs)(t.p,{children:["To use ",(0,r.jsx)(t.strong,{children:"AltaSoft.DomainPrimitives"}),", install two NuGet packages:"]}),(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"AltaSoft.DomainPrimitives.Abstractions"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"AltaSoft.DomainPrimitives.Generator"})}),"\n"]}),(0,r.jsx)(t.p,{children:"In your project file add references as follows:"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'<ItemGroup>\n  <PackageReference Include="AltaSoft.DomainPrimitives.Abstractions" Version="1.0.3" />\n  <PackageReference Include="AltaSoft.DomainPrimitives.Generator" Version="1.0.3" OutputItemType="Analyzer" ReferenceOutputAssembly="false" PrivateAssets="all" ExcludeAssets="runtime" />\n</ItemGroup>\n'})}),(0,r.jsx)(t.h2,{id:"creating-your-domain-type",children:(0,r.jsx)(t.strong,{children:"Creating your Domain type"})}),(0,r.jsxs)(t.p,{children:["For optimal performance, we recommend using ",(0,r.jsx)(t.code,{children:"readonly struct"})," - especially for wrapping value types"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public readonly partial record struct PositiveInteger : IDomainValue<int>\n{\n\tpublic static void Validate(int value)\n\t{\n\t\tif (value <= 0)\n\t\t\tthrow new InvalidDomainValueException("Number must be positive");\n\t}\n\tpublic static int Default => 1;\n}\n'})}),(0,r.jsx)(t.p,{children:"This will automatically generate by default 4 classes"}),(0,r.jsx)(t.h2,{id:"positiveintegergenerated",children:(0,r.jsx)(t.strong,{children:"PositiveInteger.Generated"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Text.Json.Serialization;\nusing AltaSoft.DomainPrimitives.Converters;\nusing System.ComponentModel;\n\nnamespace AltaSoft.DomainPrimitives;\n\n[JsonConverter(typeof(PositiveIntegerJsonConverter))]\n[TypeConverter(typeof(PositiveIntegerTypeConverter))]\n[DebuggerDisplay("{_valueOrDefault}")]\npublic readonly partial record struct PositiveInteger :\n   \tIAdditionOperators<PositiveInteger, PositiveInteger, PositiveInteger>,\n   \tISubtractionOperators<PositiveInteger, PositiveInteger, PositiveInteger>,\n   \tIMultiplyOperators<PositiveInteger, PositiveInteger, PositiveInteger>,\n   \tIDivisionOperators<PositiveInteger, PositiveInteger, PositiveInteger>,\n   \tIModulusOperators<PositiveInteger, PositiveInteger, PositiveInteger>,\n   \tIComparisonOperators<PositiveInteger, PositiveInteger, bool>,\n   \tIComparable,\n   \tIComparable<PositiveInteger>,\n   \tIParsable<PositiveInteger>,\n   \tIConvertible\n{\n   private int _valueOrDefault => _isInitialized ? _value : Default;\n   [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n   private readonly int _value;\n   [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n   private readonly bool _isInitialized;\n   \n   /// <summary>\n   /// Initializes a new instance of the PositiveInteger class by validating the provided value using <see cref="Validate"/>.\n   /// </summary>\n   /// <param name="value">The value to be validated..</param>\n   public PositiveInteger(int value)\n   {\n   \t\tValidate(value);\n   \t\t_value = value;\n   \t\t_isInitialized = true;\n   }\n   \n   [Obsolete("Domain primitive cannot be created using empty Ctor", true)]\n   public PositiveInteger() : this(Default)\n   {\n   }\n   \n   /// <summary>\n   /// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "PositiveInteger"/></summary>\n   /// </summary>\n   public static implicit operator PositiveInteger(int value) => new(value);\n\n   /// <summary>\n   /// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "PositiveInteger"/></summary>\n   /// </summary>\n   [return: NotNullIfNotNull(nameof(value))]\n   public static implicit operator PositiveInteger?(int? value) => value is null ? null : new(value.Value);\n\n   /// <summary>\n   /// <summary>Implicit conversion from <see cref = "PositiveInteger"/> to <see cref = "int"/></summary>\n   /// </summary>\n   public static implicit operator int(PositiveInteger value) => (int)value._valueOrDefault;\n\n   /// <inheritdoc/>\n   public static PositiveInteger operator +(PositiveInteger left, PositiveInteger right) => new(left._valueOrDefault + right._valueOrDefault);\n\n   /// <inheritdoc/>\n   public static PositiveInteger operator -(PositiveInteger left, PositiveInteger right) => new(left._valueOrDefault - right._valueOrDefault);\n\n   /// <inheritdoc/>\n   public static PositiveInteger operator *(PositiveInteger left, PositiveInteger right) => new(left._valueOrDefault * right._valueOrDefault);\n\n   /// <inheritdoc/>\n   public static PositiveInteger operator /(PositiveInteger left, PositiveInteger right) => new(left._valueOrDefault / right._valueOrDefault);\n\n   /// <inheritdoc/>\n   public static PositiveInteger operator %(PositiveInteger left, PositiveInteger right) => new(left._valueOrDefault % right._valueOrDefault);\n\n   /// <inheritdoc/>\n   public int CompareTo(object? value)\n   {\n   \tif (value is null)\n   \t\treturn 1;\n\n   \tif (value is PositiveInteger c)\n   \t\treturn CompareTo(c);\n\n   \tthrow new ArgumentException("Object is not a PositiveInteger", nameof(value));\n   }\n\n   /// <inheritdoc/>\n   public int CompareTo(PositiveInteger other) => _valueOrDefault.CompareTo(other._valueOrDefault);\n\n   /// <inheritdoc/>\n   public static bool operator <(PositiveInteger left, PositiveInteger right) => left._valueOrDefault < right._valueOrDefault;\n\n   /// <inheritdoc/>\n   public static bool operator <=(PositiveInteger left, PositiveInteger right) => left._valueOrDefault <= right._valueOrDefault;\n\n   /// <inheritdoc/>\n   public static bool operator >(PositiveInteger left, PositiveInteger right) => left._valueOrDefault > right._valueOrDefault;\n\n   /// <inheritdoc/>\n   public static bool operator >=(PositiveInteger left, PositiveInteger right) => left._valueOrDefault >= right._valueOrDefault;\n\n\n   /// <inheritdoc/>\n   public static PositiveInteger Parse(string s, IFormatProvider? provider) => int.Parse(s, provider);\n\n   /// <inheritdoc/>\n   public static bool TryParse(string? s, IFormatProvider? provider, out PositiveInteger result)\n   {\n   \tif (int.TryParse(s, provider, out var value))\n   \t{\n   \t\tresult = new PositiveInteger(value);\n   \t\treturn true;\n   \t}\n   \tresult = default;\n   \treturn false;\n   }\n\n   /// <inheritdoc/>\n   public override string ToString() => _valueOrDefault.ToString();\n\n   /// <inheritdoc/>\n   TypeCode IConvertible.GetTypeCode() => ((IConvertible)_valueOrDefault).GetTypeCode();\n\n   /// <inheritdoc/>\n   bool IConvertible.ToBoolean(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToBoolean(provider);\n\n   /// <inheritdoc/>\n   byte IConvertible.ToByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToByte(provider);\n\n   /// <inheritdoc/>\n   char IConvertible.ToChar(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToChar(provider);\n\n   /// <inheritdoc/>\n   DateTime IConvertible.ToDateTime(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDateTime(provider);\n\n   /// <inheritdoc/>\n   decimal IConvertible.ToDecimal(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDecimal(provider);\n\n   /// <inheritdoc/>\n   double IConvertible.ToDouble(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDouble(provider);\n\n   /// <inheritdoc/>\n   short IConvertible.ToInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt16(provider);\n\n   /// <inheritdoc/>\n   int IConvertible.ToInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt32(provider);\n\n   /// <inheritdoc/>\n   long IConvertible.ToInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt64(provider);\n\n   /// <inheritdoc/>\n   sbyte IConvertible.ToSByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSByte(provider);\n\n   /// <inheritdoc/>\n   float IConvertible.ToSingle(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSingle(provider);\n\n   /// <inheritdoc/>\n   string IConvertible.ToString(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToString(provider);\n\n   /// <inheritdoc/>\n   object IConvertible.ToType(Type conversionType, IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToType(conversionType, provider);\n\n   /// <inheritdoc/>\n   ushort IConvertible.ToUInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt16(provider);\n\n   /// <inheritdoc/>\n   uint IConvertible.ToUInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt32(provider);\n\n   /// <inheritdoc/>\n   ulong IConvertible.ToUInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt64(provider);\n}\n'})}),(0,r.jsx)(t.h2,{id:"jsonconverter",children:(0,r.jsx)(t.strong,{children:"JsonConverter"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing AltaSoft.DomainPrimitives;\nusing System;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Globalization;\nusing System.Text.Json.Serialization.Metadata;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace AltaSoft.DomainPrimitives.Converters;\n\n/// <summary>\n/// JsonConverter for <see cref = "PositiveInteger"/>\n/// </summary>\npublic sealed class PositiveIntegerJsonConverter : JsonConverter<PositiveInteger>\n{\n\t/// <inheritdoc/>\n\tpublic override PositiveInteger Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn JsonInternalConverters.Int32Converter.Read(ref reader, typeToConvert, options);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new JsonException(ex.Message);\n\t\t}\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override void Write(Utf8JsonWriter writer, PositiveInteger value, JsonSerializerOptions options)\n\t{\n\t\tJsonInternalConverters.Int32Converter.Write(writer, (int)value, options);\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override PositiveInteger ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn JsonInternalConverters.Int32Converter.ReadAsPropertyName(ref reader, typeToConvert, options);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new JsonException(ex.Message);\n\t\t}\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override void WriteAsPropertyName(Utf8JsonWriter writer, PositiveInteger value, JsonSerializerOptions options)\n\t{\n\t\tJsonInternalConverters.Int32Converter.WriteAsPropertyName(writer, (int)value, options);\n\t}\n}\n\n'})}),(0,r.jsx)(t.h2,{id:"type-converter",children:(0,r.jsx)(t.strong,{children:"Type Converter"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing AltaSoft.DomainPrimitives;\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace AltaSoft.DomainPrimitives.Converters;\n\n/// <summary>\n/// TypeConverter for <see cref = "PositiveInteger"/>\n/// </summary>\npublic sealed class PositiveIntegerTypeConverter : Int32Converter\n{\n\t/// <inheritdoc/>\n\tpublic override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)\n\t{\n\t\tvar result = base.ConvertFrom(context, culture, value);\n\t\tif (result is null)\n\t\t\treturn null;\n\t\ttry\n\t\t{\n\t\t\treturn new PositiveInteger((int)result);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new FormatException("Cannot parse PositiveInteger", ex);\n\t\t}\n\t}\n}\n'})}),(0,r.jsx)(t.h2,{id:"swagger-mappers",children:(0,r.jsx)(t.strong,{children:"Swagger Mappers"})}),(0,r.jsx)(t.p,{children:"A single file for all domainPrimitives containing all type mappings is generated."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing AltaSoft.DomainPrimitives;\nusing Microsoft.Extensions.DependencyInjection;\nusing Swashbuckle.AspNetCore.SwaggerGen;\nusing Microsoft.OpenApi.Models;\n\nnamespace AltaSoft.DomainPrimitives.Converters.Extensions;\n\n/// <summary>\n/// Helper class providing methods to configure Swagger mappings for DomainPrimitive types of AltaSoft.DomainPrimitives\n/// </summary>\npublic static class SwaggerTypeHelper\n{\n\t/// <summary>\n\t/// Adds Swagger mappings for specific custom types to ensure proper OpenAPI documentation generation.\n\t/// </summary>\n\t/// <param name="options">The SwaggerGenOptions instance to which mappings are added..</param>\n\t/// <remarks>\n\t/// The method adds Swagger mappings for the following types:\n\t/// <see cref="PositiveInteger"/>\n\t/// </remarks>\n\tpublic static void AddSwaggerMappings(this SwaggerGenOptions options)\n\t{\n\t\toptions.MapType<PositiveInteger>(() => new OpenApiSchema { Type = "integer", Format = "Int32" });\n\t\toptions.MapType<PositiveInteger?>(() => new OpenApiSchema { Type = "integer", Format = "Int32" });\n\t}\n}\n'})}),(0,r.jsx)(t.h2,{id:"specialized-tostring-method",children:"Specialized ToString method"}),(0,r.jsx)(t.p,{children:"By Default IDomainValue uses its underlying type's ToString method however this can be overriden by implementing a method specified below"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"static virtual string ToString(T value) => value.ToString() ?? string.Empty;\n"})}),(0,r.jsx)(t.h2,{id:"managing-generated-operators-for-numeric-types",children:"Managing Generated Operators for numeric types"}),(0,r.jsxs)(t.p,{children:["Mathematical operators for particular numeric types can be customized using the ",(0,r.jsx)(t.code,{children:"SupportedOperationsAttribute"}),". If left unspecified, all operators are generated by default (as shown below). Once this attribute is applied, manual specification of the operators becomes mandatory. Note that for ",(0,r.jsx)(t.code,{children:"byte"}),", ",(0,r.jsx)(t.code,{children:"sbyte"}),", ",(0,r.jsx)(t.code,{children:"short"}),", and ",(0,r.jsx)(t.code,{children:"ushort"})," types, mathematical operators will not be generated by default."]}),(0,r.jsx)(t.h3,{id:"default-numeric-types-generated-operators",children:"Default numeric types Generated Operators"}),(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"byte, sbyte"})," => ",(0,r.jsx)(t.code,{children:"None"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"short, ushort"})," => ",(0,r.jsx)(t.code,{children:"None"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"int, uint"})," => ",(0,r.jsx)(t.code,{children:"+ - / * %"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"long, ulong"})," => ",(0,r.jsx)(t.code,{children:"+ - / * %"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"double"})," => ",(0,r.jsx)(t.code,{children:"+ - / * %"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"decimal"})," => ",(0,r.jsx)(t.code,{children:"+ - / * %"})]}),"\n"]}),(0,r.jsxs)(t.h3,{id:"using-supportedoperationsattribute",children:["using ",(0,r.jsx)(t.code,{children:"SupportedOperationsAttribute"})]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'[SupportedOperations(Addition = false,Division = false,Modulus = false,Multiplication = true,Subtraction = true)]\npublic readonly partial record struct PositiveInteger : IDomainValue<int>\n{\n\tpublic static void Validate(int value)\n\t{\n\t\tif (value <= 0)\n\t\t\tthrow new InvalidDomainValueException("Number must be positive");\n\t}\n\tpublic static int Default => 1;\n}\n'})}),(0,r.jsx)(t.h3,{id:"for-further-customization-of-the-operators-consider-implementing-specific-interfaces-this-action-will-override-the-generated-operators-for-the-respective-domain-type",children:"For further customization of the operators, consider implementing specific interfaces. This action will override the generated operators for the respective domain type:"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public readonly partial record struct PositiveInteger :\n\tIDomainValue<int>,\n\tIAdditionOperators<PositiveInteger, PositiveInteger, PositiveInteger>\n{\n\tpublic static void Validate(int value)\n\t{\n\t\tif (value <= 0)\n\t\t\tthrow new InvalidDomainValueException("Number must be positive");\n\t}\n\tpublic static int Default => 1;\n\t//custom + operator\n\tpublic static PositiveInteger operator +(PositiveInteger left, PositiveInteger right)\n\t{\n\t\treturn (left._value + right._value + 1);\n\t}\n}\n'})}),(0,r.jsx)(t.h2,{id:"managing-serialization-format-for-date-related-types",children:"Managing Serialization Format for date-related types"}),(0,r.jsxs)(t.p,{children:["Certain date-related types like ",(0,r.jsx)(t.code,{children:"DateTime"}),", ",(0,r.jsx)(t.code,{children:"DateOnly"}),", ",(0,r.jsx)(t.code,{children:"TimeOnly"}),", ",(0,r.jsx)(t.code,{children:"DateTimeOffset"}),", and ",(0,r.jsx)(t.code,{children:"TimeSpan"})," can modify their serialization/deserialization format using the ",(0,r.jsx)(t.code,{children:"SerializationFormatAttribute"}),".\nFor instance, consider the ",(0,r.jsx)(t.code,{children:"GDay"})," type, which represents an XML gDay value. It implements the ",(0,r.jsx)(t.code,{children:"IDomainValue<DateOnly>"})," interface and utilizes the ",(0,r.jsx)(t.code,{children:"SerializationFormatAttribute"})," to specify a serialization format."]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'\n/// <summary>\n/// Represents an XML gDay value object, providing operations for parsing and handling gDay values.\n/// </summary>\n[SerializationFormat("dd")]\npublic readonly partial record struct GDay : IDomainValue<DateOnly>\n{\n\t/// <inheritdoc/>\n\tpublic static void Validate(DateOnly value)\n\t{ }\n\n\t/// <inheritdoc/>\n\tpublic static DateOnly Default => default;\n\n\t/// <inheritdoc/>\n\t// Customized string representation of DateOnly\n\tpublic static string ToString(DateOnly value) => value.ToString("dd");\n}\n'})}),(0,r.jsx)(t.h1,{id:"disable-generation-of-converters",children:"Disable Generation of Converters"}),(0,r.jsxs)(t.p,{children:["To disable the generation of Converters or Swagger Mappers in csproj file follow the below described steps.However,please note that if Swagger is ",(0,r.jsx)(t.strong,{children:"enabled"})," then you'll need to add reference to the  ",(0,r.jsx)(t.strong,{children:"Swashbuckle.AspNetCore.SwaggerGen"})]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'  <PropertyGroup>\n    <DomainPrimitiveGenerator_GenerateJsonConverters>false</DomainPrimitiveGenerator_GenerateJsonConverters>\n    <DomainPrimitiveGenerator_GenerateTypeConverters>false</DomainPrimitiveGenerator_GenerateTypeConverters>\n    <DomainPrimitiveGenerator_GenerateSwaggerConverters>false</DomainPrimitiveGenerator_GenerateSwaggerConverters>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateJsonConverters" />\n    <CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateTypeConverters" />\n    <CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateSwaggerConverters" />\n  </ItemGroup>\n'})}),(0,r.jsx)(t.h1,{id:"additional-features",children:"Additional Features"}),(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Handling Domain Value Exception"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["To ensure correct error handling, it's recommended to throw ",(0,r.jsx)(t.code,{children:"InvalidDomainValueException"})," or (descendants of ",(0,r.jsx)(t.code,{children:"InvalidDomainValueException"}),") provided in ",(0,r.jsx)(t.code,{children:"AltaSoft.DomainPrimitives.Abstractions"}),". This exception, when thrown from ",(0,r.jsx)(t.code,{children:"JsonConverter"})," or ",(0,r.jsx)(t.code,{children:"TypeConverter"}),", will  be converted to ",(0,r.jsx)(t.code,{children:"BadRequest"}),". Using any other exception in the ",(0,r.jsx)(t.code,{children:"Validate"})," method will prompt a compiler warning."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Chaining Primitive Types"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Chaining of primitive types is possible. For instance, considering the ",(0,r.jsx)(t.code,{children:"PositiveInteger"})," and ",(0,r.jsx)(t.code,{children:"BetweenOneAnd100"})," DomainPrimitives:"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public readonly partial record struct PositiveInteger : IDomainValue<int>\n\t{\n\t\tpublic static void Validate(int value)\n\t\t{\n\t\t\tif (value <= 0)\n\t\t\t\tthrow new InvalidDomainValueException("Number must be positive");\n\t\t}\n\t\tpublic static int Default => 1;\n\t}\n\npublic readonly partial record struct BetweenOneAnd100 : IDomainValue<PositiveInteger>\n{\n\tpublic static void Validate(PositiveInteger value)\n\t{\n\t\t\tif (value < 100)\n\t\t\t\tthrow new InvalidDomainValueException("Value must be less than 100");\n\t}\n\tpublic static PositiveInteger Default => 1; // using implicit operators this is possible.\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Defined type ",(0,r.jsx)(t.code,{children:"BetweenOneAnd100"}),"  automatically inherits restrictions from PositiveInteger. Operators restricted in PositiveInteger are also inherited. Further restrictions on operators can be added using the ",(0,r.jsx)(t.code,{children:"SupportedOperationsAttribute"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'[SupportedOperations(Addition=false)]\npublic readonly partial record struct BetweenOneAnd100 : IDomainValue<PositiveInteger>\n\t{\n\t\tpublic static void Validate(PositiveInteger value)\n\t\t{\n\t\t\t\tif (value < 100)\n\t\t\t\t\tthrow new InvalidDomainValueException("Value must be less than 100");\n\t\t}\n\t\tpublic static PositiveInteger Default => 1; // using implicit operators this is possible.\n\t}\n'})}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Default Value Guarantee with IDomainValue of T"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"IDomainValue<T>"})," incorporates a static abstract property Default to ensure the correct domain state if a value is uninitialized. For example:"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class TestObject\n{\n\tpublic PositiveInteger CustomerId { get; set; }\n}\n\npublic class Program\n{\n\tvar test = new TestObject();\n\tConsole.Write(test); // If no Default was defined, CustomerId would default to 0, providing invalid value in the Domain. Providing a Default value ensures initialization according to validation rules by initializing in this example to 1 .\n}\n"})}),"\n"]}),"\n"]}),(0,r.jsx)(t.p,{children:"These additional features offer enhanced control over exceptions, chaining of primitive types, inheritance of restrictions and operators, and a mechanism to ensure correct default values within the domain."}),(0,r.jsx)(t.h1,{id:"restrictions",children:"Restrictions"}),(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Implementation of IDomainValue Interface"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["DomainPrimitives are mandated to implement the ",(0,r.jsx)(t.code,{children:"IDomainValue<T>"})," interface to ensure adherence to domain-specific constraints and behaviors."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Constructor Limitation"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"No constructors should be explicitly defined within DomainPrimitives. Doing so will result in a compiler error."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Prohibition of Public Properties or Fields"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["DomainPrimitive types should not contain any explicitly defined public properties or fields. The backing field will be automatically generated.","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["If any property or field is explicitly named ",(0,r.jsx)(t.code,{children:"_value"}),", ",(0,r.jsx)(t.code,{children:"_valueOrDefault"}),", or ",(0,r.jsx)(t.code,{children:"_isInitialized"}),", a compiler error will be triggered."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),(0,r.jsx)(t.h1,{id:"examples",children:"Examples"}),(0,r.jsx)(t.h2,{id:"implicit-usage-of-domaintype",children:"Implicit Usage of DomainType"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public readonly partial record struct PositiveAmount : IDomainValue<decimal>\n{\n\tpublic static void Validate(decimal value)\n\t{\n\t\tif (value <= 0m)\n\t\t\tthrow new InvalidDomainValueException("Must be a a positive number");\n\t}\n\n\tpublic static decimal Default => 1m;\n}\n\npublic static class Example\n{\n\tpublic static void ImplicitConversion()\n\t{\n\t\tvar amount = new PositiveAmount(100m);\n\t\tPositiveAmount amount2 = 100m; // implicitly converted to PositiveAmount\n\n\t\t//implicilty casted to decimal\n\t\tdecimal amountInDecimal = amount + amount2;        \n\t}\n}\n\n'})}),(0,r.jsx)(t.h1,{id:"json-conversion",children:"Json Conversion"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'[SupportedOperations] // no mathematical operators should be generated\npublic readonly partial record struct CustomerId : IDomainValue<int>\n{\n\tpublic static void Validate(int value)\n\t{\n\t\tif (value <= 0)\n\t\t\tthrow new InvalidDomainValueException("Value must be a positive number");\n\t}\n\n\tpublic static int Default => 1;\n}\n\npublic sealed class Transaction\n{\n\tpublic CustomerId FromId { get; set; }\n\tpublic CustomerId? ToId { get; set; }\n\tpublic PositiveAmount Amount { get; set; }\n\tpublic PositiveAmount? Fees { get; set; }\n}\n\npublic static void JsonSerializationAndDeserialization()\n{\n\tvar amount = new Transaction()\n        {\n            Amount = 100.523m,\n            Fees = null,\n            FromId = 1,\n            ToId = null\n        };\n\n    var jsonValue = JsonSerializer.Serialize(amount); //this will produce the same result as changing customerId to int and PositiveAmount to decimal\n    var newValue = JsonSerializer.Deserialize<Transaction>(jsonValue)\n}\n'})}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"Serialized Json"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-json",children:'{\n    "FromId": 1,\n    "ToId": null,\n    "Amount": 100.523,\n    "Fees": null\n}\n'})}),(0,r.jsx)(t.h1,{id:"contributions",children:"Contributions"}),(0,r.jsx)(t.p,{children:"Contributions to AltaSoft.DomainPrimitives are welcome! Whether you have suggestions or wish to contribute code, feel free to submit a pull request or open an issue."}),(0,r.jsx)(t.h1,{id:"contact",children:"Contact"}),(0,r.jsx)(t.p,{children:"For support, questions, or additional information, please visit GitHub Issues."}),(0,r.jsx)(t.h1,{id:"license",children:"License"}),(0,r.jsxs)(t.p,{children:["This project is licensed under ",(0,r.jsx)(t.a,{href:"https://github.com/altasoft/DomainPrimitives/LICENSE.TXT",children:"MIT"}),". See the LICENSE file for details."]})]}),"\n",(0,r.jsx)(t.h3,{id:"about",children:"About"}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsx)(t.p,{children:"One of the most complete and mature libraries for DomainPrimitives in  .NET"})}),"\n",(0,r.jsx)(t.h2,{id:"how-to-use",children:"How to use"}),"\n",(0,r.jsx)(t.h3,{id:"example-source-csproj-source-files",children:"Example (source csproj, source files)"}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsxs)(s.A,{value:"csproj",label:"CSharp Project",children:[(0,r.jsxs)(t.p,{children:["This is the CSharp Project that references ",(0,r.jsx)(t.strong,{children:"DomainPrimitives"})]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",metastring:"showLineNumbers {12}",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n\t<PropertyGroup>\n\t\t<OutputType>Exe</OutputType>\n\t\t<TargetFramework>net8.0</TargetFramework>\n\t\t<ImplicitUsings>enable</ImplicitUsings>\n\t\t<Nullable>enable</Nullable>\n\t</PropertyGroup>\n\n\t<ItemGroup>\n\t\t<PackageReference Include="AltaSoft.DomainPrimitives.Abstractions" Version="1.0.3" />\n\t\t<PackageReference Include="AltaSoft.DomainPrimitives.Generator" Version="1.0.3" OutputItemType="Analyzer" ReferenceOutputAssembly="false" PrivateAssets="all" ExcludeAssets="runtime" />\n\t</ItemGroup>\n\t<PropertyGroup>\n\t\t<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n\t\t<CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n\t</PropertyGroup>\n\n\t<PropertyGroup>\n\t\t\x3c!--<DomainPrimitiveGenerator_GenerateJsonConverters>false</DomainPrimitiveGenerator_GenerateJsonConverters>--\x3e\n\t\t\x3c!--<DomainPrimitiveGenerator_GenerateTypeConverters>false</DomainPrimitiveGenerator_GenerateTypeConverters>--\x3e\n\t\t<DomainPrimitiveGenerator_GenerateSwaggerConverters>false</DomainPrimitiveGenerator_GenerateSwaggerConverters>\n\t</PropertyGroup>\n\t<ItemGroup>\n\t\t\x3c!--<CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateTypeConverters" />--\x3e\n\t\t\x3c!--<CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateJsonConverters" />--\x3e\n\t\t<CompilerVisibleProperty Include="DomainPrimitiveGenerator_GenerateSwaggerConverters" />\n\t</ItemGroup>\n\n</Project>\n\n'})})]}),(0,r.jsxs)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\Program.cs",label:"Program.cs",children:[(0,r.jsxs)(t.p,{children:["This is the use of ",(0,r.jsx)(t.strong,{children:"DomainPrimitives"})," in ",(0,r.jsx)(t.em,{children:"Program.cs"})]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"// See https://aka.ms/new-console-template for more information\nusing DomainPrimitives;\n\nvar year = new YearDate(1970);\nvar month = new MonthDate(4);\nvar day = new DayDate(16);\nyear += 1;\nvar p=new Person(year,month,day);\n\nConsole.WriteLine(p.DOB);\n"})})]}),(0,r.jsxs)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\DOB.cs",label:"DOB.cs",children:[(0,r.jsxs)(t.p,{children:["This is the use of ",(0,r.jsx)(t.strong,{children:"DomainPrimitives"})," in ",(0,r.jsx)(t.em,{children:"DOB.cs"})]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'using AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives;\n\npublic readonly partial record struct YearDate : IDomainValue<int>\n{\n    public static void Validate(int value)\n    {\n        if (value <= 0)\n            throw new InvalidDomainValueException("year must be positive");\n    }\n    public static int Default => 1;\n}\npublic readonly partial record struct MonthDate : IDomainValue<int>\n{\n    public static void Validate(int value)\n    {\n        if (value <= 0)\n            throw new InvalidDomainValueException("year must be positive");\n    }\n    public static int Default => 1;\n}\n\npublic readonly partial record struct DayDate : IDomainValue<int>\n{\n    public static void Validate(int value)\n    {\n        if (value <= 0)\n            throw new InvalidDomainValueException("year must be positive");\n    }\n    public static int Default => 1;\n}\n\n'})})]}),(0,r.jsxs)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\TaskAfterDelay.cs",label:"TaskAfterDelay.cs",children:[(0,r.jsxs)(t.p,{children:["This is the use of ",(0,r.jsx)(t.strong,{children:"DomainPrimitives"})," in ",(0,r.jsx)(t.em,{children:"TaskAfterDelay.cs"})]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:"namespace DomainPrimitives;\ninternal class Person\n{\n    public Person(YearDate year,MonthDate month,DayDate day)\n    {\n        DOB = new DateOnly(year,month,day);\n    }\n    public DateOnly DOB { get; private set; }\n\n    \n}\n\n"})})]})]}),"\n",(0,r.jsx)(t.h3,{id:"generated-files",children:"Generated Files"}),"\n",(0,r.jsx)(t.p,{children:"Those are taken from $(BaseIntermediateOutputPath)\\GX"}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\DayDate.g.cs",label:"DayDate.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Text.Json.Serialization;\nusing DomainPrimitives.Converters;\nusing System.ComponentModel;\n\nnamespace DomainPrimitives;\n\n[JsonConverter(typeof(DayDateJsonConverter))]\n[TypeConverter(typeof(DayDateTypeConverter))]\n[DebuggerDisplay("{_valueOrDefault}")]\npublic readonly partial record struct DayDate :\n\t\tIAdditionOperators<DayDate, DayDate, DayDate>,\n\t\tISubtractionOperators<DayDate, DayDate, DayDate>,\n\t\tIMultiplyOperators<DayDate, DayDate, DayDate>,\n\t\tIDivisionOperators<DayDate, DayDate, DayDate>,\n\t\tIModulusOperators<DayDate, DayDate, DayDate>,\n\t\tIComparisonOperators<DayDate, DayDate, bool>,\n\t\tIComparable,\n\t\tIComparable<DayDate>,\n\t\tIParsable<DayDate>,\n\t\tIConvertible\n{\n\tprivate int _valueOrDefault => _isInitialized ? _value : Default;\n\t[DebuggerBrowsable(DebuggerBrowsableState.Never)]\n\tprivate readonly int _value;\n\t[DebuggerBrowsable(DebuggerBrowsableState.Never)]\n\tprivate readonly bool _isInitialized;\n\t\n\t/// <summary>\n\t/// Initializes a new instance of the <see cref="DayDate"/> class by validating the specified <see cref="int"/> value using <see cref="Validate"/> static method.\n\t/// </summary>\n\t/// <param name="value">The value to be validated..</param>\n\tpublic DayDate(int value)\n\t{\n\t\t\tValidate(value);\n\t\t\t_value = value;\n\t\t\t_isInitialized = true;\n\t}\n\t\n\t[Obsolete("Domain primitive cannot be created using empty Ctor", true)]\n\tpublic DayDate() : this(Default)\n\t{\n\t}\n\t\n\t/// <summary>\n\t/// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "DayDate"/></summary>\n\t/// </summary>\n\tpublic static implicit operator DayDate(int value) => new(value);\n\n\t/// <summary>\n\t/// <summary>Implicit conversion from <see cref = "int?"/> to <see cref = "DayDate?"/></summary>\n\t/// </summary>\n\t[return: NotNullIfNotNull(nameof(value))]\n\tpublic static implicit operator DayDate?(int? value) => value is null ? null : new(value.Value);\n\n\t/// <summary>\n\t/// <summary>Implicit conversion from <see cref = "DayDate"/> to <see cref = "int"/></summary>\n\t/// </summary>\n\tpublic static implicit operator int(DayDate value) => (int)value._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static DayDate operator +(DayDate left, DayDate right) => new(left._valueOrDefault + right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static DayDate operator -(DayDate left, DayDate right) => new(left._valueOrDefault - right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static DayDate operator *(DayDate left, DayDate right) => new(left._valueOrDefault * right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static DayDate operator /(DayDate left, DayDate right) => new(left._valueOrDefault / right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static DayDate operator %(DayDate left, DayDate right) => new(left._valueOrDefault % right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic int CompareTo(object? value)\n\t{\n\t\tif (value is null)\n\t\t\treturn 1;\n\n\t\tif (value is DayDate c)\n\t\t\treturn CompareTo(c);\n\n\t\tthrow new ArgumentException("Object is not a DayDate", nameof(value));\n\t}\n\n\t/// <inheritdoc/>\n\tpublic int CompareTo(DayDate other) => _valueOrDefault.CompareTo(other._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static bool operator <(DayDate left, DayDate right) => left._valueOrDefault < right._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static bool operator <=(DayDate left, DayDate right) => left._valueOrDefault <= right._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static bool operator >(DayDate left, DayDate right) => left._valueOrDefault > right._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static bool operator >=(DayDate left, DayDate right) => left._valueOrDefault >= right._valueOrDefault;\n\n\n\t/// <inheritdoc/>\n\tpublic static DayDate Parse(string s, IFormatProvider? provider) => int.Parse(s, provider);\n\n\t/// <inheritdoc/>\n\tpublic static bool TryParse(string? s, IFormatProvider? provider, out DayDate result)\n\t{\n\t\tif (int.TryParse(s, provider, out var value))\n\t\t{\n\t\t\tresult = new DayDate(value);\n\t\t\treturn true;\n\t\t}\n\t\tresult = default;\n\t\treturn false;\n\t}\n\n\n\t/// <inheritdoc/>\n\tpublic override string ToString() => _valueOrDefault.ToString();\n\n\t/// <inheritdoc/>\n\tTypeCode IConvertible.GetTypeCode() => ((IConvertible)_valueOrDefault).GetTypeCode();\n\n\t/// <inheritdoc/>\n\tbool IConvertible.ToBoolean(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToBoolean(provider);\n\n\t/// <inheritdoc/>\n\tbyte IConvertible.ToByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToByte(provider);\n\n\t/// <inheritdoc/>\n\tchar IConvertible.ToChar(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToChar(provider);\n\n\t/// <inheritdoc/>\n\tDateTime IConvertible.ToDateTime(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDateTime(provider);\n\n\t/// <inheritdoc/>\n\tdecimal IConvertible.ToDecimal(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDecimal(provider);\n\n\t/// <inheritdoc/>\n\tdouble IConvertible.ToDouble(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDouble(provider);\n\n\t/// <inheritdoc/>\n\tshort IConvertible.ToInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt16(provider);\n\n\t/// <inheritdoc/>\n\tint IConvertible.ToInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt32(provider);\n\n\t/// <inheritdoc/>\n\tlong IConvertible.ToInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt64(provider);\n\n\t/// <inheritdoc/>\n\tsbyte IConvertible.ToSByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSByte(provider);\n\n\t/// <inheritdoc/>\n\tfloat IConvertible.ToSingle(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSingle(provider);\n\n\t/// <inheritdoc/>\n\tstring IConvertible.ToString(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToString(provider);\n\n\t/// <inheritdoc/>\n\tobject IConvertible.ToType(Type conversionType, IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToType(conversionType, provider);\n\n\t/// <inheritdoc/>\n\tushort IConvertible.ToUInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt16(provider);\n\n\t/// <inheritdoc/>\n\tuint IConvertible.ToUInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt32(provider);\n\n\t/// <inheritdoc/>\n\tulong IConvertible.ToUInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt64(provider);\n}\n\n'})})}),(0,r.jsx)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\DayDateJsonConverter.g.cs",label:"DayDateJsonConverter.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Globalization;\nusing System.Text.Json.Serialization.Metadata;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// JsonConverter for <see cref = "DayDate"/>\n/// </summary>\npublic sealed class DayDateJsonConverter : JsonConverter<DayDate>\n{\n\t/// <inheritdoc/>\n\tpublic override DayDate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn JsonInternalConverters.Int32Converter.Read(ref reader, typeToConvert, options);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new JsonException(ex.Message);\n\t\t}\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override void Write(Utf8JsonWriter writer, DayDate value, JsonSerializerOptions options)\n\t{\n\t\tJsonInternalConverters.Int32Converter.Write(writer, (int)value, options);\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override DayDate ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn JsonInternalConverters.Int32Converter.ReadAsPropertyName(ref reader, typeToConvert, options);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new JsonException(ex.Message);\n\t\t}\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override void WriteAsPropertyName(Utf8JsonWriter writer, DayDate value, JsonSerializerOptions options)\n\t{\n\t\tJsonInternalConverters.Int32Converter.WriteAsPropertyName(writer, (int)value, options);\n\t}\n}\n\n'})})}),(0,r.jsx)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\DayDateTypeConverter.g.cs",label:"DayDateTypeConverter.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// TypeConverter for <see cref = "DayDate"/>\n/// </summary>\npublic sealed class DayDateTypeConverter : Int32Converter\n{\n\t/// <inheritdoc/>\n\tpublic override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)\n\t{\n\t\tvar result = base.ConvertFrom(context, culture, value);\n\t\tif (result is null)\n\t\t\treturn null;\n\t\ttry\n\t\t{\n\t\t\treturn new DayDate((int)result);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new FormatException("Cannot parse DayDate", ex);\n\t\t}\n\t}\n}\n\n'})})}),(0,r.jsx)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\MonthDate.g.cs",label:"MonthDate.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Text.Json.Serialization;\nusing DomainPrimitives.Converters;\nusing System.ComponentModel;\n\nnamespace DomainPrimitives;\n\n[JsonConverter(typeof(MonthDateJsonConverter))]\n[TypeConverter(typeof(MonthDateTypeConverter))]\n[DebuggerDisplay("{_valueOrDefault}")]\npublic readonly partial record struct MonthDate :\n\t\tIAdditionOperators<MonthDate, MonthDate, MonthDate>,\n\t\tISubtractionOperators<MonthDate, MonthDate, MonthDate>,\n\t\tIMultiplyOperators<MonthDate, MonthDate, MonthDate>,\n\t\tIDivisionOperators<MonthDate, MonthDate, MonthDate>,\n\t\tIModulusOperators<MonthDate, MonthDate, MonthDate>,\n\t\tIComparisonOperators<MonthDate, MonthDate, bool>,\n\t\tIComparable,\n\t\tIComparable<MonthDate>,\n\t\tIParsable<MonthDate>,\n\t\tIConvertible\n{\n\tprivate int _valueOrDefault => _isInitialized ? _value : Default;\n\t[DebuggerBrowsable(DebuggerBrowsableState.Never)]\n\tprivate readonly int _value;\n\t[DebuggerBrowsable(DebuggerBrowsableState.Never)]\n\tprivate readonly bool _isInitialized;\n\t\n\t/// <summary>\n\t/// Initializes a new instance of the <see cref="MonthDate"/> class by validating the specified <see cref="int"/> value using <see cref="Validate"/> static method.\n\t/// </summary>\n\t/// <param name="value">The value to be validated..</param>\n\tpublic MonthDate(int value)\n\t{\n\t\t\tValidate(value);\n\t\t\t_value = value;\n\t\t\t_isInitialized = true;\n\t}\n\t\n\t[Obsolete("Domain primitive cannot be created using empty Ctor", true)]\n\tpublic MonthDate() : this(Default)\n\t{\n\t}\n\t\n\t/// <summary>\n\t/// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "MonthDate"/></summary>\n\t/// </summary>\n\tpublic static implicit operator MonthDate(int value) => new(value);\n\n\t/// <summary>\n\t/// <summary>Implicit conversion from <see cref = "int?"/> to <see cref = "MonthDate?"/></summary>\n\t/// </summary>\n\t[return: NotNullIfNotNull(nameof(value))]\n\tpublic static implicit operator MonthDate?(int? value) => value is null ? null : new(value.Value);\n\n\t/// <summary>\n\t/// <summary>Implicit conversion from <see cref = "MonthDate"/> to <see cref = "int"/></summary>\n\t/// </summary>\n\tpublic static implicit operator int(MonthDate value) => (int)value._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static MonthDate operator +(MonthDate left, MonthDate right) => new(left._valueOrDefault + right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static MonthDate operator -(MonthDate left, MonthDate right) => new(left._valueOrDefault - right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static MonthDate operator *(MonthDate left, MonthDate right) => new(left._valueOrDefault * right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static MonthDate operator /(MonthDate left, MonthDate right) => new(left._valueOrDefault / right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static MonthDate operator %(MonthDate left, MonthDate right) => new(left._valueOrDefault % right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic int CompareTo(object? value)\n\t{\n\t\tif (value is null)\n\t\t\treturn 1;\n\n\t\tif (value is MonthDate c)\n\t\t\treturn CompareTo(c);\n\n\t\tthrow new ArgumentException("Object is not a MonthDate", nameof(value));\n\t}\n\n\t/// <inheritdoc/>\n\tpublic int CompareTo(MonthDate other) => _valueOrDefault.CompareTo(other._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static bool operator <(MonthDate left, MonthDate right) => left._valueOrDefault < right._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static bool operator <=(MonthDate left, MonthDate right) => left._valueOrDefault <= right._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static bool operator >(MonthDate left, MonthDate right) => left._valueOrDefault > right._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static bool operator >=(MonthDate left, MonthDate right) => left._valueOrDefault >= right._valueOrDefault;\n\n\n\t/// <inheritdoc/>\n\tpublic static MonthDate Parse(string s, IFormatProvider? provider) => int.Parse(s, provider);\n\n\t/// <inheritdoc/>\n\tpublic static bool TryParse(string? s, IFormatProvider? provider, out MonthDate result)\n\t{\n\t\tif (int.TryParse(s, provider, out var value))\n\t\t{\n\t\t\tresult = new MonthDate(value);\n\t\t\treturn true;\n\t\t}\n\t\tresult = default;\n\t\treturn false;\n\t}\n\n\n\t/// <inheritdoc/>\n\tpublic override string ToString() => _valueOrDefault.ToString();\n\n\t/// <inheritdoc/>\n\tTypeCode IConvertible.GetTypeCode() => ((IConvertible)_valueOrDefault).GetTypeCode();\n\n\t/// <inheritdoc/>\n\tbool IConvertible.ToBoolean(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToBoolean(provider);\n\n\t/// <inheritdoc/>\n\tbyte IConvertible.ToByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToByte(provider);\n\n\t/// <inheritdoc/>\n\tchar IConvertible.ToChar(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToChar(provider);\n\n\t/// <inheritdoc/>\n\tDateTime IConvertible.ToDateTime(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDateTime(provider);\n\n\t/// <inheritdoc/>\n\tdecimal IConvertible.ToDecimal(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDecimal(provider);\n\n\t/// <inheritdoc/>\n\tdouble IConvertible.ToDouble(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDouble(provider);\n\n\t/// <inheritdoc/>\n\tshort IConvertible.ToInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt16(provider);\n\n\t/// <inheritdoc/>\n\tint IConvertible.ToInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt32(provider);\n\n\t/// <inheritdoc/>\n\tlong IConvertible.ToInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt64(provider);\n\n\t/// <inheritdoc/>\n\tsbyte IConvertible.ToSByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSByte(provider);\n\n\t/// <inheritdoc/>\n\tfloat IConvertible.ToSingle(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSingle(provider);\n\n\t/// <inheritdoc/>\n\tstring IConvertible.ToString(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToString(provider);\n\n\t/// <inheritdoc/>\n\tobject IConvertible.ToType(Type conversionType, IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToType(conversionType, provider);\n\n\t/// <inheritdoc/>\n\tushort IConvertible.ToUInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt16(provider);\n\n\t/// <inheritdoc/>\n\tuint IConvertible.ToUInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt32(provider);\n\n\t/// <inheritdoc/>\n\tulong IConvertible.ToUInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt64(provider);\n}\n\n'})})}),(0,r.jsx)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\MonthDateJsonConverter.g.cs",label:"MonthDateJsonConverter.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Globalization;\nusing System.Text.Json.Serialization.Metadata;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// JsonConverter for <see cref = "MonthDate"/>\n/// </summary>\npublic sealed class MonthDateJsonConverter : JsonConverter<MonthDate>\n{\n\t/// <inheritdoc/>\n\tpublic override MonthDate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn JsonInternalConverters.Int32Converter.Read(ref reader, typeToConvert, options);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new JsonException(ex.Message);\n\t\t}\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override void Write(Utf8JsonWriter writer, MonthDate value, JsonSerializerOptions options)\n\t{\n\t\tJsonInternalConverters.Int32Converter.Write(writer, (int)value, options);\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override MonthDate ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn JsonInternalConverters.Int32Converter.ReadAsPropertyName(ref reader, typeToConvert, options);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new JsonException(ex.Message);\n\t\t}\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override void WriteAsPropertyName(Utf8JsonWriter writer, MonthDate value, JsonSerializerOptions options)\n\t{\n\t\tJsonInternalConverters.Int32Converter.WriteAsPropertyName(writer, (int)value, options);\n\t}\n}\n\n'})})}),(0,r.jsx)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\MonthDateTypeConverter.g.cs",label:"MonthDateTypeConverter.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// TypeConverter for <see cref = "MonthDate"/>\n/// </summary>\npublic sealed class MonthDateTypeConverter : Int32Converter\n{\n\t/// <inheritdoc/>\n\tpublic override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)\n\t{\n\t\tvar result = base.ConvertFrom(context, culture, value);\n\t\tif (result is null)\n\t\t\treturn null;\n\t\ttry\n\t\t{\n\t\t\treturn new MonthDate((int)result);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new FormatException("Cannot parse MonthDate", ex);\n\t\t}\n\t}\n}\n\n'})})}),(0,r.jsx)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\YearDate.g.cs",label:"YearDate.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Text.Json.Serialization;\nusing DomainPrimitives.Converters;\nusing System.ComponentModel;\n\nnamespace DomainPrimitives;\n\n[JsonConverter(typeof(YearDateJsonConverter))]\n[TypeConverter(typeof(YearDateTypeConverter))]\n[DebuggerDisplay("{_valueOrDefault}")]\npublic readonly partial record struct YearDate :\n\t\tIAdditionOperators<YearDate, YearDate, YearDate>,\n\t\tISubtractionOperators<YearDate, YearDate, YearDate>,\n\t\tIMultiplyOperators<YearDate, YearDate, YearDate>,\n\t\tIDivisionOperators<YearDate, YearDate, YearDate>,\n\t\tIModulusOperators<YearDate, YearDate, YearDate>,\n\t\tIComparisonOperators<YearDate, YearDate, bool>,\n\t\tIComparable,\n\t\tIComparable<YearDate>,\n\t\tIParsable<YearDate>,\n\t\tIConvertible\n{\n\tprivate int _valueOrDefault => _isInitialized ? _value : Default;\n\t[DebuggerBrowsable(DebuggerBrowsableState.Never)]\n\tprivate readonly int _value;\n\t[DebuggerBrowsable(DebuggerBrowsableState.Never)]\n\tprivate readonly bool _isInitialized;\n\t\n\t/// <summary>\n\t/// Initializes a new instance of the <see cref="YearDate"/> class by validating the specified <see cref="int"/> value using <see cref="Validate"/> static method.\n\t/// </summary>\n\t/// <param name="value">The value to be validated..</param>\n\tpublic YearDate(int value)\n\t{\n\t\t\tValidate(value);\n\t\t\t_value = value;\n\t\t\t_isInitialized = true;\n\t}\n\t\n\t[Obsolete("Domain primitive cannot be created using empty Ctor", true)]\n\tpublic YearDate() : this(Default)\n\t{\n\t}\n\t\n\t/// <summary>\n\t/// <summary>Implicit conversion from <see cref = "int"/> to <see cref = "YearDate"/></summary>\n\t/// </summary>\n\tpublic static implicit operator YearDate(int value) => new(value);\n\n\t/// <summary>\n\t/// <summary>Implicit conversion from <see cref = "int?"/> to <see cref = "YearDate?"/></summary>\n\t/// </summary>\n\t[return: NotNullIfNotNull(nameof(value))]\n\tpublic static implicit operator YearDate?(int? value) => value is null ? null : new(value.Value);\n\n\t/// <summary>\n\t/// <summary>Implicit conversion from <see cref = "YearDate"/> to <see cref = "int"/></summary>\n\t/// </summary>\n\tpublic static implicit operator int(YearDate value) => (int)value._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static YearDate operator +(YearDate left, YearDate right) => new(left._valueOrDefault + right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static YearDate operator -(YearDate left, YearDate right) => new(left._valueOrDefault - right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static YearDate operator *(YearDate left, YearDate right) => new(left._valueOrDefault * right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static YearDate operator /(YearDate left, YearDate right) => new(left._valueOrDefault / right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static YearDate operator %(YearDate left, YearDate right) => new(left._valueOrDefault % right._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic int CompareTo(object? value)\n\t{\n\t\tif (value is null)\n\t\t\treturn 1;\n\n\t\tif (value is YearDate c)\n\t\t\treturn CompareTo(c);\n\n\t\tthrow new ArgumentException("Object is not a YearDate", nameof(value));\n\t}\n\n\t/// <inheritdoc/>\n\tpublic int CompareTo(YearDate other) => _valueOrDefault.CompareTo(other._valueOrDefault);\n\n\t/// <inheritdoc/>\n\tpublic static bool operator <(YearDate left, YearDate right) => left._valueOrDefault < right._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static bool operator <=(YearDate left, YearDate right) => left._valueOrDefault <= right._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static bool operator >(YearDate left, YearDate right) => left._valueOrDefault > right._valueOrDefault;\n\n\t/// <inheritdoc/>\n\tpublic static bool operator >=(YearDate left, YearDate right) => left._valueOrDefault >= right._valueOrDefault;\n\n\n\t/// <inheritdoc/>\n\tpublic static YearDate Parse(string s, IFormatProvider? provider) => int.Parse(s, provider);\n\n\t/// <inheritdoc/>\n\tpublic static bool TryParse(string? s, IFormatProvider? provider, out YearDate result)\n\t{\n\t\tif (int.TryParse(s, provider, out var value))\n\t\t{\n\t\t\tresult = new YearDate(value);\n\t\t\treturn true;\n\t\t}\n\t\tresult = default;\n\t\treturn false;\n\t}\n\n\n\t/// <inheritdoc/>\n\tpublic override string ToString() => _valueOrDefault.ToString();\n\n\t/// <inheritdoc/>\n\tTypeCode IConvertible.GetTypeCode() => ((IConvertible)_valueOrDefault).GetTypeCode();\n\n\t/// <inheritdoc/>\n\tbool IConvertible.ToBoolean(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToBoolean(provider);\n\n\t/// <inheritdoc/>\n\tbyte IConvertible.ToByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToByte(provider);\n\n\t/// <inheritdoc/>\n\tchar IConvertible.ToChar(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToChar(provider);\n\n\t/// <inheritdoc/>\n\tDateTime IConvertible.ToDateTime(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDateTime(provider);\n\n\t/// <inheritdoc/>\n\tdecimal IConvertible.ToDecimal(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDecimal(provider);\n\n\t/// <inheritdoc/>\n\tdouble IConvertible.ToDouble(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToDouble(provider);\n\n\t/// <inheritdoc/>\n\tshort IConvertible.ToInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt16(provider);\n\n\t/// <inheritdoc/>\n\tint IConvertible.ToInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt32(provider);\n\n\t/// <inheritdoc/>\n\tlong IConvertible.ToInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToInt64(provider);\n\n\t/// <inheritdoc/>\n\tsbyte IConvertible.ToSByte(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSByte(provider);\n\n\t/// <inheritdoc/>\n\tfloat IConvertible.ToSingle(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToSingle(provider);\n\n\t/// <inheritdoc/>\n\tstring IConvertible.ToString(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToString(provider);\n\n\t/// <inheritdoc/>\n\tobject IConvertible.ToType(Type conversionType, IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToType(conversionType, provider);\n\n\t/// <inheritdoc/>\n\tushort IConvertible.ToUInt16(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt16(provider);\n\n\t/// <inheritdoc/>\n\tuint IConvertible.ToUInt32(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt32(provider);\n\n\t/// <inheritdoc/>\n\tulong IConvertible.ToUInt64(IFormatProvider? provider) => ((IConvertible)_valueOrDefault).ToUInt64(provider);\n}\n\n'})})}),(0,r.jsx)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\YearDateJsonConverter.g.cs",label:"YearDateJsonConverter.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Globalization;\nusing System.Text.Json.Serialization.Metadata;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// JsonConverter for <see cref = "YearDate"/>\n/// </summary>\npublic sealed class YearDateJsonConverter : JsonConverter<YearDate>\n{\n\t/// <inheritdoc/>\n\tpublic override YearDate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn JsonInternalConverters.Int32Converter.Read(ref reader, typeToConvert, options);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new JsonException(ex.Message);\n\t\t}\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override void Write(Utf8JsonWriter writer, YearDate value, JsonSerializerOptions options)\n\t{\n\t\tJsonInternalConverters.Int32Converter.Write(writer, (int)value, options);\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override YearDate ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn JsonInternalConverters.Int32Converter.ReadAsPropertyName(ref reader, typeToConvert, options);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new JsonException(ex.Message);\n\t\t}\n\t}\n\n\t/// <inheritdoc/>\n\tpublic override void WriteAsPropertyName(Utf8JsonWriter writer, YearDate value, JsonSerializerOptions options)\n\t{\n\t\tJsonInternalConverters.Int32Converter.WriteAsPropertyName(writer, (int)value, options);\n\t}\n}\n\n'})})}),(0,r.jsx)(s.A,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\DomainPrimitives\\src\\DomainPrimitives\\obj\\GX\\AltaSoft.DomainPrimitives.Generator\\AltaSoft.DomainPrimitives.Generator.DomainPrimitiveGenerator\\YearDateTypeConverter.g.cs",label:"YearDateTypeConverter.g.cs",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:"showLineNumbers ",children:'//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a AltaSoft.DomainPrimitives.Generator v1.0.0\n//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\n#nullable enable\n\nusing DomainPrimitives;\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\nusing AltaSoft.DomainPrimitives.Abstractions;\n\nnamespace DomainPrimitives.Converters;\n\n/// <summary>\n/// TypeConverter for <see cref = "YearDate"/>\n/// </summary>\npublic sealed class YearDateTypeConverter : Int32Converter\n{\n\t/// <inheritdoc/>\n\tpublic override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)\n\t{\n\t\tvar result = base.ConvertFrom(context, culture, value);\n\t\tif (result is null)\n\t\t\treturn null;\n\t\ttry\n\t\t{\n\t\t\treturn new YearDate((int)result);\n\t\t}\n\t\tcatch (InvalidDomainValueException ex)\n\t\t{\n\t\t\tthrow new FormatException("Cannot parse YearDate", ex);\n\t\t}\n\t}\n}\n\n'})})})]}),"\n",(0,r.jsx)(t.h2,{id:"useful",children:"Useful"}),"\n",(0,r.jsx)(t.h3,{id:"download-example-net--c-",children:"Download Example (.NET  C# )"}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(85154).A+"",children:"Download Example project DomainPrimitives "})})}),"\n",(0,r.jsx)(t.h3,{id:"share-domainprimitives",children:"Share DomainPrimitives"}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives&quote=DomainPrimitives",title:"Share on Facebook",target:"_blank",children:"Share on Facebook"})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives&text=DomainPrimitives:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives",target:"_blank",title:"Tweet",children:"Share in Twitter"})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives&title=DomainPrimitives",target:"_blank",title:"Submit to Reddit",children:"Share on Reddit"})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives&title=DomainPrimitives&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FDomainPrimitives",target:"_blank",title:"Share on LinkedIn",children:"Share on Linkedin"})})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/DomainPrimitives",children:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/DomainPrimitives"})}),"\n",(0,r.jsx)(t.h3,{id:"in-the-same-category-primitiveobsession---4-other-generators",children:"In the same category (PrimitiveObsession) - 4 other generators"}),"\n",(0,r.jsx)(d,{})]})}function g(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},85154:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/files/DomainPrimitives-fb299eedd08fa14f01e555a2fd14f378.zip"}}]);