"use strict";(self.webpackChunkrscg_examples=self.webpackChunkrscg_examples||[]).push([[3738],{9217:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>g,toc:()=>u});var t=a(87462),s=(a(67294),a(3905)),r=a(73992),T=a(18679),l=a(68839);const i={sidebar_position:1630,title:"163 - TypedSignalR.Client",description:"Creating typed Signal R clients",slug:"/TypedSignalR.Client"},o="TypedSignalR.Client  by nenoNaninu",g={unversionedId:"RSCG-Examples/TypedSignalR.Client",id:"RSCG-Examples/TypedSignalR.Client",title:"163 - TypedSignalR.Client",description:"Creating typed Signal R clients",source:"@site/docs/RSCG-Examples/TypedSignalR.Client.md",sourceDirName:"RSCG-Examples",slug:"/TypedSignalR.Client",permalink:"/RSCG_Examples/v2/docs/TypedSignalR.Client",draft:!1,tags:[],version:"current",sidebarPosition:1630,frontMatter:{sidebar_position:1630,title:"163 - TypedSignalR.Client",description:"Creating typed Signal R clients",slug:"/TypedSignalR.Client"},sidebar:"tutorialSidebar",previous:{title:"162 - MinimalHelpers.Routing.Analyzers",permalink:"/RSCG_Examples/v2/docs/MinimalHelpers.Routing.Analyzers"},next:{title:"164 - RazorSlices",permalink:"/RSCG_Examples/v2/docs/RazorSlices"}},c={},u=[{value:"Nuget / site data",id:"nuget--site-data",level:2},{value:"Details",id:"details",level:2},{value:"Info",id:"info",level:3},{value:"Original Readme",id:"original-readme",level:3},{value:"About",id:"about",level:3},{value:"How to use",id:"how-to-use",level:2},{value:"Example ( source csproj, source files )",id:"example--source-csproj-source-files-",level:3},{value:"Generated Files",id:"generated-files",level:3},{value:"Usefull",id:"usefull",level:2},{value:"Download Example (.NET  C# )",id:"download-example-net--c-",level:3},{value:"Share TypedSignalR.Client",id:"share-typedsignalrclient",level:3},{value:"In the same category (SignalR) - 0 other generators",id:"in-the-same-category-signalr---0-other-generators",level:3}],d={toc:u},m="wrapper";function p(e){let{components:n,...i}=e;return(0,s.kt)(m,(0,t.Z)({},d,i,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"typedsignalrclient--by-nenonaninu"},"TypedSignalR.Client  by nenoNaninu"),(0,s.kt)(l.Z,{toc:u,mdxType:"TOCInline"}),(0,s.kt)("h2",{id:"nuget--site-data"},"Nuget / site data"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/TypedSignalR.Client/"},(0,s.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/dt/TypedSignalR.Client?label=TypedSignalR.Client",alt:"Nuget"})),"\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/nenoNaninu/TypedSignalR.Client"},(0,s.kt)("img",{parentName:"a",src:"https://img.shields.io/github/last-commit/nenoNaninu/TypedSignalR.Client?label=updated",alt:"GitHub last commit"})),"\n",(0,s.kt)("img",{parentName:"p",src:"https://img.shields.io/github/stars/nenoNaninu/TypedSignalR.Client?style=social",alt:"GitHub Repo stars"})),(0,s.kt)("h2",{id:"details"},"Details"),(0,s.kt)("h3",{id:"info"},"Info"),(0,s.kt)("admonition",{type:"info"},(0,s.kt)("p",{parentName:"admonition"},"Name: ",(0,s.kt)("strong",{parentName:"p"},"TypedSignalR.Client")),(0,s.kt)("p",{parentName:"admonition"},"C# Source Generator to create strongly typed SignalR Client."),(0,s.kt)("p",{parentName:"admonition"},"Author: nenoNaninu"),(0,s.kt)("p",{parentName:"admonition"},"NuGet:\n",(0,s.kt)("em",{parentName:"p"},(0,s.kt)("a",{parentName:"em",href:"https://www.nuget.org/packages/TypedSignalR.Client/"},"https://www.nuget.org/packages/TypedSignalR.Client/")),"   "),(0,s.kt)("p",{parentName:"admonition"},"You can find more details at ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/nenoNaninu/TypedSignalR.Client"},"https://github.com/nenoNaninu/TypedSignalR.Client")),(0,s.kt)("p",{parentName:"admonition"},"Source : ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/nenoNaninu/TypedSignalR.Client"},"https://github.com/nenoNaninu/TypedSignalR.Client"))),(0,s.kt)("h3",{id:"original-readme"},"Original Readme"),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("h1",{parentName:"admonition",id:"typedsignalrclient"},"TypedSignalR.Client"),(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/TypedSignalR.Client"},(0,s.kt)("img",{parentName:"a",src:"https://img.shields.io/nuget/v/TypedSignalR.Client.svg",alt:"NuGet"})),"\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/nenoNaninu/TypedSignalR.Client/actions/workflows/build-and-test.yaml"},(0,s.kt)("img",{parentName:"a",src:"https://github.com/nenoNaninu/TypedSignalR.Client/actions/workflows/build-and-test.yaml/badge.svg?branch=master",alt:"build-and-test"}))),(0,s.kt)("p",{parentName:"admonition"},"C# ",(0,s.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview"},"Source Generator")," to create strongly typed SignalR clients."),(0,s.kt)("h2",{parentName:"admonition",id:"table-of-contents"},"Table of Contents"),(0,s.kt)("ul",{parentName:"admonition"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#install"},"Install")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#why-typedsignalrclient"},"Why TypedSignalR.Client?")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#api"},"API")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#usage"},"Usage"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#client"},"Client"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#cancellation"},"Cancellation")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#server"},"Server")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#recommendation"},"Recommendation"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#sharing-a-project"},"Sharing a Project")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#client-code-format"},"Client Code Format")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#streaming-support"},"Streaming Support")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#client-results-support"},"Client Results Support")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#compile-time-error-support"},"Compile-Time Error Support")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#generated-source-code"},"Generated Source Code")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#related-work"},"Related Work"))),(0,s.kt)("h2",{parentName:"admonition",id:"install"},"Install"),(0,s.kt)("p",{parentName:"admonition"},"NuGet: ",(0,s.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/TypedSignalR.Client/"},"TypedSignalR.Client")),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre"},"dotnet add package Microsoft.AspNetCore.SignalR.Client\ndotnet add package TypedSignalR.Client\n")),(0,s.kt)("h2",{parentName:"admonition",id:"why-typedsignalrclient"},"Why TypedSignalR.Client?"),(0,s.kt)("p",{parentName:"admonition"},"The ASP.NET Core SignalR C# client is not strongly typed.\nTo call a Hub (server-side) method, we must specify the method defined in Hub using a string.\nWe also have to determine the return type manually.\nMoreover, registering client methods called from a server also requires specifying the method name as a string, and we must set parameter types manually."),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-cs"},'// C# SignalR Client\n// without TypedSignalR.Client\n\n// Specify a hub method to invoke using string.\nawait connection.InvokeAsync("HubMethod1");\n\n// Manually determine a return type.\n// Parameters are cast to object type.\nvar guid = await connection.InvokeAsync<Guid>("HubMethod2", "message", 99);\n\n// Registering a client method requires a string, and parameter types must be set manually.\nvar subscription = connection.On<string, DateTime>("ClientMethod", (message, dateTime) => {});\n')),(0,s.kt)("p",{parentName:"admonition"},"These are very painful and cause bugs easily.\nMoreover, if we change the code on the server-side, the modification on the client-side becomes very troublesome.\nThe leading cause of the problems is that they are not strongly typed."),(0,s.kt)("p",{parentName:"admonition"},"TypedSignalR.Client aims to generate strongly typed SignalR clients using interfaces in which the server and client methods are defined.\nDefining interfaces is helpful not only for the client-side but also for the server-side.\nSee ",(0,s.kt)("a",{parentName:"p",href:"#usage"},"Usage")," section for details."),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-cs"},'// C# SignalR Client\n// with TypedSignalR.Client\n\n// First, create a hub proxy.\nIHub hubProxy = connection.CreateHubProxy<IHub>();\n\n// Invoke a hub method through hub proxy.\n// We no longer need to specify the method using a string.\nawait hubProxy.HubMethod1();\n\n// Both parameters and return types are strongly typed.\nvar guid = await hubProxy.HubMethod2("message", 99);\n\n// Client method registration is also strongly typed, so it\'s safe and easy.\nvar subscription = connection.Register<IReceiver>(new Receiver());\n\n// Defining interfaces are useful not only for the client-side but also for the server-side.\n// See Usage in this README.md for details.\ninterface IHub\n{\n    Task HubMethod1();\n    Task<Guid> HubMethod2(string message, int value);\n}\n\ninterface IReceiver\n{\n    Task ClientMethod(string message, DateTime dateTime);\n}\n\nclass Receiver : IReceiver\n{\n    // implementation\n}\n')),(0,s.kt)("h2",{parentName:"admonition",id:"api"},"API"),(0,s.kt)("p",{parentName:"admonition"},"This Source Generator provides two extension methods and one interface. "),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-cs"},"static class HubConnectionExtensions\n{\n    THub CreateHubProxy<THub>(this HubConnection connection, CancellationToken cancellationToken = default){...}\n    IDisposable Register<TReceiver>(this HubConnection connection, TReceiver receiver){...}\n}\n\n// An interface for observing SignalR events.\ninterface IHubConnectionObserver\n{\n    Task OnClosed(Exception? exception);\n    Task OnReconnected(string? connectionId);\n    Task OnReconnecting(Exception? exception);\n}\n")),(0,s.kt)("p",{parentName:"admonition"},"Use it as follows. "),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-cs"},"HubConnection connection = ...;\n\nIHub hub = connection.CreateHubProxy<IHub>();\nIDisposable subscription = connection.Register<IReceiver>(new Receiver());\n")),(0,s.kt)("h2",{parentName:"admonition",id:"usage"},"Usage"),(0,s.kt)("p",{parentName:"admonition"},"For example, we have the following interface defined."),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-cs"},"public class UserDefinedType\n{\n    public Guid Id { get; set; }\n    public DateTime Datetime { get; set; }\n}\n\n// The return type of methods on the client-side must be Task. \npublic interface IClientContract\n{\n    // Of course, user defined type is OK. \n    Task ClientMethod1(string user, string message, UserDefinedType userDefine);\n    Task ClientMethod2();\n}\n\n// The return type of methods on the hub-side must be Task or Task<T>. \npublic interface IHubContract\n{\n    Task<string> HubMethod1(string user, string message);\n    Task HubMethod2();\n}\n\nclass Receiver1 : IClientContract\n{\n    // implementation\n}\n\nclass Receiver2 : IClientContract, IHubConnectionObserver\n{\n    // implementation\n}\n")),(0,s.kt)("h3",{parentName:"admonition",id:"client"},"Client"),(0,s.kt)("p",{parentName:"admonition"},"It's very easy to use. "),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-cs"},'HubConnection connection = ...;\n\nvar hub = connection.CreateHubProxy<IHubContract>();\nvar subscription1 = connection.Register<IClientContract>(new Receiver1());\n\n// When an instance of a class that implements IHubConnectionObserver is registered (Receiver2 in this case), \n// the method defined in IHubConnectionObserver is automatically registered regardless of the type argument. \nvar subscription2 = connection.Register<IClientContract>(new Receiver2());\n\n// Invoke hub methods\nhub.HubMethod1("user", "message");\n\n// Unregister the receiver\nsubscription.Dispose();\n')),(0,s.kt)("h4",{parentName:"admonition",id:"cancellation"},"Cancellation"),(0,s.kt)("p",{parentName:"admonition"},"In ASP.NET Core SignalR, ",(0,s.kt)("inlineCode",{parentName:"p"},"CancellationToken")," is passed for each invoke."),(0,s.kt)("p",{parentName:"admonition"},"On the other hand, in TypedSignalR.Client, ",(0,s.kt)("inlineCode",{parentName:"p"},"CancellationToken")," is passed only once when creating a hub proxy.\nThe passed ",(0,s.kt)("inlineCode",{parentName:"p"},"CancelationToken")," will be used for each invoke internally."),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-cs"},'var cts = new CancellationTokenSource();\n\n// The following two are equivalent.\n\n// 1: ASP.NET Core SignalR Client\nvar ret =  await connection.InvokeAsync<string>("HubMethod1", "user", "message", cts.Token);\nawait connection.InvokeAsync("HubMethod2", cts.Token);\n\n// 2: TypedSignalR.Client\nvar hubProxy = connection.CreateHubProxy<IHubContract>(cts.Token);\nvar ret = await hubProxy.HubMethod1("user", "message");\nawait hubProxy.HubMethod2();\n')),(0,s.kt)("h3",{parentName:"admonition",id:"server"},"Server"),(0,s.kt)("p",{parentName:"admonition"},"Using the interface definitions, we can write as follows on the server-side (ASP.NET Core).\nTypedSignalR.Client is not necessary."),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-cs"},'using Microsoft.AspNetCore.SignalR;\n\npublic class SomeHub : Hub<IClientContract>, IHubContract\n{\n    public async Task<string> HubMethod1(string user, string message)\n    {\n        var instance = new UserDefinedType()\n        {\n            Id = Guid.NewGuid(),\n            DateTime = DateTime.Now,\n        };\n\n        // broadcast\n        await this.Clients.All.ClientMethod1(user, message, instance);\n        return "OK!";\n    }\n\n    public async Task HubMethod2()\n    {\n        await this.Clients.Caller.ClientMethod2();\n    }\n}\n')),(0,s.kt)("h2",{parentName:"admonition",id:"recommendation"},"Recommendation"),(0,s.kt)("h3",{parentName:"admonition",id:"sharing-a-project"},"Sharing a Project"),(0,s.kt)("p",{parentName:"admonition"},"I recommend that these interfaces be shared between the client-side and server-side project, for example, by project references."),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre"},"server.csproj --\x3e shared.csproj <-- client.csproj\n")),(0,s.kt)("h3",{parentName:"admonition",id:"client-code-format"},"Client Code Format"),(0,s.kt)("p",{parentName:"admonition"},"It is easier to handle if we write client code in the following format."),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-cs"},"class Client : IReceiver, IHubConnectionObserver, IDisposable\n{\n    private readonly IHub _hubProxy;\n    private readonly IDisposable _subscription;\n    private readonly CancellationTokenSource _cancellationTokenSource = new();\n\n    public Client(HubConnection connection)\n    {\n        _hubProxy = connection.CreateHubProxy<IHub>(_cancellationTokenSource.Token);\n        _subscription = connection.Register<IReceiver>(this);\n    }\n\n    // implementation\n}\n")),(0,s.kt)("h2",{parentName:"admonition",id:"streaming-support"},"Streaming Support"),(0,s.kt)("p",{parentName:"admonition"},"SignalR supports both ",(0,s.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/aspnet/core/signalr/streaming?view=aspnetcore-6.0"},"server-to-client streaming and client-to-server streaming"),"."),(0,s.kt)("p",{parentName:"admonition"},"TypedSignalR.Client supports both server-to-client streaming and client-to-server streaming.\nIf you use ",(0,s.kt)("inlineCode",{parentName:"p"},"IAsyncEnumerable<T>"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Task<IAsyncEnumerable<T>>"),", or ",(0,s.kt)("inlineCode",{parentName:"p"},"Task<ChannelReader<T>>")," for the method return type, it is analyzed as server-to-client streaming.\nAnd if ",(0,s.kt)("inlineCode",{parentName:"p"},"IAsyncEnumerable<T>")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"ChannelReader<T>")," is used in the method parameter, it is analyzed as client-to-server streaming."),(0,s.kt)("p",{parentName:"admonition"},"When using server-to-client streaming, a single ",(0,s.kt)("inlineCode",{parentName:"p"},"CancellationToken")," can be used as a method parameter (Note: ",(0,s.kt)("inlineCode",{parentName:"p"},"CancellationToken")," cannot be used as a parameter except for server-to-client streaming)."),(0,s.kt)("h2",{parentName:"admonition",id:"client-results-support"},"Client Results Support"),(0,s.kt)("p",{parentName:"admonition"},".NET 7 and later, you can use ",(0,s.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/aspnet/core/signalr/hubs?view=aspnetcore-7.0#client-results"},"client results"),"."),(0,s.kt)("p",{parentName:"admonition"},"TypedSignalR.Client supports client results.\nIf you use ",(0,s.kt)("inlineCode",{parentName:"p"},"Task<T>")," for the method return type in the receiver interface, you can use client results."),(0,s.kt)("h2",{parentName:"admonition",id:"compile-time-error-support"},"Compile-Time Error Support"),(0,s.kt)("p",{parentName:"admonition"},"This library has some restrictions, including those that come from server-side implementations."),(0,s.kt)("ul",{parentName:"admonition"},(0,s.kt)("li",{parentName:"ul"},"Type argument of the ",(0,s.kt)("inlineCode",{parentName:"li"},"CreateHubProxy/Register")," method must be an interface."),(0,s.kt)("li",{parentName:"ul"},"Only method definitions are allowed in the interface used for ",(0,s.kt)("inlineCode",{parentName:"li"},"CreateHubProxy/Register"),".",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"It is forbidden to define properties and events."))),(0,s.kt)("li",{parentName:"ul"},"The return type of the method in the interface used for ",(0,s.kt)("inlineCode",{parentName:"li"},"CreateHubProxy")," must be ",(0,s.kt)("inlineCode",{parentName:"li"},"Task")," or ",(0,s.kt)("inlineCode",{parentName:"li"},"Task<T>"),"."),(0,s.kt)("li",{parentName:"ul"},"The return type of the method in the interface used for ",(0,s.kt)("inlineCode",{parentName:"li"},"Register")," must be ",(0,s.kt)("inlineCode",{parentName:"li"},"Task"),".")),(0,s.kt)("p",{parentName:"admonition"},"It is complicated for humans to comply with these restrictions properly.\nSo, this library looks for parts that do not follow the restriction and report detailed errors at compile time.\nTherefore, no runtime error occurs. "),(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/27144255/155505022-0a13bf1b-643c-472c-882e-8508e52c2b63.png",alt:"compile-time-error"})),(0,s.kt)("h2",{parentName:"admonition",id:"generated-source-code"},"Generated Source Code"),(0,s.kt)("p",{parentName:"admonition"},"TypedSignalR.Client checks the type argument of a methods ",(0,s.kt)("inlineCode",{parentName:"p"},"CreateHubProxy")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Register")," and generates source code.\nGenerated source code can be seen in Visual Studio. "),(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/27144255/154827948-dca0b9b1-0a1b-4833-8b32-3d5ceaa41414.png",alt:"generated-code-visible-from-solution-explorer"})),(0,s.kt)("h2",{parentName:"admonition",id:"related-work"},"Related Work"),(0,s.kt)("ul",{parentName:"admonition"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/nenoNaninu/TypedSignalR.Client.TypeScript"},"nenoNaninu/TypedSignalR.Client.TypeScript"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"TypeScript source generator to provide strongly typed SignalR clients by analyzing C# type definitions."))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/nenoNaninu/TypedSignalR.Client.DevTools"},"nenoNaninu/TypedSignalR.Client.DevTools"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"SignalR development tools inspired by SwaggerUI."))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/nenoNaninu/AspNetCore.SignalR.OpenTelemetry"},"nenoNaninu/AspNetCore.SignalR.OpenTelemetry"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"SignalR instrumentation library for OpenTelemetry."))))),(0,s.kt)("h3",{id:"about"},"About"),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"Creating typed Signal R clients")),(0,s.kt)("h2",{id:"how-to-use"},"How to use"),(0,s.kt)("h3",{id:"example--source-csproj-source-files-"},"Example ( source csproj, source files )"),(0,s.kt)(r.Z,{mdxType:"Tabs"},(0,s.kt)(T.Z,{value:"csproj",label:"CSharp Project",mdxType:"TabItem"},(0,s.kt)("p",null,"This is the CSharp Project that references ",(0,s.kt)("strong",{parentName:"p"},"TypedSignalR.Client")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-xml",metastring:"showLineNumbers {12}",showLineNumbers:!0,"{12}":!0},'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n    <ItemGroup>\n        <PackageReference Include="Microsoft.AspNetCore.SignalR.Client" Version="6.0.1" />\n        <PackageReference Include="TypedSignalR.Client" Version="3.6.0">\n          <PrivateAssets>all</PrivateAssets>\n          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n        </PackageReference>\n    </ItemGroup>\n\n    <ItemGroup>\n      <ProjectReference Include="..\\TestSignalRCommon\\TestSignalRCommon.csproj" />\n    </ItemGroup>\n\n    <PropertyGroup>\n        <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>\n        <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GX</CompilerGeneratedFilesOutputPath>\n    </PropertyGroup>\n    \n</Project>\n\n'))),(0,s.kt)(T.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\TypedSignalR.Client\\src\\TestSignalRConsole\\Program.cs",label:"Program.cs",mdxType:"TabItem"},(0,s.kt)("p",null,"  This is the use of ",(0,s.kt)("strong",{parentName:"p"},"TypedSignalR.Client")," in ",(0,s.kt)("em",{parentName:"p"},"Program.cs")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// See https://aka.ms/new-console-template for more information\nusing Microsoft.AspNetCore.SignalR.Client;\nusing TestSignalRCommon;\nusing TestSignalRConsole;\n\nConsole.WriteLine("Hello, World!");\nawait Task.Delay(5_000);\nHubConnection _connection = new HubConnectionBuilder()\n    .WithUrl("https://localhost:7302/ChatHub")\n    .Build();\nawait _connection.StartAsync();\n\n_connection.On<string, string>("ReceiveMessage", (user, message) =>\n{\n    Console.WriteLine($" from not typed {user}: {message}");\n});\n\nawait Task.Delay(30_000);\nvar h = TypedSignalR.Client.HubConnectionExtensions.CreateHubProxy<IHubMessage>(_connection);\nawait h.SendMessage("console", "message");\n//TypedSignalR.Client.HubConnectionExtensions.Register<IHubMessage>(_connection,new ReceiverMessage());\n\nConsole.WriteLine("waiting for messages from Windows App");\nvar message = Console.ReadLine();\n\n\n\n')))),(0,s.kt)("h3",{id:"generated-files"},"Generated Files"),(0,s.kt)("p",null,"Those are taken from $(BaseIntermediateOutputPath)\\GX"),(0,s.kt)(r.Z,{mdxType:"Tabs"},(0,s.kt)(T.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\TypedSignalR.Client\\src\\TestSignalRConsole\\obj\\GX\\TypedSignalR.Client\\TypedSignalR.Client.SourceGenerator\\TypedSignalR.Client.Components.Generated.cs",label:"TypedSignalR.Client.Components.Generated.cs",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY TypedSignalR.Client\n// </auto-generated>\n#nullable enable\n#pragma warning disable CS1591\nnamespace TypedSignalR.Client\n{\n    internal interface IHubConnectionObserver\n    {\n        global::System.Threading.Tasks.Task OnClosed(global::System.Exception? exception);\n        global::System.Threading.Tasks.Task OnReconnected(string? connectionId);\n        global::System.Threading.Tasks.Task OnReconnecting(global::System.Exception? exception);\n    }\n\n    internal interface IHubInvoker\n    {\n    }\n\n    internal interface IHubInvokerFactory\n    {\n    }\n\n    internal interface IHubInvokerFactory<out T> : IHubInvokerFactory\n    {\n        T CreateHubInvoker(global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, global::System.Threading.CancellationToken cancellationToken);\n    }\n\n    internal interface IReceiverBinder\n    {\n    }\n\n    internal interface IReceiverBinder<in T> : IReceiverBinder\n    {\n        global::System.IDisposable Bind(global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, T receiver);\n    }\n}\n#pragma warning restore CS1591\n\n"))),(0,s.kt)(T.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\TypedSignalR.Client\\src\\TestSignalRConsole\\obj\\GX\\TypedSignalR.Client\\TypedSignalR.Client.SourceGenerator\\TypedSignalR.Client.HubConnectionExtensions.Binder.Generated.cs",label:"TypedSignalR.Client.HubConnectionExtensions.Binder.Generated.cs",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY TypedSignalR.Client\n// </auto-generated>\n#nullable enable\n#pragma warning disable CS1591\n#pragma warning disable CS8767\n#pragma warning disable CS8613\nnamespace TypedSignalR.Client\n{\n    internal static partial class HubConnectionExtensions\n    {\n        private static partial global::System.Collections.Generic.Dictionary<global::System.Type, IReceiverBinder> CreateBinders()\n        {\n            var binders = new global::System.Collections.Generic.Dictionary<global::System.Type, IReceiverBinder>();\n\n\n            return binders;\n        }\n    }\n}\n#pragma warning restore CS8613\n#pragma warning restore CS8767\n#pragma warning restore CS1591\n\n"))),(0,s.kt)(T.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\TypedSignalR.Client\\src\\TestSignalRConsole\\obj\\GX\\TypedSignalR.Client\\TypedSignalR.Client.SourceGenerator\\TypedSignalR.Client.HubConnectionExtensions.Generated.cs",label:"TypedSignalR.Client.HubConnectionExtensions.Generated.cs",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},'// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY TypedSignalR.Client\n// </auto-generated>\n#nullable enable\n#pragma warning disable CS1591\nnamespace TypedSignalR.Client\n{\n    internal static partial class HubConnectionExtensions\n    {\n        public static THub CreateHubProxy<THub>(this global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, global::System.Threading.CancellationToken cancellationToken = default)\n        {\n            var factory = HubInvokerFactoryProvider.GetHubInvokerFactory<THub>();\n\n            if (factory is null)\n            {\n                throw new global::System.InvalidOperationException($"Failed to create a hub proxy. TypedSignalR.Client did not generate source code to create a hub proxy, which type is {typeof(THub)}.");\n            }\n\n            return factory.CreateHubInvoker(connection, cancellationToken);\n        }\n\n        public static global::System.IDisposable Register<TReceiver>(this global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, TReceiver receiver)\n        {\n            if (receiver is null)\n            {\n                throw new global::System.ArgumentNullException(nameof(receiver));\n            }\n\n            if (typeof(TReceiver) == typeof(IHubConnectionObserver))\n            {\n                return new HubConnectionObserverSubscription(connection, (IHubConnectionObserver)receiver);\n            }\n\n            var binder = ReceiverBinderProvider.GetReceiverBinder<TReceiver>();\n\n            if (binder is null)\n            {\n                throw new global::System.InvalidOperationException($"Failed to register a receiver. TypedSignalR.Client did not generate source code to register a receiver, which type is {typeof(TReceiver)}.");\n            }\n\n            var subscription = binder.Bind(connection, receiver);\n\n            if (receiver is IHubConnectionObserver hubConnectionObserver)\n            {\n                subscription = new CompositeDisposable(new[] { subscription, new HubConnectionObserverSubscription(connection, hubConnectionObserver) });\n            }\n\n            return subscription;\n        }\n    }\n\n    internal static partial class HubConnectionExtensions\n    {\n        private static partial global::System.Collections.Generic.Dictionary<global::System.Type, IHubInvokerFactory> CreateFactories();\n        private static partial global::System.Collections.Generic.Dictionary<global::System.Type, IReceiverBinder> CreateBinders();\n\n        private static class HubInvokerFactoryProvider\n        {\n            private static readonly global::System.Collections.Generic.Dictionary<global::System.Type, IHubInvokerFactory> Factories;\n\n            static HubInvokerFactoryProvider()\n            {\n                Factories = CreateFactories();\n            }\n\n            public static IHubInvokerFactory<T>? GetHubInvokerFactory<T>()\n            {\n                return Cache<T>.HubInvokerFactory;\n            }\n\n            private static class Cache<T>\n            {\n                public static readonly IHubInvokerFactory<T>? HubInvokerFactory = default;\n\n                static Cache()\n                {\n                    if (Factories.TryGetValue(typeof(T), out var hubInvokerFactory))\n                    {\n                        HubInvokerFactory = hubInvokerFactory as IHubInvokerFactory<T>;\n                    }\n                }\n            }\n        }\n\n        private static class ReceiverBinderProvider\n        {\n            private static readonly global::System.Collections.Generic.Dictionary<global::System.Type, IReceiverBinder> Binders;\n\n            static ReceiverBinderProvider()\n            {\n                Binders = CreateBinders();\n            }\n\n            public static IReceiverBinder<T>? GetReceiverBinder<T>()\n            {\n                return Cache<T>.ReceiverBinder;\n            }\n\n            private static class Cache<T>\n            {\n                public static readonly IReceiverBinder<T>? ReceiverBinder = default;\n\n                static Cache()\n                {\n                    if (Binders.TryGetValue(typeof(T), out var receiverBinder))\n                    {\n                        ReceiverBinder = receiverBinder as IReceiverBinder<T>;\n                    }\n                }\n            }\n        }\n\n        private sealed class HubConnectionObserverSubscription : global::System.IDisposable\n        {\n            private readonly global::Microsoft.AspNetCore.SignalR.Client.HubConnection _connection;\n            private readonly IHubConnectionObserver _hubConnectionObserver;\n\n            private int _disposed = 0;\n\n            public HubConnectionObserverSubscription(global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, IHubConnectionObserver hubConnectionObserver)\n            {\n                _connection = connection;\n                _hubConnectionObserver = hubConnectionObserver;\n\n                _connection.Closed += hubConnectionObserver.OnClosed;\n                _connection.Reconnected += hubConnectionObserver.OnReconnected;\n                _connection.Reconnecting += hubConnectionObserver.OnReconnecting;\n            }\n\n            public void Dispose()\n            {\n                if (global::System.Threading.Interlocked.Exchange(ref _disposed, 1) == 0)\n                {\n                    _connection.Closed -= _hubConnectionObserver.OnClosed;\n                    _connection.Reconnected -= _hubConnectionObserver.OnReconnected;\n                    _connection.Reconnecting -= _hubConnectionObserver.OnReconnecting;\n                }\n            }\n        }\n\n        private sealed class CompositeDisposable : global::System.IDisposable\n        {\n            private readonly object _gate = new object();\n            private readonly global::System.Collections.Generic.List<global::System.IDisposable> _disposables;\n\n            private bool _disposed;\n\n            public CompositeDisposable()\n            {\n                _disposables = new global::System.Collections.Generic.List<global::System.IDisposable>();\n            }\n\n            public CompositeDisposable(global::System.IDisposable[] disposables)\n            {\n                _disposables = new global::System.Collections.Generic.List<global::System.IDisposable>(disposables);\n            }\n\n            public CompositeDisposable(int capacity)\n            {\n                if (capacity < 0)\n                {\n                    throw new global::System.ArgumentOutOfRangeException(nameof(capacity));\n                }\n\n                _disposables = new global::System.Collections.Generic.List<global::System.IDisposable>(capacity);\n            }\n\n            public void Add(global::System.IDisposable item)\n            {\n                bool shouldDispose = false;\n\n                lock (_gate)\n                {\n                    shouldDispose = _disposed;\n\n                    if (!_disposed)\n                    {\n                        _disposables.Add(item);\n                    }\n                }\n\n                if (shouldDispose)\n                {\n                    item.Dispose();\n                }\n            }\n\n            public void Dispose()\n            {\n                var currentDisposables = default(global::System.Collections.Generic.List<global::System.IDisposable>);\n\n                lock (_gate)\n                {\n                    if (_disposed)\n                    {\n                        return;\n                    }\n\n                    _disposed = true;\n                    currentDisposables = _disposables;\n                }\n\n                foreach (var item in currentDisposables)\n                {\n                    if (item is not null)\n                    {\n                        item.Dispose();\n                    }\n                }\n\n                currentDisposables.Clear();\n            }\n        }\n\n        // It is not possible to avoid boxing.\n        // This is a limitation caused by the SignalR implementation.\n        private static class HandlerConverter\n        {\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert(global::System.Func<global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler();\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1>(global::System.Func<T1, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2>(global::System.Func<T1, T2, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3>(global::System.Func<T1, T2, T3, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4>(global::System.Func<T1, T2, T3, T4, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5>(global::System.Func<T1, T2, T3, T4, T5, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6>(global::System.Func<T1, T2, T3, T4, T5, T6, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, (T14)args[13]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, (T14)args[13]!, (T15)args[14]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, (T14)args[13]!, (T15)args[14]!, (T16)args[15]!);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert(global::System.Func<global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler(default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1>(global::System.Func<T1, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2>(global::System.Func<T1, T2, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3>(global::System.Func<T1, T2, T3, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4>(global::System.Func<T1, T2, T3, T4, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5>(global::System.Func<T1, T2, T3, T4, T5, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6>(global::System.Func<T1, T2, T3, T4, T5, T6, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, (T14)args[13]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task> handler)\n            {\n                return args => handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, (T14)args[13]!, (T15)args[14]!, default);\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<TResult>(global::System.Func<global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler().ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, TResult>(global::System.Func<T1, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, TResult>(global::System.Func<T1, T2, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, TResult>(global::System.Func<T1, T2, T3, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, TResult>(global::System.Func<T1, T2, T3, T4, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, TResult>(global::System.Func<T1, T2, T3, T4, T5, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, (T14)args[13]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, (T14)args[13]!, (T15)args[14]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, (T14)args[13]!, (T15)args[14]!, (T16)args[15]!).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<TResult>(global::System.Func<global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler(default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, TResult>(global::System.Func<T1, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, TResult>(global::System.Func<T1, T2, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, TResult>(global::System.Func<T1, T2, T3, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, TResult>(global::System.Func<T1, T2, T3, T4, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, TResult>(global::System.Func<T1, T2, T3, T4, T5, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, (T14)args[13]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n\n            public static global::System.Func<object?[], global::System.Threading.Tasks.Task<TResult>> Convert<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, global::System.Threading.CancellationToken, global::System.Threading.Tasks.Task<TResult>> handler)\n            {\n                return async args =>\n                {\n                    var result = await handler((T1)args[0]!, (T2)args[1]!, (T3)args[2]!, (T4)args[3]!, (T5)args[4]!, (T6)args[5]!, (T7)args[6]!, (T8)args[7]!, (T9)args[8]!, (T10)args[9]!, (T11)args[10]!, (T12)args[11]!, (T13)args[12]!, (T14)args[13]!, (T15)args[14]!, default).ConfigureAwait(false);\n                    return result;\n                };\n            }\n        }\n    }\n}\n#pragma warning restore CS1591\n\n'))),(0,s.kt)(T.Z,{value:"D:\\gth\\RSCG_Examples\\v2\\rscg_examples\\TypedSignalR.Client\\src\\TestSignalRConsole\\obj\\GX\\TypedSignalR.Client\\TypedSignalR.Client.SourceGenerator\\TypedSignalR.Client.HubConnectionExtensions.HubInvoker.Generated.cs",label:"TypedSignalR.Client.HubConnectionExtensions.HubInvoker.Generated.cs",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"showLineNumbers",showLineNumbers:!0},"// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY TypedSignalR.Client\n// </auto-generated>\n#nullable enable\n#pragma warning disable CS1591\n#pragma warning disable CS8767\n#pragma warning disable CS8613\nnamespace TypedSignalR.Client\n{\n    internal static partial class HubConnectionExtensions\n    {\n        private sealed class HubInvokerFor_global__TestSignalRCommon_IHubMessage : global::TestSignalRCommon.IHubMessage, IHubInvoker\n        {\n            private readonly global::Microsoft.AspNetCore.SignalR.Client.HubConnection _connection;\n            private readonly global::System.Threading.CancellationToken _cancellationToken;\n\n            public HubInvokerFor_global__TestSignalRCommon_IHubMessage(global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, global::System.Threading.CancellationToken cancellationToken)\n            {\n                _connection = connection;\n                _cancellationToken = cancellationToken;\n            }\n\n            public global::System.Threading.Tasks.Task SendMessage(string user, string message)\n            {\n                return global::Microsoft.AspNetCore.SignalR.Client.HubConnectionExtensions.InvokeCoreAsync(_connection, nameof(SendMessage), new object?[] { user, message }, _cancellationToken);\n            }\n        }\n\n        private sealed class HubInvokerFactoryFor_global__TestSignalRCommon_IHubMessage : IHubInvokerFactory<global::TestSignalRCommon.IHubMessage>\n        {\n            public global::TestSignalRCommon.IHubMessage CreateHubInvoker(global::Microsoft.AspNetCore.SignalR.Client.HubConnection connection, global::System.Threading.CancellationToken cancellationToken)\n            {\n                return new HubInvokerFor_global__TestSignalRCommon_IHubMessage(connection, cancellationToken);\n            }\n        }\n\n        private static partial global::System.Collections.Generic.Dictionary<global::System.Type, IHubInvokerFactory> CreateFactories()\n        {\n            var factories = new global::System.Collections.Generic.Dictionary<global::System.Type, IHubInvokerFactory>();\n\n            factories.Add(typeof(global::TestSignalRCommon.IHubMessage), new HubInvokerFactoryFor_global__TestSignalRCommon_IHubMessage());\n\n            return factories;\n        }\n    }\n}\n#pragma warning restore CS8613\n#pragma warning restore CS8767\n#pragma warning restore CS1591\n\n")))),(0,s.kt)("h2",{id:"usefull"},"Usefull"),(0,s.kt)("h3",{id:"download-example-net--c-"},"Download Example (.NET  C# )"),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("a",{target:"_blank",href:a(40670).Z},"Download Example project TypedSignalR.Client "))),(0,s.kt)("h3",{id:"share-typedsignalrclient"},"Share TypedSignalR.Client"),(0,s.kt)("ul",null,(0,s.kt)("li",null,(0,s.kt)("a",{href:"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FTypedSignalR.Client&quote=TypedSignalR.Client",title:"Share on Facebook",target:"_blank"},"Share on Facebook")),(0,s.kt)("li",null,(0,s.kt)("a",{href:"https://twitter.com/intent/tweet?source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FTypedSignalR.Client&text=TypedSignalR.Client:%20https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FTypedSignalR.Client",target:"_blank",title:"Tweet"},"Share in Twitter")),(0,s.kt)("li",null,(0,s.kt)("a",{href:"http://www.reddit.com/submit?url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FTypedSignalR.Client&title=TypedSignalR.Client",target:"_blank",title:"Submit to Reddit"},"Share on Reddit")),(0,s.kt)("li",null,(0,s.kt)("a",{href:"http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FTypedSignalR.Client&title=TypedSignalR.Client&summary=&source=https%3A%2F%2Fignatandrei.github.io%2FRSCG_Examples%2Fv2%2Fdocs%2FTypedSignalR.Client",target:"_blank",title:"Share on LinkedIn"},"Share on Linkedin"))),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://ignatandrei.github.io/RSCG_Examples/v2/docs/TypedSignalR.Client"},"https://ignatandrei.github.io/RSCG_Examples/v2/docs/TypedSignalR.Client")),(0,s.kt)("h3",{id:"in-the-same-category-signalr---0-other-generators"},"In the same category (SignalR) - 0 other generators"))}p.isMDXComponent=!0},40670:(e,n,a)=>{a.d(n,{Z:()=>t});const t=a.p+"assets/files/TypedSignalR.Client-e736bc6906a22ee0b06e022680d5cfde.zip"}}]);